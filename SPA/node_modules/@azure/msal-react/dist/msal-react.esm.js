import React__default, { createContext, useEffect, useMemo, useState, useContext, useCallback } from 'react';
import { stubbedPublicClientApplication, InteractionStatus, Logger, WrapperSKU, EventType, EventMessageUtils, AccountEntity, InteractionType } from '@azure/msal-browser';

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/*
 * Stubbed context implementation
 * Only used when there is no provider, which is an unsupported scenario
 */

const defaultMsalContext = {
  instance: stubbedPublicClientApplication,
  inProgress: InteractionStatus.None,
  accounts: [],
  logger: /*#__PURE__*/new Logger({})
};
const MsalContext = /*#__PURE__*/createContext(defaultMsalContext);
const MsalConsumer = MsalContext.Consumer;

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function getChildrenOrFunction(children, args) {
  if (typeof children === "function") {
    return children(args);
  }

  return children;
}
/**
 * Helper function to determine whether 2 arrays are equal
 * Used to avoid unnecessary state updates
 * @param arrayA
 * @param arrayB
 */

function accountArraysAreEqual(arrayA, arrayB) {
  if (arrayA.length !== arrayB.length) {
    return false;
  }

  const comparisonArray = [...arrayB];
  return arrayA.every(elementA => {
    const elementB = comparisonArray.shift();

    if (!elementA || !elementB) {
      return false;
    }

    return elementA.homeAccountId === elementB.homeAccountId && elementA.localAccountId === elementB.localAccountId && elementA.username === elementB.username;
  });
}

/* eslint-disable header/header */
const name = "@azure/msal-react";
const version = "1.0.1";

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
function MsalProvider({
  instance,
  children
}) {
  useEffect(() => {
    instance.initializeWrapperLibrary(WrapperSKU.React, version);
  }, [instance]); // Create a logger instance for msal-react with the same options as PublicClientApplication

  const logger = useMemo(() => {
    return instance.getLogger().clone(name, version);
  }, [instance]); // State hook to store accounts

  const [accounts, setAccounts] = useState([]); // State hook to store in progress value

  const [inProgress, setInProgress] = useState(InteractionStatus.Startup);
  useEffect(() => {
    const callbackId = instance.addEventCallback(message => {
      switch (message.eventType) {
        case EventType.LOGIN_SUCCESS:
        case EventType.SSO_SILENT_SUCCESS:
        case EventType.HANDLE_REDIRECT_END:
        case EventType.LOGIN_FAILURE:
        case EventType.SSO_SILENT_FAILURE:
        case EventType.LOGOUT_END:
        case EventType.ACQUIRE_TOKEN_SUCCESS:
        case EventType.ACQUIRE_TOKEN_FAILURE:
          const currentAccounts = instance.getAllAccounts();

          if (!accountArraysAreEqual(currentAccounts, accounts)) {
            logger.info("MsalProvider - updating account state");
            setAccounts(currentAccounts);
          } else {
            logger.info("MsalProvider - no account changes");
          }

          break;
      }
    });
    logger.verbose(`MsalProvider - Registered event callback with id: ${callbackId}`);
    return () => {
      // Remove callback when component unmounts or accounts change
      if (callbackId) {
        logger.verbose(`MsalProvider - Removing event callback ${callbackId}`);
        instance.removeEventCallback(callbackId);
      }
    };
  }, [instance, accounts, logger]);
  useEffect(() => {
    const callbackId = instance.addEventCallback(message => {
      const status = EventMessageUtils.getInteractionStatusFromEvent(message);

      if (status !== null) {
        logger.info(`MsalProvider - ${message.eventType} results in setting inProgress to ${status}`);
        setInProgress(status);
      }
    });
    logger.verbose(`MsalProvider - Registered event callback with id: ${callbackId}`);
    instance.handleRedirectPromise().catch(() => {
      // Errors should be handled by listening to the LOGIN_FAILURE event
      return;
    });
    return () => {
      if (callbackId) {
        logger.verbose(`MsalProvider - Removing event callback ${callbackId}`);
        instance.removeEventCallback(callbackId);
      }
    };
  }, [instance, logger]);
  const contextValue = {
    instance,
    inProgress,
    accounts,
    logger
  };
  return React__default.createElement(MsalContext.Provider, {
    value: contextValue
  }, children);
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Returns Msal Context values
 */

const useMsal = () => useContext(MsalContext);

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function getAccount(instance, accountIdentifiers) {
  const allAccounts = instance.getAllAccounts();

  if (allAccounts.length > 0 && (accountIdentifiers.homeAccountId || accountIdentifiers.localAccountId || accountIdentifiers.username)) {
    const matchedAccounts = allAccounts.filter(accountObj => {
      if (accountIdentifiers.username && accountIdentifiers.username.toLowerCase() !== accountObj.username.toLowerCase()) {
        return false;
      }

      if (accountIdentifiers.homeAccountId && accountIdentifiers.homeAccountId.toLowerCase() !== accountObj.homeAccountId.toLowerCase()) {
        return false;
      }

      if (accountIdentifiers.localAccountId && accountIdentifiers.localAccountId.toLowerCase() !== accountObj.localAccountId.toLowerCase()) {
        return false;
      }

      return true;
    });
    return matchedAccounts[0] || null;
  } else {
    return null;
  }
}
/**
 * Given 1 or more accountIdentifiers, returns the Account object if the user is signed-in
 * @param accountIdentifiers
 */


function useAccount(accountIdentifiers) {
  const {
    instance,
    inProgress
  } = useMsal();
  const initialStateValue = inProgress === InteractionStatus.Startup ? null : getAccount(instance, accountIdentifiers);
  const [account, setAccount] = useState(initialStateValue);
  useEffect(() => {
    const currentAccount = getAccount(instance, accountIdentifiers);

    if (!AccountEntity.accountInfoIsEqual(account, currentAccount, true)) {
      setAccount(currentAccount);
    }
  }, [inProgress, accountIdentifiers, instance, account]);
  return account;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */

function isAuthenticated(allAccounts, account, matchAccount) {
  if (matchAccount && (matchAccount.username || matchAccount.homeAccountId || matchAccount.localAccountId)) {
    return !!account;
  }

  return allAccounts.length > 0;
}
/**
 * Returns whether or not a user is currently signed-in. Optionally provide 1 or more accountIdentifiers to determine if a specific user is signed-in
 * @param matchAccount
 */


function useIsAuthenticated(matchAccount) {
  const {
    accounts: allAccounts,
    inProgress
  } = useMsal();
  const account = useAccount(matchAccount || {});
  const initialStateValue = inProgress === InteractionStatus.Startup ? false : isAuthenticated(allAccounts, account, matchAccount);
  const [hasAuthenticated, setHasAuthenticated] = useState(initialStateValue);
  useEffect(() => {
    setHasAuthenticated(isAuthenticated(allAccounts, account, matchAccount));
  }, [allAccounts, account, matchAccount]);
  return hasAuthenticated;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Renders child components if user is authenticated
 * @param props
 */

function AuthenticatedTemplate({
  username,
  homeAccountId,
  localAccountId,
  children
}) {
  const context = useMsal();
  const accountIdentifier = useMemo(() => {
    return {
      username,
      homeAccountId,
      localAccountId
    };
  }, [username, homeAccountId, localAccountId]);
  const isAuthenticated = useIsAuthenticated(accountIdentifier);

  if (isAuthenticated && context.inProgress !== InteractionStatus.Startup) {
    return React__default.createElement(React__default.Fragment, null, getChildrenOrFunction(children, context));
  }

  return null;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Renders child components if user is unauthenticated
 * @param props
 */

function UnauthenticatedTemplate({
  username,
  homeAccountId,
  localAccountId,
  children
}) {
  const context = useMsal();
  const accountIdentifier = useMemo(() => {
    return {
      username,
      homeAccountId,
      localAccountId
    };
  }, [username, homeAccountId, localAccountId]);
  const isAuthenticated = useIsAuthenticated(accountIdentifier);

  if (!isAuthenticated && context.inProgress !== InteractionStatus.Startup && context.inProgress !== InteractionStatus.HandleRedirect) {
    return React__default.createElement(React__default.Fragment, null, getChildrenOrFunction(children, context));
  }

  return null;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Invokes a login call if a user is not currently signed-in. Failed logins can be retried using the login callback returned.
 * Optionally provide a request object to be used in the login call.
 * Optionally provide a specific user that should be logged in.
 * @param interactionType
 * @param authenticationRequest
 * @param accountIdentifiers
 */

function useMsalAuthentication(interactionType, authenticationRequest, accountIdentifiers) {
  const {
    instance,
    inProgress,
    logger
  } = useMsal();
  const isAuthenticated = useIsAuthenticated(accountIdentifiers);
  const [[result, error], setResponse] = useState([null, null]);
  const [hasBeenCalled, setHasBeenCalled] = useState(false);
  const login = useCallback(async (callbackInteractionType, callbackRequest) => {
    const loginType = callbackInteractionType || interactionType;
    const loginRequest = callbackRequest || authenticationRequest;

    switch (loginType) {
      case InteractionType.Popup:
        logger.verbose("useMsalAuthentication - Calling loginPopup");
        return instance.loginPopup(loginRequest);

      case InteractionType.Redirect:
        // This promise is not expected to resolve due to full frame redirect
        logger.verbose("useMsalAuthentication - Calling loginRedirect");
        return instance.loginRedirect(loginRequest).then(null);

      case InteractionType.Silent:
        logger.verbose("useMsalAuthentication - Calling ssoSilent");
        return instance.ssoSilent(loginRequest);

      default:
        throw "Invalid interaction type provided.";
    }
  }, [instance, interactionType, authenticationRequest, logger]);
  useEffect(() => {
    const callbackId = instance.addEventCallback(message => {
      switch (message.eventType) {
        case EventType.LOGIN_SUCCESS:
        case EventType.SSO_SILENT_SUCCESS:
          if (message.payload) {
            setResponse([message.payload, null]);
          }

          break;

        case EventType.LOGIN_FAILURE:
        case EventType.SSO_SILENT_FAILURE:
          if (message.error) {
            setResponse([null, message.error]);
          }

          break;
      }
    });
    logger.verbose(`useMsalAuthentication - Registered event callback with id: ${callbackId}`);
    return () => {
      if (callbackId) {
        logger.verbose(`useMsalAuthentication - Removing event callback ${callbackId}`);
        instance.removeEventCallback(callbackId);
      }
    };
  }, [instance, logger]);
  useEffect(() => {
    if (!hasBeenCalled && !error && !isAuthenticated && inProgress === InteractionStatus.None) {
      logger.info("useMsalAuthentication - No user is authenticated, attempting to login"); // Ensure login is only called one time from within this hook, any subsequent login attempts should use the callback returned

      setHasBeenCalled(true);
      login().catch(() => {
        // Errors are handled by the event handler above
        return;
      });
    }
  }, [isAuthenticated, inProgress, error, hasBeenCalled, login, logger]);
  return {
    login,
    result,
    error
  };
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Attempts to authenticate user if not already authenticated, then renders child components
 * @param props
 */

function MsalAuthenticationTemplate({
  interactionType,
  username,
  homeAccountId,
  localAccountId,
  authenticationRequest,
  loadingComponent: LoadingComponent,
  errorComponent: ErrorComponent,
  children
}) {
  const accountIdentifier = useMemo(() => {
    return {
      username,
      homeAccountId,
      localAccountId
    };
  }, [username, homeAccountId, localAccountId]);
  const context = useMsal();
  const msalAuthResult = useMsalAuthentication(interactionType, authenticationRequest, accountIdentifier);
  const isAuthenticated = useIsAuthenticated(accountIdentifier);

  if (msalAuthResult.error && context.inProgress === InteractionStatus.None) {
    if (!!ErrorComponent) {
      return React__default.createElement(ErrorComponent, Object.assign({}, msalAuthResult));
    }

    throw msalAuthResult.error;
  }

  if (isAuthenticated) {
    return React__default.createElement(React__default.Fragment, null, getChildrenOrFunction(children, msalAuthResult));
  }

  if (!!LoadingComponent && context.inProgress !== InteractionStatus.None) {
    return React__default.createElement(LoadingComponent, Object.assign({}, context));
  }

  return null;
}

/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License.
 */
/**
 * Higher order component wraps provided component with msal by injecting msal context values into the component's props
 * @param Component
 */

const withMsal = Component => {
  const ComponentWithMsal = props => {
    const msal = useMsal();
    return React__default.createElement(Component, Object.assign({}, props, {
      msalContext: msal
    }));
  };

  const componentName = Component.displayName || Component.name || "Component";
  ComponentWithMsal.displayName = `withMsal(${componentName})`;
  return ComponentWithMsal;
};

export { AuthenticatedTemplate, MsalAuthenticationTemplate, MsalConsumer, MsalContext, MsalProvider, UnauthenticatedTemplate, useAccount, useIsAuthenticated, useMsal, useMsalAuthentication, withMsal };
//# sourceMappingURL=msal-react.esm.js.map
