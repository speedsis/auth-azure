{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { RequestMethod } from \"../RequestMethod\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { getRequestHeader, setRequestHeader } from \"./MiddlewareUtil\";\nimport { RetryHandlerOptions } from \"./options/RetryHandlerOptions\";\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\n/**\r\n * @class\r\n * @implements Middleware\r\n * Class for RetryHandler\r\n */\n\nexport class RetryHandler {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * To create an instance of RetryHandler\r\n   * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value\r\n   * @returns An instance of RetryHandler\r\n   */\n  constructor(options = new RetryHandlerOptions()) {\n    this.options = options;\n  }\n  /**\r\n   *\r\n   * @private\r\n   * To check whether the response has the retry status code\r\n   * @param {Response} response - The response object\r\n   * @returns Whether the response has retry status code or not\r\n   */\n\n\n  isRetry(response) {\n    return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;\n  }\n  /**\r\n   * @private\r\n   * To check whether the payload is buffered or not\r\n   * @param {RequestInfo} request - The url string or the request object value\r\n   * @param {FetchOptions} options - The options of a request\r\n   * @returns Whether the payload is buffered or not\r\n   */\n\n\n  isBuffered(request, options) {\n    const method = typeof request === \"string\" ? options.method : request.method;\n    const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;\n\n    if (isPutPatchOrPost) {\n      const isStream = getRequestHeader(request, options, \"Content-Type\") === \"application/octet-stream\";\n\n      if (isStream) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\r\n   * @private\r\n   * To get the delay for a retry\r\n   * @param {Response} response - The response object\r\n   * @param {number} retryAttempts - The current attempt count\r\n   * @param {number} delay - The delay value in seconds\r\n   * @returns A delay for a retry\r\n   */\n\n\n  getDelay(response, retryAttempts, delay) {\n    const getRandomness = () => Number(Math.random().toFixed(3));\n\n    const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;\n    let newDelay;\n\n    if (retryAfter !== null) {\n      // tslint:disable: prefer-conditional-expression\n      if (Number.isNaN(Number(retryAfter))) {\n        newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);\n      } else {\n        newDelay = Number(retryAfter);\n      } // tslint:enable: prefer-conditional-expression\n\n    } else {\n      // Adding randomness to avoid retrying at a same\n      newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();\n    }\n\n    return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());\n  }\n  /**\r\n   * @private\r\n   * To get an exponential back off value\r\n   * @param {number} attempts - The current attempt count\r\n   * @returns An exponential back off value\r\n   */\n\n\n  getExponentialBackOffTime(attempts) {\n    return Math.round(1 / 2 * (Math.pow(2, attempts) - 1));\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To add delay for the execution\r\n   * @param {number} delaySeconds - The delay value in seconds\r\n   * @returns Nothing\r\n   */\n\n\n  sleep(delaySeconds) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const delayMilliseconds = delaySeconds * 1000;\n      return new Promise(resolve => setTimeout(resolve, delayMilliseconds));\n    });\n  }\n\n  getOptions(context) {\n    let options;\n\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);\n    }\n\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new RetryHandlerOptions(), this.options);\n    }\n\n    return options;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To execute the middleware with retries\r\n   * @param {Context} context - The context object\r\n   * @param {number} retryAttempts - The current attempt count\r\n   * @param {RetryHandlerOptions} options - The retry middleware options instance\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  executeWithRetry(context, retryAttempts, options) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.nextMiddleware.execute(context);\n\n        if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {\n          ++retryAttempts;\n          setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());\n          const delay = this.getDelay(context.response, retryAttempts, options.delay);\n          yield this.sleep(delay);\n          return yield this.executeWithRetry(context, retryAttempts, options);\n        } else {\n          return;\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * To execute the current middleware\r\n   * @param {Context} context - The context object of the request\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  execute(context) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const retryAttempts = 0;\n        const options = this.getOptions(context);\n        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);\n        return yield this.executeWithRetry(context, retryAttempts, options);\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * To set the next middleware in the chain\r\n   * @param {Middleware} next - The middleware instance\r\n   * @returns Nothing\r\n   */\n\n\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n\n}\n/**\r\n * @private\r\n * @static\r\n * A list of status codes that needs to be retried\r\n */\n\nRetryHandler.RETRY_STATUS_CODES = [429, 503, 504];\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of retry attempt header\r\n */\n\nRetryHandler.RETRY_ATTEMPT_HEADER = \"Retry-Attempt\";\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of retry after header\r\n */\n\nRetryHandler.RETRY_AFTER_HEADER = \"Retry-After\";","map":{"version":3,"sources":["../../../src/middleware/RetryHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { RequestMethod } from \"../RequestMethod\";\r\nimport { MiddlewareControl } from \"./MiddlewareControl\";\r\nimport { getRequestHeader, setRequestHeader } from \"./MiddlewareUtil\";\r\nimport { RetryHandlerOptions } from \"./options/RetryHandlerOptions\";\r\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\r\n/**\r\n * @class\r\n * @implements Middleware\r\n * Class for RetryHandler\r\n */\r\nexport class RetryHandler {\r\n    /**\r\n     * @public\r\n     * @constructor\r\n     * To create an instance of RetryHandler\r\n     * @param {RetryHandlerOptions} [options = new RetryHandlerOptions()] - The retry handler options value\r\n     * @returns An instance of RetryHandler\r\n     */\r\n    constructor(options = new RetryHandlerOptions()) {\r\n        this.options = options;\r\n    }\r\n    /**\r\n     *\r\n     * @private\r\n     * To check whether the response has the retry status code\r\n     * @param {Response} response - The response object\r\n     * @returns Whether the response has retry status code or not\r\n     */\r\n    isRetry(response) {\r\n        return RetryHandler.RETRY_STATUS_CODES.indexOf(response.status) !== -1;\r\n    }\r\n    /**\r\n     * @private\r\n     * To check whether the payload is buffered or not\r\n     * @param {RequestInfo} request - The url string or the request object value\r\n     * @param {FetchOptions} options - The options of a request\r\n     * @returns Whether the payload is buffered or not\r\n     */\r\n    isBuffered(request, options) {\r\n        const method = typeof request === \"string\" ? options.method : request.method;\r\n        const isPutPatchOrPost = method === RequestMethod.PUT || method === RequestMethod.PATCH || method === RequestMethod.POST;\r\n        if (isPutPatchOrPost) {\r\n            const isStream = getRequestHeader(request, options, \"Content-Type\") === \"application/octet-stream\";\r\n            if (isStream) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * @private\r\n     * To get the delay for a retry\r\n     * @param {Response} response - The response object\r\n     * @param {number} retryAttempts - The current attempt count\r\n     * @param {number} delay - The delay value in seconds\r\n     * @returns A delay for a retry\r\n     */\r\n    getDelay(response, retryAttempts, delay) {\r\n        const getRandomness = () => Number(Math.random().toFixed(3));\r\n        const retryAfter = response.headers !== undefined ? response.headers.get(RetryHandler.RETRY_AFTER_HEADER) : null;\r\n        let newDelay;\r\n        if (retryAfter !== null) {\r\n            // tslint:disable: prefer-conditional-expression\r\n            if (Number.isNaN(Number(retryAfter))) {\r\n                newDelay = Math.round((new Date(retryAfter).getTime() - Date.now()) / 1000);\r\n            }\r\n            else {\r\n                newDelay = Number(retryAfter);\r\n            }\r\n            // tslint:enable: prefer-conditional-expression\r\n        }\r\n        else {\r\n            // Adding randomness to avoid retrying at a same\r\n            newDelay = retryAttempts >= 2 ? this.getExponentialBackOffTime(retryAttempts) + delay + getRandomness() : delay + getRandomness();\r\n        }\r\n        return Math.min(newDelay, this.options.getMaxDelay() + getRandomness());\r\n    }\r\n    /**\r\n     * @private\r\n     * To get an exponential back off value\r\n     * @param {number} attempts - The current attempt count\r\n     * @returns An exponential back off value\r\n     */\r\n    getExponentialBackOffTime(attempts) {\r\n        return Math.round((1 / 2) * (Math.pow(2, attempts) - 1));\r\n    }\r\n    /**\r\n     * @private\r\n     * @async\r\n     * To add delay for the execution\r\n     * @param {number} delaySeconds - The delay value in seconds\r\n     * @returns Nothing\r\n     */\r\n    sleep(delaySeconds) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            const delayMilliseconds = delaySeconds * 1000;\r\n            return new Promise((resolve) => setTimeout(resolve, delayMilliseconds));\r\n        });\r\n    }\r\n    getOptions(context) {\r\n        let options;\r\n        if (context.middlewareControl instanceof MiddlewareControl) {\r\n            options = context.middlewareControl.getMiddlewareOptions(this.options.constructor);\r\n        }\r\n        if (typeof options === \"undefined\") {\r\n            options = Object.assign(new RetryHandlerOptions(), this.options);\r\n        }\r\n        return options;\r\n    }\r\n    /**\r\n     * @private\r\n     * @async\r\n     * To execute the middleware with retries\r\n     * @param {Context} context - The context object\r\n     * @param {number} retryAttempts - The current attempt count\r\n     * @param {RetryHandlerOptions} options - The retry middleware options instance\r\n     * @returns A Promise that resolves to nothing\r\n     */\r\n    executeWithRetry(context, retryAttempts, options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield this.nextMiddleware.execute(context);\r\n                if (retryAttempts < options.maxRetries && this.isRetry(context.response) && this.isBuffered(context.request, context.options) && options.shouldRetry(options.delay, retryAttempts, context.request, context.options, context.response)) {\r\n                    ++retryAttempts;\r\n                    setRequestHeader(context.request, context.options, RetryHandler.RETRY_ATTEMPT_HEADER, retryAttempts.toString());\r\n                    const delay = this.getDelay(context.response, retryAttempts, options.delay);\r\n                    yield this.sleep(delay);\r\n                    return yield this.executeWithRetry(context, retryAttempts, options);\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * To execute the current middleware\r\n     * @param {Context} context - The context object of the request\r\n     * @returns A Promise that resolves to nothing\r\n     */\r\n    execute(context) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const retryAttempts = 0;\r\n                const options = this.getOptions(context);\r\n                TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.RETRY_HANDLER_ENABLED);\r\n                return yield this.executeWithRetry(context, retryAttempts, options);\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * To set the next middleware in the chain\r\n     * @param {Middleware} next - The middleware instance\r\n     * @returns Nothing\r\n     */\r\n    setNext(next) {\r\n        this.nextMiddleware = next;\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @static\r\n * A list of status codes that needs to be retried\r\n */\r\nRetryHandler.RETRY_STATUS_CODES = [\r\n    429,\r\n    503,\r\n    504,\r\n];\r\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of retry attempt header\r\n */\r\nRetryHandler.RETRY_ATTEMPT_HEADER = \"Retry-Attempt\";\r\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of retry after header\r\n */\r\nRetryHandler.RETRY_AFTER_HEADER = \"Retry-After\";\r\n//# sourceMappingURL=RetryHandler.js.map"]},"metadata":{},"sourceType":"module"}