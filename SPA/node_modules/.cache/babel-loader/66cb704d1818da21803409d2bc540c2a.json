{"ast":null,"code":"/*! @azure/msal-browser v2.16.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserStringUtils } from '../utils/BrowserStringUtils.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { KEY_FORMAT_JWK } from '../utils/BrowserConstants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\n// RSA KeyGen Algorithm\n\nvar PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\"; // SHA-256 hashing algorithm\n\nvar S256_HASH_ALG = \"SHA-256\"; // MOD length for PoP tokens\n\nvar MODULUS_LENGTH = 2048; // Public Exponent\n\nvar PUBLIC_EXPONENT = new Uint8Array([0x01, 0x00, 0x01]);\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\n\nvar BrowserCrypto = function () {\n  function BrowserCrypto() {\n    if (!this.hasCryptoAPI()) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\n    }\n\n    this._keygenAlgorithmOptions = {\n      name: PKCS1_V15_KEYGEN_ALG,\n      hash: S256_HASH_ALG,\n      modulusLength: MODULUS_LENGTH,\n      publicExponent: PUBLIC_EXPONENT\n    };\n  }\n  /**\r\n   * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n   * @param dataString\r\n   */\n\n\n  BrowserCrypto.prototype.sha256Digest = function (dataString) {\n    return __awaiter(this, void 0, void 0, function () {\n      var data;\n      return __generator(this, function (_a) {\n        data = BrowserStringUtils.stringToUtf8Arr(dataString);\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data)];\n      });\n    });\n  };\n  /**\r\n   * Populates buffer with cryptographically random values.\r\n   * @param dataBuffer\r\n   */\n\n\n  BrowserCrypto.prototype.getRandomValues = function (dataBuffer) {\n    var cryptoObj = window[\"msCrypto\"] || window.crypto;\n\n    if (!cryptoObj.getRandomValues) {\n      throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\n    }\n\n    cryptoObj.getRandomValues(dataBuffer);\n  };\n  /**\r\n   * Generates a keypair based on current keygen algorithm config.\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.generateKeyPair = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoGenerateKey(extractable, usages) : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Export key as Json Web Key (JWK)\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.exportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key)];\n      });\n    });\n  };\n  /**\r\n   * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.importJwk = function (key, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var keyString, keyBuffer;\n      return __generator(this, function (_a) {\n        keyString = BrowserCrypto.getJwkString(key);\n        keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoImportKey(keyBuffer, extractable, usages) : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages)];\n      });\n    });\n  };\n  /**\r\n   * Signs given data with given key\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.sign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.hasIECrypto() ? this.msCryptoSign(key, data) : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data)];\n      });\n    });\n  };\n  /**\r\n   * Check whether IE crypto or other browser cryptography is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasCryptoAPI = function () {\n    return this.hasIECrypto() || this.hasBrowserCrypto();\n  };\n  /**\r\n   * Checks whether IE crypto (AKA msCrypto) is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasIECrypto = function () {\n    return \"msCrypto\" in window;\n  };\n  /**\r\n   * Check whether browser crypto is available.\r\n   */\n\n\n  BrowserCrypto.prototype.hasBrowserCrypto = function () {\n    return \"crypto\" in window;\n  };\n  /**\r\n   * Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.getSubtleCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , window.crypto.subtle.digest(algorithm, data)];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for SHA digest.\r\n   * @param algorithm\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.getMSCryptoDigest = function (algorithm, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\n          digestOperation.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          digestOperation.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for generating a keypair\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoGenerateKey = function (extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msGenerateKey = window[\"msCrypto\"].subtle.generateKey(_this._keygenAlgorithmOptions, extractable, usages);\n          msGenerateKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msGenerateKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for exportKey\r\n   * @param key\r\n   * @param format\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoExportJwk = function (key) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\n          msExportKey.addEventListener(\"complete\", function (e) {\n            var resultBuffer = e.target.result;\n            var resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer)).replace(/\\r/g, \"\").replace(/\\n/g, \"\").replace(/\\t/g, \"\").split(\" \").join(\"\").replace(\"\\u0000\", \"\");\n\n            try {\n              resolve(JSON.parse(resultString));\n            } catch (e) {\n              reject(e);\n            }\n          });\n          msExportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for importKey\r\n   * @param key\r\n   * @param format\r\n   * @param extractable\r\n   * @param usages\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoImportKey = function (keyBuffer, extractable, usages) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, _this._keygenAlgorithmOptions, extractable, usages);\n          msImportKey.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msImportKey.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * IE Helper function for sign JWT\r\n   * @param key\r\n   * @param data\r\n   */\n\n\n  BrowserCrypto.prototype.msCryptoSign = function (key, data) {\n    return __awaiter(this, void 0, void 0, function () {\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , new Promise(function (resolve, reject) {\n          var msSign = window[\"msCrypto\"].subtle.sign(_this._keygenAlgorithmOptions, key, data);\n          msSign.addEventListener(\"complete\", function (e) {\n            resolve(e.target.result);\n          });\n          msSign.addEventListener(\"error\", function (error) {\n            reject(error);\n          });\n        })];\n      });\n    });\n  };\n  /**\r\n   * Returns stringified jwk.\r\n   * @param jwk\r\n   */\n\n\n  BrowserCrypto.getJwkString = function (jwk) {\n    return JSON.stringify(jwk, Object.keys(jwk).sort());\n  };\n\n  return BrowserCrypto;\n}();\n\nexport { BrowserCrypto };","map":{"version":3,"sources":["../../src/crypto/BrowserCrypto.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { BrowserStringUtils } from \"../utils/BrowserStringUtils\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { KEY_FORMAT_JWK } from \"../utils/BrowserConstants\";\r\n/**\r\n * See here for more info on RsaHashedKeyGenParams: https://developer.mozilla.org/en-US/docs/Web/API/RsaHashedKeyGenParams\r\n */\r\n// RSA KeyGen Algorithm\r\nconst PKCS1_V15_KEYGEN_ALG = \"RSASSA-PKCS1-v1_5\";\r\n// SHA-256 hashing algorithm\r\nconst S256_HASH_ALG = \"SHA-256\";\r\n// MOD length for PoP tokens\r\nconst MODULUS_LENGTH = 2048;\r\n// Public Exponent\r\nconst PUBLIC_EXPONENT: Uint8Array = new Uint8Array([0x01, 0x00, 0x01]);\r\n\r\n/**\r\n * This class implements functions used by the browser library to perform cryptography operations such as\r\n * hashing and encoding. It also has helper functions to validate the availability of specific APIs.\r\n */\r\nexport class BrowserCrypto {\r\n\r\n    private _keygenAlgorithmOptions: RsaHashedKeyGenParams;\r\n\r\n    constructor() {\r\n        if (!(this.hasCryptoAPI())) {\r\n            throw BrowserAuthError.createCryptoNotAvailableError(\"Browser crypto or msCrypto object not available.\");\r\n        }\r\n\r\n        this._keygenAlgorithmOptions = {\r\n            name: PKCS1_V15_KEYGEN_ALG,\r\n            hash: S256_HASH_ALG,\r\n            modulusLength: MODULUS_LENGTH,\r\n            publicExponent: PUBLIC_EXPONENT\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Returns a sha-256 hash of the given dataString as an ArrayBuffer.\r\n     * @param dataString \r\n     */\r\n    async sha256Digest(dataString: string): Promise<ArrayBuffer> {\r\n        const data = BrowserStringUtils.stringToUtf8Arr(dataString);\r\n\r\n        return this.hasIECrypto() ? this.getMSCryptoDigest(S256_HASH_ALG, data) : this.getSubtleCryptoDigest(S256_HASH_ALG, data);\r\n    }\r\n\r\n    /**\r\n     * Populates buffer with cryptographically random values.\r\n     * @param dataBuffer \r\n     */\r\n    getRandomValues(dataBuffer: Uint8Array): void {\r\n        const cryptoObj = window[\"msCrypto\"] || window.crypto;\r\n        if (!cryptoObj.getRandomValues) {\r\n            throw BrowserAuthError.createCryptoNotAvailableError(\"getRandomValues does not exist.\");\r\n        }\r\n        cryptoObj.getRandomValues(dataBuffer);\r\n    }\r\n\r\n    /**\r\n     * Generates a keypair based on current keygen algorithm config.\r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    async generateKeyPair(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\r\n        return (\r\n            this.hasIECrypto() ? \r\n                this.msCryptoGenerateKey(extractable, usages) \r\n                : window.crypto.subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages)\r\n        ) as Promise<CryptoKeyPair>;\r\n    }\r\n\r\n    /**\r\n     * Export key as Json Web Key (JWK)\r\n     * @param key \r\n     * @param format \r\n     */\r\n    async exportJwk(key: CryptoKey): Promise<JsonWebKey> {\r\n        return this.hasIECrypto() ? this.msCryptoExportJwk(key) : window.crypto.subtle.exportKey(KEY_FORMAT_JWK, key);\r\n    }\r\n\r\n    /**\r\n     * Imports key as Json Web Key (JWK), can set extractable and usages.\r\n     * @param key \r\n     * @param format \r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    async importJwk(key: JsonWebKey, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\r\n        const keyString = BrowserCrypto.getJwkString(key);\r\n        const keyBuffer = BrowserStringUtils.stringToArrayBuffer(keyString);\r\n\r\n        return this.hasIECrypto() ? \r\n            this.msCryptoImportKey(keyBuffer, extractable, usages) \r\n            : window.crypto.subtle.importKey(KEY_FORMAT_JWK, key, this._keygenAlgorithmOptions, extractable, usages);\r\n    }\r\n\r\n    /**\r\n     * Signs given data with given key\r\n     * @param key \r\n     * @param data \r\n     */\r\n    async sign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return this.hasIECrypto() ?\r\n            this.msCryptoSign(key, data)\r\n            : window.crypto.subtle.sign(this._keygenAlgorithmOptions, key, data);\r\n    }\r\n\r\n    /**\r\n     * Check whether IE crypto or other browser cryptography is available.\r\n     */\r\n    private hasCryptoAPI(): boolean {\r\n        return this.hasIECrypto() || this.hasBrowserCrypto();\r\n    }\r\n\r\n    /**\r\n     * Checks whether IE crypto (AKA msCrypto) is available.\r\n     */\r\n    private hasIECrypto(): boolean {\r\n        return \"msCrypto\" in window;\r\n    }\r\n\r\n    /**\r\n     * Check whether browser crypto is available.\r\n     */\r\n    private hasBrowserCrypto(): boolean {\r\n        return \"crypto\" in window;\r\n    }\r\n\r\n    /**\r\n     * Helper function for SHA digest.\r\n     * @param algorithm \r\n     * @param data \r\n     */\r\n    private async getSubtleCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return window.crypto.subtle.digest(algorithm, data);\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for SHA digest.\r\n     * @param algorithm \r\n     * @param data \r\n     */\r\n    private async getMSCryptoDigest(algorithm: string, data: Uint8Array): Promise<ArrayBuffer> {\r\n        return new Promise((resolve, reject) => {\r\n            const digestOperation = window[\"msCrypto\"].subtle.digest(algorithm, data.buffer);\r\n            digestOperation.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n            digestOperation.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for generating a keypair\r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    private async msCryptoGenerateKey(extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKeyPair> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msGenerateKey = window[\"msCrypto\"].subtle.generateKey(this._keygenAlgorithmOptions, extractable, usages);\r\n            msGenerateKey.addEventListener(\"complete\", (e: { target: { result: CryptoKeyPair | PromiseLike<CryptoKeyPair>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msGenerateKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for exportKey\r\n     * @param key \r\n     * @param format \r\n     */\r\n    private async msCryptoExportJwk(key: CryptoKey): Promise<JsonWebKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msExportKey = window[\"msCrypto\"].subtle.exportKey(KEY_FORMAT_JWK, key);\r\n            msExportKey.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer; }; }) => {\r\n                const resultBuffer: ArrayBuffer = e.target.result;\r\n\r\n                const resultString = BrowserStringUtils.utf8ArrToString(new Uint8Array(resultBuffer))\r\n                    .replace(/\\r/g, \"\")\r\n                    .replace(/\\n/g, \"\")\r\n                    .replace(/\\t/g, \"\")\r\n                    .split(\" \").join(\"\")\r\n                    .replace(\"\\u0000\", \"\");\r\n\r\n                try {\r\n                    resolve(JSON.parse(resultString));\r\n                } catch (e) {\r\n                    reject(e);\r\n                }\r\n            });\r\n\r\n            msExportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for importKey\r\n     * @param key \r\n     * @param format \r\n     * @param extractable \r\n     * @param usages \r\n     */\r\n    private async msCryptoImportKey(keyBuffer: ArrayBuffer, extractable: boolean, usages: Array<KeyUsage>): Promise<CryptoKey> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msImportKey = window[\"msCrypto\"].subtle.importKey(KEY_FORMAT_JWK, keyBuffer, this._keygenAlgorithmOptions, extractable, usages);\r\n            msImportKey.addEventListener(\"complete\", (e: { target: { result: CryptoKey | PromiseLike<CryptoKey>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msImportKey.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * IE Helper function for sign JWT\r\n     * @param key \r\n     * @param data \r\n     */\r\n    private async msCryptoSign(key: CryptoKey, data: ArrayBuffer): Promise<ArrayBuffer> {\r\n        return new Promise((resolve: Function, reject: Function) => {\r\n            const msSign = window[\"msCrypto\"].subtle.sign(this._keygenAlgorithmOptions, key, data);\r\n            msSign.addEventListener(\"complete\", (e: { target: { result: ArrayBuffer | PromiseLike<ArrayBuffer>; }; }) => {\r\n                resolve(e.target.result);\r\n            });\r\n\r\n            msSign.addEventListener(\"error\", (error: string) => {\r\n                reject(error);\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Returns stringified jwk.\r\n     * @param jwk \r\n     */\r\n    static getJwkString(jwk: JsonWebKey): string {\r\n        return JSON.stringify(jwk, Object.keys(jwk).sort());\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}