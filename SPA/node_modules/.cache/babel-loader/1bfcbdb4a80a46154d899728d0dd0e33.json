{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * @module BatchRequestContent\r\n */\n\nimport { RequestMethod } from \"../RequestMethod\";\n/**\r\n * @class\r\n * Class for handling BatchRequestContent\r\n */\n\nexport class BatchRequestContent {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * Constructs a BatchRequestContent instance\r\n   * @param {BatchRequestStep[]} [requests] - Array of requests value\r\n   * @returns An instance of a BatchRequestContent\r\n   */\n  constructor(requests) {\n    this.requests = new Map();\n\n    if (typeof requests !== \"undefined\") {\n      const limit = BatchRequestContent.requestLimit;\n\n      if (requests.length > limit) {\n        const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);\n        error.name = \"Limit Exceeded Error\";\n        throw error;\n      }\n\n      for (const req of requests) {\n        this.addRequest(req);\n      }\n    }\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * Validates the dependency chain of the requests\r\n   *\r\n   * Note:\r\n   * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:\r\n   * 1. Parallel - no individual request states a dependency in the dependsOn property.\r\n   * 2. Serial - all individual requests depend on the previous individual request.\r\n   * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\r\n   * As JSON batching matures, these limitations will be removed.\r\n   * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n   *\r\n   * @param {Map<string, BatchRequestStep>} requests - The map of requests.\r\n   * @returns The boolean indicating the validation status\r\n   */\n\n\n  static validateDependencies(requests) {\n    const isParallel = reqs => {\n      const iterator = reqs.entries();\n      let cur = iterator.next();\n\n      while (!cur.done) {\n        const curReq = cur.value[1];\n\n        if (curReq.dependsOn !== undefined && curReq.dependsOn.length > 0) {\n          return false;\n        }\n\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    const isSerial = reqs => {\n      const iterator = reqs.entries();\n      let cur = iterator.next();\n      const firstRequest = cur.value[1];\n\n      if (firstRequest.dependsOn !== undefined && firstRequest.dependsOn.length > 0) {\n        return false;\n      }\n\n      let prev = cur;\n      cur = iterator.next();\n\n      while (!cur.done) {\n        const curReq = cur.value[1];\n\n        if (curReq.dependsOn === undefined || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {\n          return false;\n        }\n\n        prev = cur;\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    const isSame = reqs => {\n      const iterator = reqs.entries();\n      let cur = iterator.next();\n      const firstRequest = cur.value[1];\n      let dependencyId;\n\n      if (firstRequest.dependsOn === undefined || firstRequest.dependsOn.length === 0) {\n        dependencyId = firstRequest.id;\n      } else {\n        if (firstRequest.dependsOn.length === 1) {\n          const fDependencyId = firstRequest.dependsOn[0];\n\n          if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {\n            dependencyId = fDependencyId;\n          } else {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      }\n\n      cur = iterator.next();\n\n      while (!cur.done) {\n        const curReq = cur.value[1];\n\n        if ((curReq.dependsOn === undefined || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {\n          return false;\n        }\n\n        if (curReq.dependsOn !== undefined && curReq.dependsOn.length !== 0) {\n          if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {\n            return false;\n          }\n\n          if (curReq.dependsOn.length > 1) {\n            return false;\n          }\n        }\n\n        cur = iterator.next();\n      }\n\n      return true;\n    };\n\n    if (requests.size === 0) {\n      const error = new Error(\"Empty requests map, Please provide at least one request.\");\n      error.name = \"Empty Requests Error\";\n      throw error;\n    }\n\n    return isParallel(requests) || isSerial(requests) || isSame(requests);\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * Converts Request Object instance to a JSON\r\n   * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance\r\n   * @returns A promise that resolves to JSON representation of a request\r\n   */\n\n\n  static getRequestData(request) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const requestData = {\n        url: \"\"\n      };\n      const hasHttpRegex = new RegExp(\"^https?://\"); // Stripping off hostname, port and url scheme\n\n      requestData.url = hasHttpRegex.test(request.url) ? \"/\" + request.url.split(/.*?\\/\\/.*?\\//)[1] : request.url;\n      requestData.method = request.method;\n      const headers = {};\n      request.headers.forEach((value, key) => {\n        headers[key] = value;\n      });\n\n      if (Object.keys(headers).length) {\n        requestData.headers = headers;\n      }\n\n      if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {\n        requestData.body = yield BatchRequestContent.getRequestBody(request);\n      }\n      /**\r\n       * TODO: Check any other property needs to be used from the Request object and add them\r\n       */\n\n\n      return requestData;\n    });\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * Gets the body of a Request object instance\r\n   * @param {IsomorphicRequest} request - The IsomorphicRequest object instance\r\n   * @returns The Promise that resolves to a body value of a Request\r\n   */\n\n\n  static getRequestBody(request) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      let bodyParsed = false;\n      let body;\n\n      try {\n        const cloneReq = request.clone();\n        body = yield cloneReq.json();\n        bodyParsed = true;\n      } catch (e) {// tslint:disable-line: no-empty\n      }\n\n      if (!bodyParsed) {\n        try {\n          if (typeof Blob !== \"undefined\") {\n            const blob = yield request.blob();\n            const reader = new FileReader();\n            body = yield new Promise(resolve => {\n              reader.addEventListener(\"load\", () => {\n                const dataURL = reader.result;\n                /**\r\n                 * Some valid dataURL schemes:\r\n                 *  1. data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh\r\n                 *  2. data:text/plain;charset=UTF-8;page=21,the%20data:1234,5678\r\n                 *  3. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 *  4. data:image/png,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 *  5. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                 * @see Syntax {@link https://en.wikipedia.org/wiki/Data_URI_scheme} for more\r\n                 */\n\n                const regex = new RegExp(\"^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$\");\n                const segments = regex.exec(dataURL);\n                resolve(segments[4]);\n              }, false);\n              reader.readAsDataURL(blob);\n            });\n          } else if (typeof Buffer !== \"undefined\") {\n            const buffer = yield request.buffer();\n            body = buffer.toString(\"base64\");\n          }\n\n          bodyParsed = true;\n        } catch (e) {// tslint:disable-line: no-empty\n        }\n      }\n\n      return body;\n    });\n  }\n  /**\r\n   * @public\r\n   * Adds a request to the batch request content\r\n   * @param {BatchRequestStep} request - The request value\r\n   * @returns The id of the added request\r\n   */\n\n\n  addRequest(request) {\n    const limit = BatchRequestContent.requestLimit;\n\n    if (request.id === \"\") {\n      const error = new Error(`Id for a request is empty, Please provide an unique id`);\n      error.name = \"Empty Id For Request\";\n      throw error;\n    }\n\n    if (this.requests.size === limit) {\n      const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);\n      error.name = \"Limit Exceeded Error\";\n      throw error;\n    }\n\n    if (this.requests.has(request.id)) {\n      const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);\n      error.name = \"Duplicate RequestId Error\";\n      throw error;\n    }\n\n    this.requests.set(request.id, request);\n    return request.id;\n  }\n  /**\r\n   * @public\r\n   * Removes request from the batch payload and its dependencies from all dependents\r\n   * @param {string} requestId - The id of a request that needs to be removed\r\n   * @returns The boolean indicating removed status\r\n   */\n\n\n  removeRequest(requestId) {\n    const deleteStatus = this.requests.delete(requestId);\n    const iterator = this.requests.entries();\n    let cur = iterator.next();\n    /**\r\n     * Removing dependencies where this request is present as a dependency\r\n     */\n\n    while (!cur.done) {\n      const dependencies = cur.value[1].dependsOn;\n\n      if (typeof dependencies !== \"undefined\") {\n        const index = dependencies.indexOf(requestId);\n\n        if (index !== -1) {\n          dependencies.splice(index, 1);\n        }\n\n        if (dependencies.length === 0) {\n          delete cur.value[1].dependsOn;\n        }\n      }\n\n      cur = iterator.next();\n    }\n\n    return deleteStatus;\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Serialize content from BatchRequestContent instance\r\n   * @returns The body content to make batch request\r\n   */\n\n\n  getContent() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      const requests = [];\n      const requestBody = {\n        requests\n      };\n      const iterator = this.requests.entries();\n      let cur = iterator.next();\n\n      if (cur.done) {\n        const error = new Error(\"No requests added yet, Please add at least one request.\");\n        error.name = \"Empty Payload\";\n        throw error;\n      }\n\n      if (!BatchRequestContent.validateDependencies(this.requests)) {\n        const error = new Error(`Invalid dependency found, Dependency should be:\n1. Parallel - no individual request states a dependency in the dependsOn property.\n2. Serial - all individual requests depend on the previous individual request.\n3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);\n        error.name = \"Invalid Dependency\";\n        throw error;\n      }\n\n      while (!cur.done) {\n        const requestStep = cur.value[1];\n        const batchRequestData = yield BatchRequestContent.getRequestData(requestStep.request);\n        /**\r\n         * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/json_batching#request-format}\r\n         */\n\n        if (batchRequestData.body !== undefined && (batchRequestData.headers === undefined || batchRequestData.headers[\"content-type\"] === undefined)) {\n          const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);\n          error.name = \"Invalid Content-type header\";\n          throw error;\n        }\n\n        batchRequestData.id = requestStep.id;\n\n        if (requestStep.dependsOn !== undefined && requestStep.dependsOn.length > 0) {\n          batchRequestData.dependsOn = requestStep.dependsOn;\n        }\n\n        requests.push(batchRequestData);\n        cur = iterator.next();\n      }\n\n      requestBody.requests = requests;\n      return requestBody;\n    });\n  }\n  /**\r\n   * @public\r\n   * Adds a dependency for a given dependent request\r\n   * @param {string} dependentId - The id of the dependent request\r\n   * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency\r\n   * @returns Nothing\r\n   */\n\n\n  addDependency(dependentId, dependencyId) {\n    if (!this.requests.has(dependentId)) {\n      const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);\n      error.name = \"Invalid Dependent\";\n      throw error;\n    }\n\n    if (typeof dependencyId !== \"undefined\" && !this.requests.has(dependencyId)) {\n      const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);\n      error.name = \"Invalid Dependency\";\n      throw error;\n    }\n\n    if (typeof dependencyId !== \"undefined\") {\n      const dependent = this.requests.get(dependentId);\n\n      if (dependent.dependsOn === undefined) {\n        dependent.dependsOn = [];\n      }\n\n      if (dependent.dependsOn.indexOf(dependencyId) !== -1) {\n        const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);\n        error.name = \"Duplicate Dependency\";\n        throw error;\n      }\n\n      dependent.dependsOn.push(dependencyId);\n    } else {\n      const iterator = this.requests.entries();\n      let prev;\n      let cur = iterator.next();\n\n      while (!cur.done && cur.value[1].id !== dependentId) {\n        prev = cur;\n        cur = iterator.next();\n      }\n\n      if (typeof prev !== \"undefined\") {\n        const dId = prev.value[0];\n\n        if (cur.value[1].dependsOn === undefined) {\n          cur.value[1].dependsOn = [];\n        }\n\n        if (cur.value[1].dependsOn.indexOf(dId) !== -1) {\n          const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);\n          error.name = \"Duplicate Dependency\";\n          throw error;\n        }\n\n        cur.value[1].dependsOn.push(dId);\n      } else {\n        const error = new Error(`Can't add dependency ${dependencyId}, There is only a dependent request in the batch`);\n        error.name = \"Invalid Dependency Addition\";\n        throw error;\n      }\n    }\n  }\n  /**\r\n   * @public\r\n   * Removes a dependency for a given dependent request id\r\n   * @param {string} dependentId - The id of the dependent request\r\n   * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request\r\n   * @returns The boolean indicating removed status\r\n   */\n\n\n  removeDependency(dependentId, dependencyId) {\n    const request = this.requests.get(dependentId);\n\n    if (typeof request === \"undefined\" || request.dependsOn === undefined || request.dependsOn.length === 0) {\n      return false;\n    }\n\n    if (typeof dependencyId !== \"undefined\") {\n      const index = request.dependsOn.indexOf(dependencyId);\n\n      if (index === -1) {\n        return false;\n      }\n\n      request.dependsOn.splice(index, 1);\n      return true;\n    } else {\n      delete request.dependsOn;\n      return true;\n    }\n  }\n\n}\n/**\r\n * @private\r\n * @static\r\n * Limit for number of requests {@link - https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n */\n\nBatchRequestContent.requestLimit = 20;","map":{"version":3,"sources":["../../../src/content/BatchRequestContent.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\n/**\r\n * @module BatchRequestContent\r\n */\r\nimport { RequestMethod } from \"../RequestMethod\";\r\n/**\r\n * @class\r\n * Class for handling BatchRequestContent\r\n */\r\nexport class BatchRequestContent {\r\n    /**\r\n     * @public\r\n     * @constructor\r\n     * Constructs a BatchRequestContent instance\r\n     * @param {BatchRequestStep[]} [requests] - Array of requests value\r\n     * @returns An instance of a BatchRequestContent\r\n     */\r\n    constructor(requests) {\r\n        this.requests = new Map();\r\n        if (typeof requests !== \"undefined\") {\r\n            const limit = BatchRequestContent.requestLimit;\r\n            if (requests.length > limit) {\r\n                const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);\r\n                error.name = \"Limit Exceeded Error\";\r\n                throw error;\r\n            }\r\n            for (const req of requests) {\r\n                this.addRequest(req);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @static\r\n     * Validates the dependency chain of the requests\r\n     *\r\n     * Note:\r\n     * Individual requests can depend on other individual requests. Currently, requests can only depend on a single other request, and must follow one of these three patterns:\r\n     * 1. Parallel - no individual request states a dependency in the dependsOn property.\r\n     * 2. Serial - all individual requests depend on the previous individual request.\r\n     * 3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.\r\n     * As JSON batching matures, these limitations will be removed.\r\n     * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n     *\r\n     * @param {Map<string, BatchRequestStep>} requests - The map of requests.\r\n     * @returns The boolean indicating the validation status\r\n     */\r\n    static validateDependencies(requests) {\r\n        const isParallel = (reqs) => {\r\n            const iterator = reqs.entries();\r\n            let cur = iterator.next();\r\n            while (!cur.done) {\r\n                const curReq = cur.value[1];\r\n                if (curReq.dependsOn !== undefined && curReq.dependsOn.length > 0) {\r\n                    return false;\r\n                }\r\n                cur = iterator.next();\r\n            }\r\n            return true;\r\n        };\r\n        const isSerial = (reqs) => {\r\n            const iterator = reqs.entries();\r\n            let cur = iterator.next();\r\n            const firstRequest = cur.value[1];\r\n            if (firstRequest.dependsOn !== undefined && firstRequest.dependsOn.length > 0) {\r\n                return false;\r\n            }\r\n            let prev = cur;\r\n            cur = iterator.next();\r\n            while (!cur.done) {\r\n                const curReq = cur.value[1];\r\n                if (curReq.dependsOn === undefined || curReq.dependsOn.length !== 1 || curReq.dependsOn[0] !== prev.value[1].id) {\r\n                    return false;\r\n                }\r\n                prev = cur;\r\n                cur = iterator.next();\r\n            }\r\n            return true;\r\n        };\r\n        const isSame = (reqs) => {\r\n            const iterator = reqs.entries();\r\n            let cur = iterator.next();\r\n            const firstRequest = cur.value[1];\r\n            let dependencyId;\r\n            if (firstRequest.dependsOn === undefined || firstRequest.dependsOn.length === 0) {\r\n                dependencyId = firstRequest.id;\r\n            }\r\n            else {\r\n                if (firstRequest.dependsOn.length === 1) {\r\n                    const fDependencyId = firstRequest.dependsOn[0];\r\n                    if (fDependencyId !== firstRequest.id && reqs.has(fDependencyId)) {\r\n                        dependencyId = fDependencyId;\r\n                    }\r\n                    else {\r\n                        return false;\r\n                    }\r\n                }\r\n                else {\r\n                    return false;\r\n                }\r\n            }\r\n            cur = iterator.next();\r\n            while (!cur.done) {\r\n                const curReq = cur.value[1];\r\n                if ((curReq.dependsOn === undefined || curReq.dependsOn.length === 0) && dependencyId !== curReq.id) {\r\n                    return false;\r\n                }\r\n                if (curReq.dependsOn !== undefined && curReq.dependsOn.length !== 0) {\r\n                    if (curReq.dependsOn.length === 1 && (curReq.id === dependencyId || curReq.dependsOn[0] !== dependencyId)) {\r\n                        return false;\r\n                    }\r\n                    if (curReq.dependsOn.length > 1) {\r\n                        return false;\r\n                    }\r\n                }\r\n                cur = iterator.next();\r\n            }\r\n            return true;\r\n        };\r\n        if (requests.size === 0) {\r\n            const error = new Error(\"Empty requests map, Please provide at least one request.\");\r\n            error.name = \"Empty Requests Error\";\r\n            throw error;\r\n        }\r\n        return isParallel(requests) || isSerial(requests) || isSame(requests);\r\n    }\r\n    /**\r\n     * @private\r\n     * @static\r\n     * @async\r\n     * Converts Request Object instance to a JSON\r\n     * @param {IsomorphicRequest} request - The IsomorphicRequest Object instance\r\n     * @returns A promise that resolves to JSON representation of a request\r\n     */\r\n    static getRequestData(request) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            const requestData = {\r\n                url: \"\",\r\n            };\r\n            const hasHttpRegex = new RegExp(\"^https?://\");\r\n            // Stripping off hostname, port and url scheme\r\n            requestData.url = hasHttpRegex.test(request.url) ? \"/\" + request.url.split(/.*?\\/\\/.*?\\//)[1] : request.url;\r\n            requestData.method = request.method;\r\n            const headers = {};\r\n            request.headers.forEach((value, key) => {\r\n                headers[key] = value;\r\n            });\r\n            if (Object.keys(headers).length) {\r\n                requestData.headers = headers;\r\n            }\r\n            if (request.method === RequestMethod.PATCH || request.method === RequestMethod.POST || request.method === RequestMethod.PUT) {\r\n                requestData.body = yield BatchRequestContent.getRequestBody(request);\r\n            }\r\n            /**\r\n             * TODO: Check any other property needs to be used from the Request object and add them\r\n             */\r\n            return requestData;\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * @static\r\n     * @async\r\n     * Gets the body of a Request object instance\r\n     * @param {IsomorphicRequest} request - The IsomorphicRequest object instance\r\n     * @returns The Promise that resolves to a body value of a Request\r\n     */\r\n    static getRequestBody(request) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            let bodyParsed = false;\r\n            let body;\r\n            try {\r\n                const cloneReq = request.clone();\r\n                body = yield cloneReq.json();\r\n                bodyParsed = true;\r\n            }\r\n            catch (e) {\r\n                // tslint:disable-line: no-empty\r\n            }\r\n            if (!bodyParsed) {\r\n                try {\r\n                    if (typeof Blob !== \"undefined\") {\r\n                        const blob = yield request.blob();\r\n                        const reader = new FileReader();\r\n                        body = yield new Promise((resolve) => {\r\n                            reader.addEventListener(\"load\", () => {\r\n                                const dataURL = reader.result;\r\n                                /**\r\n                                 * Some valid dataURL schemes:\r\n                                 *  1. data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh\r\n                                 *  2. data:text/plain;charset=UTF-8;page=21,the%20data:1234,5678\r\n                                 *  3. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                                 *  4. data:image/png,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                                 *  5. data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==\r\n                                 * @see Syntax {@link https://en.wikipedia.org/wiki/Data_URI_scheme} for more\r\n                                 */\r\n                                const regex = new RegExp(\"^s*data:(.+?/.+?(;.+?=.+?)*)?(;base64)?,(.*)s*$\");\r\n                                const segments = regex.exec(dataURL);\r\n                                resolve(segments[4]);\r\n                            }, false);\r\n                            reader.readAsDataURL(blob);\r\n                        });\r\n                    }\r\n                    else if (typeof Buffer !== \"undefined\") {\r\n                        const buffer = yield request.buffer();\r\n                        body = buffer.toString(\"base64\");\r\n                    }\r\n                    bodyParsed = true;\r\n                }\r\n                catch (e) {\r\n                    // tslint:disable-line: no-empty\r\n                }\r\n            }\r\n            return body;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * Adds a request to the batch request content\r\n     * @param {BatchRequestStep} request - The request value\r\n     * @returns The id of the added request\r\n     */\r\n    addRequest(request) {\r\n        const limit = BatchRequestContent.requestLimit;\r\n        if (request.id === \"\") {\r\n            const error = new Error(`Id for a request is empty, Please provide an unique id`);\r\n            error.name = \"Empty Id For Request\";\r\n            throw error;\r\n        }\r\n        if (this.requests.size === limit) {\r\n            const error = new Error(`Maximum requests limit exceeded, Max allowed number of requests are ${limit}`);\r\n            error.name = \"Limit Exceeded Error\";\r\n            throw error;\r\n        }\r\n        if (this.requests.has(request.id)) {\r\n            const error = new Error(`Adding request with duplicate id ${request.id}, Make the id of the requests unique`);\r\n            error.name = \"Duplicate RequestId Error\";\r\n            throw error;\r\n        }\r\n        this.requests.set(request.id, request);\r\n        return request.id;\r\n    }\r\n    /**\r\n     * @public\r\n     * Removes request from the batch payload and its dependencies from all dependents\r\n     * @param {string} requestId - The id of a request that needs to be removed\r\n     * @returns The boolean indicating removed status\r\n     */\r\n    removeRequest(requestId) {\r\n        const deleteStatus = this.requests.delete(requestId);\r\n        const iterator = this.requests.entries();\r\n        let cur = iterator.next();\r\n        /**\r\n         * Removing dependencies where this request is present as a dependency\r\n         */\r\n        while (!cur.done) {\r\n            const dependencies = cur.value[1].dependsOn;\r\n            if (typeof dependencies !== \"undefined\") {\r\n                const index = dependencies.indexOf(requestId);\r\n                if (index !== -1) {\r\n                    dependencies.splice(index, 1);\r\n                }\r\n                if (dependencies.length === 0) {\r\n                    delete cur.value[1].dependsOn;\r\n                }\r\n            }\r\n            cur = iterator.next();\r\n        }\r\n        return deleteStatus;\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Serialize content from BatchRequestContent instance\r\n     * @returns The body content to make batch request\r\n     */\r\n    getContent() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            const requests = [];\r\n            const requestBody = {\r\n                requests,\r\n            };\r\n            const iterator = this.requests.entries();\r\n            let cur = iterator.next();\r\n            if (cur.done) {\r\n                const error = new Error(\"No requests added yet, Please add at least one request.\");\r\n                error.name = \"Empty Payload\";\r\n                throw error;\r\n            }\r\n            if (!BatchRequestContent.validateDependencies(this.requests)) {\r\n                const error = new Error(`Invalid dependency found, Dependency should be:\r\n1. Parallel - no individual request states a dependency in the dependsOn property.\r\n2. Serial - all individual requests depend on the previous individual request.\r\n3. Same - all individual requests that state a dependency in the dependsOn property, state the same dependency.`);\r\n                error.name = \"Invalid Dependency\";\r\n                throw error;\r\n            }\r\n            while (!cur.done) {\r\n                const requestStep = cur.value[1];\r\n                const batchRequestData = (yield BatchRequestContent.getRequestData(requestStep.request));\r\n                /**\r\n                 * @see {@link https://developer.microsoft.com/en-us/graph/docs/concepts/json_batching#request-format}\r\n                 */\r\n                if (batchRequestData.body !== undefined && (batchRequestData.headers === undefined || batchRequestData.headers[\"content-type\"] === undefined)) {\r\n                    const error = new Error(`Content-type header is not mentioned for request #${requestStep.id}, For request having body, Content-type header should be mentioned`);\r\n                    error.name = \"Invalid Content-type header\";\r\n                    throw error;\r\n                }\r\n                batchRequestData.id = requestStep.id;\r\n                if (requestStep.dependsOn !== undefined && requestStep.dependsOn.length > 0) {\r\n                    batchRequestData.dependsOn = requestStep.dependsOn;\r\n                }\r\n                requests.push(batchRequestData);\r\n                cur = iterator.next();\r\n            }\r\n            requestBody.requests = requests;\r\n            return requestBody;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * Adds a dependency for a given dependent request\r\n     * @param {string} dependentId - The id of the dependent request\r\n     * @param {string} [dependencyId] - The id of the dependency request, if not specified the preceding request will be considered as a dependency\r\n     * @returns Nothing\r\n     */\r\n    addDependency(dependentId, dependencyId) {\r\n        if (!this.requests.has(dependentId)) {\r\n            const error = new Error(`Dependent ${dependentId} does not exists, Please check the id`);\r\n            error.name = \"Invalid Dependent\";\r\n            throw error;\r\n        }\r\n        if (typeof dependencyId !== \"undefined\" && !this.requests.has(dependencyId)) {\r\n            const error = new Error(`Dependency ${dependencyId} does not exists, Please check the id`);\r\n            error.name = \"Invalid Dependency\";\r\n            throw error;\r\n        }\r\n        if (typeof dependencyId !== \"undefined\") {\r\n            const dependent = this.requests.get(dependentId);\r\n            if (dependent.dependsOn === undefined) {\r\n                dependent.dependsOn = [];\r\n            }\r\n            if (dependent.dependsOn.indexOf(dependencyId) !== -1) {\r\n                const error = new Error(`Dependency ${dependencyId} is already added for the request ${dependentId}`);\r\n                error.name = \"Duplicate Dependency\";\r\n                throw error;\r\n            }\r\n            dependent.dependsOn.push(dependencyId);\r\n        }\r\n        else {\r\n            const iterator = this.requests.entries();\r\n            let prev;\r\n            let cur = iterator.next();\r\n            while (!cur.done && cur.value[1].id !== dependentId) {\r\n                prev = cur;\r\n                cur = iterator.next();\r\n            }\r\n            if (typeof prev !== \"undefined\") {\r\n                const dId = prev.value[0];\r\n                if (cur.value[1].dependsOn === undefined) {\r\n                    cur.value[1].dependsOn = [];\r\n                }\r\n                if (cur.value[1].dependsOn.indexOf(dId) !== -1) {\r\n                    const error = new Error(`Dependency ${dId} is already added for the request ${dependentId}`);\r\n                    error.name = \"Duplicate Dependency\";\r\n                    throw error;\r\n                }\r\n                cur.value[1].dependsOn.push(dId);\r\n            }\r\n            else {\r\n                const error = new Error(`Can't add dependency ${dependencyId}, There is only a dependent request in the batch`);\r\n                error.name = \"Invalid Dependency Addition\";\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @public\r\n     * Removes a dependency for a given dependent request id\r\n     * @param {string} dependentId - The id of the dependent request\r\n     * @param {string} [dependencyId] - The id of the dependency request, if not specified will remove all the dependencies of that request\r\n     * @returns The boolean indicating removed status\r\n     */\r\n    removeDependency(dependentId, dependencyId) {\r\n        const request = this.requests.get(dependentId);\r\n        if (typeof request === \"undefined\" || request.dependsOn === undefined || request.dependsOn.length === 0) {\r\n            return false;\r\n        }\r\n        if (typeof dependencyId !== \"undefined\") {\r\n            const index = request.dependsOn.indexOf(dependencyId);\r\n            if (index === -1) {\r\n                return false;\r\n            }\r\n            request.dependsOn.splice(index, 1);\r\n            return true;\r\n        }\r\n        else {\r\n            delete request.dependsOn;\r\n            return true;\r\n        }\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @static\r\n * Limit for number of requests {@link - https://developer.microsoft.com/en-us/graph/docs/concepts/known_issues#json-batching}\r\n */\r\nBatchRequestContent.requestLimit = 20;\r\n//# sourceMappingURL=BatchRequestContent.js.map"]},"metadata":{},"sourceType":"module"}