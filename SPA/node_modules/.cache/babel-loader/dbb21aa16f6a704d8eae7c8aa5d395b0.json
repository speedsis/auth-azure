{"ast":null,"code":"/*! @azure/msal-browser v2.16.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator } from '../_virtual/_tslib.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { HTTP_REQUEST_TYPE } from '../utils/BrowserConstants.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This client implements the XMLHttpRequest class to send GET and POST requests.\r\n */\n\nvar XhrClient = function () {\n  function XhrClient() {}\n  /**\r\n   * XhrClient for REST endpoints - Get request\r\n   * @param url\r\n   * @param headers\r\n   * @param body\r\n   */\n\n\n  XhrClient.prototype.sendGetRequestAsync = function (url, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.sendRequestAsync(url, HTTP_REQUEST_TYPE.GET, options)];\n      });\n    });\n  };\n  /**\r\n   * XhrClient for REST endpoints - Post request\r\n   * @param url\r\n   * @param headers\r\n   * @param body\r\n   */\n\n\n  XhrClient.prototype.sendPostRequestAsync = function (url, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , this.sendRequestAsync(url, HTTP_REQUEST_TYPE.POST, options)];\n      });\n    });\n  };\n  /**\r\n   * Helper for XhrClient requests.\r\n   * @param url\r\n   * @param method\r\n   * @param options\r\n   */\n\n\n  XhrClient.prototype.sendRequestAsync = function (url, method, options) {\n    var _this = this;\n\n    return new Promise(function (resolve, reject) {\n      var xhr = new XMLHttpRequest();\n      xhr.open(method, url,\n      /* async: */\n      true);\n\n      _this.setXhrHeaders(xhr, options);\n\n      xhr.onload = function () {\n        if (xhr.status < 200 || xhr.status >= 300) {\n          if (method === HTTP_REQUEST_TYPE.POST) {\n            reject(BrowserAuthError.createPostRequestFailedError(\"Failed with status \" + xhr.status, url));\n          } else {\n            reject(BrowserAuthError.createGetRequestFailedError(\"Failed with status \" + xhr.status, url));\n          }\n        }\n\n        try {\n          var jsonResponse = JSON.parse(xhr.responseText);\n          var networkResponse = {\n            headers: _this.getHeaderDict(xhr),\n            body: jsonResponse,\n            status: xhr.status\n          };\n          resolve(networkResponse);\n        } catch (e) {\n          reject(BrowserAuthError.createFailedToParseNetworkResponseError(url));\n        }\n      };\n\n      xhr.onerror = function () {\n        if (window.navigator.onLine) {\n          if (method === HTTP_REQUEST_TYPE.POST) {\n            reject(BrowserAuthError.createPostRequestFailedError(\"Failed with status \" + xhr.status, url));\n          } else {\n            reject(BrowserAuthError.createGetRequestFailedError(\"Failed with status \" + xhr.status, url));\n          }\n        } else {\n          reject(BrowserAuthError.createNoNetworkConnectivityError());\n        }\n      };\n\n      if (method === HTTP_REQUEST_TYPE.POST && options && options.body) {\n        xhr.send(options.body);\n      } else if (method === HTTP_REQUEST_TYPE.GET) {\n        xhr.send();\n      } else {\n        throw BrowserAuthError.createHttpMethodNotImplementedError(method);\n      }\n    });\n  };\n  /**\r\n   * Helper to set XHR headers for request.\r\n   * @param xhr\r\n   * @param options\r\n   */\n\n\n  XhrClient.prototype.setXhrHeaders = function (xhr, options) {\n    if (options && options.headers) {\n      var headers_1 = options.headers;\n      Object.keys(headers_1).forEach(function (key) {\n        xhr.setRequestHeader(key, headers_1[key]);\n      });\n    }\n  };\n  /**\r\n   * Gets a string map of the headers received in the response.\r\n   *\r\n   * Algorithm comes from https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders\r\n   * @param xhr\r\n   */\n\n\n  XhrClient.prototype.getHeaderDict = function (xhr) {\n    var headerString = xhr.getAllResponseHeaders();\n    var headerArr = headerString.trim().split(/[\\r\\n]+/);\n    var headerDict = {};\n    headerArr.forEach(function (value) {\n      var parts = value.split(\": \");\n      var headerName = parts.shift();\n      var headerVal = parts.join(\": \");\n\n      if (headerName && headerVal) {\n        headerDict[headerName] = headerVal;\n      }\n    });\n    return headerDict;\n  };\n\n  return XhrClient;\n}();\n\nexport { XhrClient };","map":{"version":3,"sources":["../../src/network/XhrClient.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { INetworkModule, NetworkRequestOptions, NetworkResponse } from \"@azure/msal-common\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { HTTP_REQUEST_TYPE } from \"../utils/BrowserConstants\";\r\n\r\n/**\r\n * This client implements the XMLHttpRequest class to send GET and POST requests.\r\n */\r\nexport class XhrClient implements INetworkModule {\r\n\r\n    /**\r\n     * XhrClient for REST endpoints - Get request\r\n     * @param url \r\n     * @param headers \r\n     * @param body \r\n     */\r\n    async sendGetRequestAsync<T>(url: string, options?: NetworkRequestOptions): Promise<NetworkResponse<T>> {\r\n        return this.sendRequestAsync(url, HTTP_REQUEST_TYPE.GET, options);\r\n    }\r\n\r\n    /**\r\n     * XhrClient for REST endpoints - Post request\r\n     * @param url \r\n     * @param headers \r\n     * @param body \r\n     */\r\n    async sendPostRequestAsync<T>(url: string, options?: NetworkRequestOptions): Promise<NetworkResponse<T>> {\r\n        return this.sendRequestAsync(url, HTTP_REQUEST_TYPE.POST, options);\r\n    }\r\n\r\n    /**\r\n     * Helper for XhrClient requests.\r\n     * @param url \r\n     * @param method \r\n     * @param options \r\n     */\r\n    private sendRequestAsync<T>(url: string, method: HTTP_REQUEST_TYPE, options?: NetworkRequestOptions): Promise<NetworkResponse<T>> {\r\n        return new Promise<NetworkResponse<T>>((resolve, reject) => {\r\n            const xhr = new XMLHttpRequest();\r\n            xhr.open(method, url, /* async: */ true);\r\n            this.setXhrHeaders(xhr, options);\r\n            xhr.onload = (): void => {\r\n                if (xhr.status < 200 || xhr.status >= 300) {\r\n                    if (method === HTTP_REQUEST_TYPE.POST) {\r\n                        reject(BrowserAuthError.createPostRequestFailedError(`Failed with status ${xhr.status}`, url));\r\n                    } else {\r\n                        reject(BrowserAuthError.createGetRequestFailedError(`Failed with status ${xhr.status}`, url));\r\n                    }\r\n                }\r\n                try {\r\n                    const jsonResponse = JSON.parse(xhr.responseText) as T;\r\n                    const networkResponse: NetworkResponse<T> = {\r\n                        headers: this.getHeaderDict(xhr),\r\n                        body: jsonResponse,\r\n                        status: xhr.status\r\n                    };\r\n                    resolve(networkResponse);\r\n                } catch (e) {\r\n                    reject(BrowserAuthError.createFailedToParseNetworkResponseError(url));\r\n                }\r\n            };\r\n\r\n            xhr.onerror = (): void => {\r\n                if (window.navigator.onLine) {\r\n                    if (method === HTTP_REQUEST_TYPE.POST) {\r\n                        reject(BrowserAuthError.createPostRequestFailedError(`Failed with status ${xhr.status}`, url));\r\n                    } else {\r\n                        reject(BrowserAuthError.createGetRequestFailedError(`Failed with status ${xhr.status}`, url));\r\n                    }\r\n                } else {\r\n                    reject(BrowserAuthError.createNoNetworkConnectivityError());\r\n                }\r\n            };\r\n\r\n            if (method === HTTP_REQUEST_TYPE.POST && options && options.body) {\r\n                xhr.send(options.body);\r\n            } else if (method === HTTP_REQUEST_TYPE.GET) {\r\n                xhr.send();\r\n            } else {\r\n                throw BrowserAuthError.createHttpMethodNotImplementedError(method);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Helper to set XHR headers for request.\r\n     * @param xhr \r\n     * @param options \r\n     */\r\n    private setXhrHeaders(xhr: XMLHttpRequest, options?: NetworkRequestOptions): void {\r\n        if (options && options.headers) {\r\n            const headers = options.headers;\r\n            Object.keys(headers).forEach((key: string) => {\r\n                xhr.setRequestHeader(key, headers[key]);\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a string map of the headers received in the response.\r\n     * \r\n     * Algorithm comes from https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/getAllResponseHeaders\r\n     * @param xhr \r\n     */\r\n    private getHeaderDict(xhr: XMLHttpRequest): Record<string, string> {\r\n        const headerString = xhr.getAllResponseHeaders();\r\n        const headerArr = headerString.trim().split(/[\\r\\n]+/);\r\n        const headerDict: Record<string, string> = {};\r\n        headerArr.forEach((value: string) => {\r\n            const parts = value.split(\": \");\r\n            const headerName = parts.shift();\r\n            const headerVal = parts.join(\": \");\r\n            if (headerName && headerVal) {\r\n                headerDict[headerName] = headerVal;\r\n            }\r\n        });\r\n\r\n        return headerDict;\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}