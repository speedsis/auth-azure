{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { generateUUID } from \"./MiddlewareUtil\";\nimport { httpStatusCode, methodStatusCode } from \"./options/ChaosHandlerData\";\nimport { ChaosHandlerOptions } from \"./options/ChaosHandlerOptions\";\nimport { ChaosStrategy } from \"./options/ChaosStrategy\";\n/**\r\n * Class representing ChaosHandler\r\n * @class\r\n * Class\r\n * @implements Middleware\r\n */\n\nexport class ChaosHandler {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * To create an instance of Testing Handler\r\n   * @param {ChaosHandlerOptions} [options = new ChaosHandlerOptions()] - The testing handler options instance\r\n   * @param manualMap - The Map passed by user containing url-statusCode info\r\n   * @returns An instance of Testing Handler\r\n   */\n  constructor(options = new ChaosHandlerOptions(), manualMap) {\n    this.options = options;\n    this.manualMap = manualMap;\n  }\n  /**\r\n   * Generates responseHeader\r\n   * @private\r\n   * @param {number} statusCode - the status code to be returned for the request\r\n   * @param {string} requestID - request id\r\n   * @param {string} requestDate - date of the request\r\n   * @returns response Header\r\n   */\n\n\n  createResponseHeaders(statusCode, requestID, requestDate) {\n    const responseHeader = new Headers();\n    responseHeader.append(\"Cache-Control\", \"no-store\");\n    responseHeader.append(\"request-id\", requestID);\n    responseHeader.append(\"client-request-id\", requestID);\n    responseHeader.append(\"x-ms-ags-diagnostic\", \"\");\n    responseHeader.append(\"Date\", requestDate);\n    responseHeader.append(\"Strict-Transport-Security\", \"\");\n\n    if (statusCode === 429) {\n      // throttling case has to have a timeout scenario\n      responseHeader.append(\"retry-after\", \"300\");\n    }\n\n    return responseHeader;\n  }\n  /**\r\n   * Generates responseBody\r\n   * @private\r\n   * @param {number} statusCode - the status code to be returned for the request\r\n   * @param {string} statusMessage - the status message to be returned for the request\r\n   * @param {string} requestID - request id\r\n   * @param {string} requestDate - date of the request\r\n   * @param {any?} requestBody - the request body to be returned for the request\r\n   * @returns response body\r\n   */\n\n\n  createResponseBody(statusCode, statusMessage, requestID, requestDate, responseBody) {\n    if (responseBody) {\n      return responseBody;\n    }\n\n    let body;\n\n    if (statusCode >= 400) {\n      const codeMessage = httpStatusCode[statusCode];\n      const errMessage = statusMessage;\n      body = {\n        error: {\n          code: codeMessage,\n          message: errMessage,\n          innerError: {\n            \"request-id\": requestID,\n            date: requestDate\n          }\n        }\n      };\n    } else {\n      body = {};\n    }\n\n    return body;\n  }\n  /**\r\n   * creates a response\r\n   * @private\r\n   * @param {ChaosHandlerOptions} ChaosHandlerOptions - The ChaosHandlerOptions object\r\n   * @param {Context} context - Contains the context of the request\r\n   */\n\n\n  createResponse(chaosHandlerOptions, context) {\n    try {\n      let responseBody;\n      let responseHeader;\n      let requestID;\n      let requestDate;\n      const requestURL = context.request;\n      requestID = generateUUID();\n      requestDate = new Date();\n      responseHeader = this.createResponseHeaders(chaosHandlerOptions.statusCode, requestID, requestDate.toString());\n      responseBody = this.createResponseBody(chaosHandlerOptions.statusCode, chaosHandlerOptions.statusMessage, requestID, requestDate.toString(), chaosHandlerOptions.responseBody);\n      const init = {\n        url: requestURL,\n        status: chaosHandlerOptions.statusCode,\n        statusText: chaosHandlerOptions.statusMessage,\n        headers: responseHeader\n      };\n      context.response = new Response(responseBody, init);\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\r\n   * Decides whether to send the request to the graph or not\r\n   * @private\r\n   * @param {ChaosHandlerOptions} chaosHandlerOptions - A ChaosHandlerOptions object\r\n   * @param {Context} context - Contains the context of the request\r\n   * @returns nothing\r\n   */\n\n\n  sendRequest(chaosHandlerOptions, context) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        this.setStatusCode(chaosHandlerOptions, context.request, context.options.method);\n\n        if (!chaosHandlerOptions.statusCode) {\n          yield this.nextMiddleware.execute(context);\n        } else {\n          this.createResponse(chaosHandlerOptions, context);\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Fetches a random status code for the RANDOM mode from the predefined array\r\n   * @private\r\n   * @param {string} requestMethod - the API method for the request\r\n   * @returns a random status code from a given set of status codes\r\n   */\n\n\n  getRandomStatusCode(requestMethod) {\n    try {\n      const statusCodeArray = methodStatusCode[requestMethod];\n      return statusCodeArray[Math.floor(Math.random() * statusCodeArray.length)];\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\r\n   * To fetch the relative URL out of the complete URL using a predefined regex pattern\r\n   * @private\r\n   * @param {string} urlMethod - the complete URL\r\n   * @returns the string as relative URL\r\n   */\n\n\n  getRelativeURL(urlMethod) {\n    const pattern = /https?:\\/\\/graph\\.microsoft\\.com\\/[^/]+(.+?)(\\?|$)/;\n    let relativeURL;\n\n    if (pattern.exec(urlMethod) !== null) {\n      relativeURL = pattern.exec(urlMethod)[1];\n    }\n\n    return relativeURL;\n  }\n  /**\r\n   * To fetch the status code from the map(if needed), then returns response by calling createResponse\r\n   * @private\r\n   * @param {ChaosHandlerOptions} ChaosHandlerOptions - The ChaosHandlerOptions object\r\n   * @param {string} requestURL - the URL for the request\r\n   * @param {string} requestMethod - the API method for the request\r\n   */\n\n\n  setStatusCode(chaosHandlerOptions, requestURL, requestMethod) {\n    try {\n      if (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL) {\n        if (chaosHandlerOptions.statusCode === undefined) {\n          // manual mode with no status code, can be a global level or request level without statusCode\n          const relativeURL = this.getRelativeURL(requestURL);\n\n          if (this.manualMap.get(relativeURL) !== undefined) {\n            // checking Manual Map for exact match\n            if (this.manualMap.get(relativeURL).get(requestMethod) !== undefined) {\n              chaosHandlerOptions.statusCode = this.manualMap.get(relativeURL).get(requestMethod);\n            } // else statusCode would be undefined\n\n          } else {\n            // checking for regex match if exact match doesn't work\n            this.manualMap.forEach((value, key) => {\n              const regexURL = new RegExp(key + \"$\");\n\n              if (regexURL.test(relativeURL)) {\n                if (this.manualMap.get(key).get(requestMethod) !== undefined) {\n                  chaosHandlerOptions.statusCode = this.manualMap.get(key).get(requestMethod);\n                } // else statusCode would be undefined\n\n              }\n            });\n          } // Case of redirection or request url not in map ---> statusCode would be undefined\n\n        }\n      } else {\n        // Handling the case of Random here\n        if (Math.floor(Math.random() * 100) < chaosHandlerOptions.chaosPercentage) {\n          chaosHandlerOptions.statusCode = this.getRandomStatusCode(requestMethod);\n        } // else statusCode would be undefined\n\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\r\n   * To get the options for execution of the middleware\r\n   * @private\r\n   * @param {Context} context - The context object\r\n   * @returns options for middleware execution\r\n   */\n\n\n  getOptions(context) {\n    let options;\n\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(ChaosHandlerOptions);\n    }\n\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new ChaosHandlerOptions(), this.options);\n    }\n\n    return options;\n  }\n  /**\r\n   * To execute the current middleware\r\n   * @public\r\n   * @async\r\n   * @param {Context} context - The context object of the request\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  execute(context) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const chaosHandlerOptions = this.getOptions(context);\n        return yield this.sendRequest(chaosHandlerOptions, context);\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * To set the next middleware in the chain\r\n   * @param {Middleware} next - The middleware instance\r\n   * @returns Nothing\r\n   */\n\n\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n\n}","map":{"version":3,"sources":["../../../src/middleware/ChaosHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { MiddlewareControl } from \"./MiddlewareControl\";\r\nimport { generateUUID } from \"./MiddlewareUtil\";\r\nimport { httpStatusCode, methodStatusCode } from \"./options/ChaosHandlerData\";\r\nimport { ChaosHandlerOptions } from \"./options/ChaosHandlerOptions\";\r\nimport { ChaosStrategy } from \"./options/ChaosStrategy\";\r\n/**\r\n * Class representing ChaosHandler\r\n * @class\r\n * Class\r\n * @implements Middleware\r\n */\r\nexport class ChaosHandler {\r\n    /**\r\n     * @public\r\n     * @constructor\r\n     * To create an instance of Testing Handler\r\n     * @param {ChaosHandlerOptions} [options = new ChaosHandlerOptions()] - The testing handler options instance\r\n     * @param manualMap - The Map passed by user containing url-statusCode info\r\n     * @returns An instance of Testing Handler\r\n     */\r\n    constructor(options = new ChaosHandlerOptions(), manualMap) {\r\n        this.options = options;\r\n        this.manualMap = manualMap;\r\n    }\r\n    /**\r\n     * Generates responseHeader\r\n     * @private\r\n     * @param {number} statusCode - the status code to be returned for the request\r\n     * @param {string} requestID - request id\r\n     * @param {string} requestDate - date of the request\r\n     * @returns response Header\r\n     */\r\n    createResponseHeaders(statusCode, requestID, requestDate) {\r\n        const responseHeader = new Headers();\r\n        responseHeader.append(\"Cache-Control\", \"no-store\");\r\n        responseHeader.append(\"request-id\", requestID);\r\n        responseHeader.append(\"client-request-id\", requestID);\r\n        responseHeader.append(\"x-ms-ags-diagnostic\", \"\");\r\n        responseHeader.append(\"Date\", requestDate);\r\n        responseHeader.append(\"Strict-Transport-Security\", \"\");\r\n        if (statusCode === 429) {\r\n            // throttling case has to have a timeout scenario\r\n            responseHeader.append(\"retry-after\", \"300\");\r\n        }\r\n        return responseHeader;\r\n    }\r\n    /**\r\n     * Generates responseBody\r\n     * @private\r\n     * @param {number} statusCode - the status code to be returned for the request\r\n     * @param {string} statusMessage - the status message to be returned for the request\r\n     * @param {string} requestID - request id\r\n     * @param {string} requestDate - date of the request\r\n     * @param {any?} requestBody - the request body to be returned for the request\r\n     * @returns response body\r\n     */\r\n    createResponseBody(statusCode, statusMessage, requestID, requestDate, responseBody) {\r\n        if (responseBody) {\r\n            return responseBody;\r\n        }\r\n        let body;\r\n        if (statusCode >= 400) {\r\n            const codeMessage = httpStatusCode[statusCode];\r\n            const errMessage = statusMessage;\r\n            body = {\r\n                error: {\r\n                    code: codeMessage,\r\n                    message: errMessage,\r\n                    innerError: {\r\n                        \"request-id\": requestID,\r\n                        date: requestDate,\r\n                    },\r\n                },\r\n            };\r\n        }\r\n        else {\r\n            body = {};\r\n        }\r\n        return body;\r\n    }\r\n    /**\r\n     * creates a response\r\n     * @private\r\n     * @param {ChaosHandlerOptions} ChaosHandlerOptions - The ChaosHandlerOptions object\r\n     * @param {Context} context - Contains the context of the request\r\n     */\r\n    createResponse(chaosHandlerOptions, context) {\r\n        try {\r\n            let responseBody;\r\n            let responseHeader;\r\n            let requestID;\r\n            let requestDate;\r\n            const requestURL = context.request;\r\n            requestID = generateUUID();\r\n            requestDate = new Date();\r\n            responseHeader = this.createResponseHeaders(chaosHandlerOptions.statusCode, requestID, requestDate.toString());\r\n            responseBody = this.createResponseBody(chaosHandlerOptions.statusCode, chaosHandlerOptions.statusMessage, requestID, requestDate.toString(), chaosHandlerOptions.responseBody);\r\n            const init = { url: requestURL, status: chaosHandlerOptions.statusCode, statusText: chaosHandlerOptions.statusMessage, headers: responseHeader };\r\n            context.response = new Response(responseBody, init);\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * Decides whether to send the request to the graph or not\r\n     * @private\r\n     * @param {ChaosHandlerOptions} chaosHandlerOptions - A ChaosHandlerOptions object\r\n     * @param {Context} context - Contains the context of the request\r\n     * @returns nothing\r\n     */\r\n    sendRequest(chaosHandlerOptions, context) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                this.setStatusCode(chaosHandlerOptions, context.request, context.options.method);\r\n                if (!chaosHandlerOptions.statusCode) {\r\n                    yield this.nextMiddleware.execute(context);\r\n                }\r\n                else {\r\n                    this.createResponse(chaosHandlerOptions, context);\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Fetches a random status code for the RANDOM mode from the predefined array\r\n     * @private\r\n     * @param {string} requestMethod - the API method for the request\r\n     * @returns a random status code from a given set of status codes\r\n     */\r\n    getRandomStatusCode(requestMethod) {\r\n        try {\r\n            const statusCodeArray = methodStatusCode[requestMethod];\r\n            return statusCodeArray[Math.floor(Math.random() * statusCodeArray.length)];\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * To fetch the relative URL out of the complete URL using a predefined regex pattern\r\n     * @private\r\n     * @param {string} urlMethod - the complete URL\r\n     * @returns the string as relative URL\r\n     */\r\n    getRelativeURL(urlMethod) {\r\n        const pattern = /https?:\\/\\/graph\\.microsoft\\.com\\/[^/]+(.+?)(\\?|$)/;\r\n        let relativeURL;\r\n        if (pattern.exec(urlMethod) !== null) {\r\n            relativeURL = pattern.exec(urlMethod)[1];\r\n        }\r\n        return relativeURL;\r\n    }\r\n    /**\r\n     * To fetch the status code from the map(if needed), then returns response by calling createResponse\r\n     * @private\r\n     * @param {ChaosHandlerOptions} ChaosHandlerOptions - The ChaosHandlerOptions object\r\n     * @param {string} requestURL - the URL for the request\r\n     * @param {string} requestMethod - the API method for the request\r\n     */\r\n    setStatusCode(chaosHandlerOptions, requestURL, requestMethod) {\r\n        try {\r\n            if (chaosHandlerOptions.chaosStrategy === ChaosStrategy.MANUAL) {\r\n                if (chaosHandlerOptions.statusCode === undefined) {\r\n                    // manual mode with no status code, can be a global level or request level without statusCode\r\n                    const relativeURL = this.getRelativeURL(requestURL);\r\n                    if (this.manualMap.get(relativeURL) !== undefined) {\r\n                        // checking Manual Map for exact match\r\n                        if (this.manualMap.get(relativeURL).get(requestMethod) !== undefined) {\r\n                            chaosHandlerOptions.statusCode = this.manualMap.get(relativeURL).get(requestMethod);\r\n                        }\r\n                        // else statusCode would be undefined\r\n                    }\r\n                    else {\r\n                        // checking for regex match if exact match doesn't work\r\n                        this.manualMap.forEach((value, key) => {\r\n                            const regexURL = new RegExp(key + \"$\");\r\n                            if (regexURL.test(relativeURL)) {\r\n                                if (this.manualMap.get(key).get(requestMethod) !== undefined) {\r\n                                    chaosHandlerOptions.statusCode = this.manualMap.get(key).get(requestMethod);\r\n                                }\r\n                                // else statusCode would be undefined\r\n                            }\r\n                        });\r\n                    }\r\n                    // Case of redirection or request url not in map ---> statusCode would be undefined\r\n                }\r\n            }\r\n            else {\r\n                // Handling the case of Random here\r\n                if (Math.floor(Math.random() * 100) < chaosHandlerOptions.chaosPercentage) {\r\n                    chaosHandlerOptions.statusCode = this.getRandomStatusCode(requestMethod);\r\n                }\r\n                // else statusCode would be undefined\r\n            }\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * To get the options for execution of the middleware\r\n     * @private\r\n     * @param {Context} context - The context object\r\n     * @returns options for middleware execution\r\n     */\r\n    getOptions(context) {\r\n        let options;\r\n        if (context.middlewareControl instanceof MiddlewareControl) {\r\n            options = context.middlewareControl.getMiddlewareOptions(ChaosHandlerOptions);\r\n        }\r\n        if (typeof options === \"undefined\") {\r\n            options = Object.assign(new ChaosHandlerOptions(), this.options);\r\n        }\r\n        return options;\r\n    }\r\n    /**\r\n     * To execute the current middleware\r\n     * @public\r\n     * @async\r\n     * @param {Context} context - The context object of the request\r\n     * @returns A Promise that resolves to nothing\r\n     */\r\n    execute(context) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const chaosHandlerOptions = this.getOptions(context);\r\n                return yield this.sendRequest(chaosHandlerOptions, context);\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * To set the next middleware in the chain\r\n     * @param {Middleware} next - The middleware instance\r\n     * @returns Nothing\r\n     */\r\n    setNext(next) {\r\n        this.nextMiddleware = next;\r\n    }\r\n}\r\n//# sourceMappingURL=ChaosHandler.js.map"]},"metadata":{},"sourceType":"module"}