{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { __extends } from '../_virtual/_tslib.js';\nimport { Constants as Constants$1, CredentialType, CacheSchemaType, THE_FAMILY_ID, APP_METADATA, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from '../utils/Constants.js';\nimport { AuthError as AuthError$1 } from '../error/AuthError.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../error/ClientAuthError.js';\nimport { CredentialEntity as CredentialEntity$1 } from './entities/CredentialEntity.js';\nimport { ScopeSet as ScopeSet$1 } from '../request/ScopeSet.js';\nimport { AccountEntity as AccountEntity$1 } from './entities/AccountEntity.js';\nimport { AuthToken as AuthToken$1 } from '../account/AuthToken.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\n\nvar CacheManager = function () {\n  function CacheManager(clientId, cryptoImpl) {\n    this.clientId = clientId;\n    this.cryptoImpl = cryptoImpl;\n  }\n  /**\r\n   * Returns all accounts in cache\r\n   */\n\n\n  CacheManager.prototype.getAllAccounts = function () {\n    var _this = this;\n\n    var currentAccounts = this.getAccountsFilteredBy();\n    var accountValues = Object.keys(currentAccounts).map(function (accountKey) {\n      return currentAccounts[accountKey];\n    });\n    var numAccounts = accountValues.length;\n\n    if (numAccounts < 1) {\n      return [];\n    } else {\n      var allAccounts = accountValues.map(function (value) {\n        var accountEntity = CacheManager.toObject(new AccountEntity$1(), value);\n        var accountInfo = accountEntity.getAccountInfo();\n\n        var idToken = _this.readIdTokenFromCache(_this.clientId, accountInfo);\n\n        if (idToken && !accountInfo.idTokenClaims) {\n          accountInfo.idTokenClaims = new AuthToken$1(idToken.secret, _this.cryptoImpl).claims;\n        }\n\n        return accountInfo;\n      });\n      return allAccounts;\n    }\n  };\n  /**\r\n   * saves a cache record\r\n   * @param cacheRecord\r\n   */\n\n\n  CacheManager.prototype.saveCacheRecord = function (cacheRecord) {\n    if (!cacheRecord) {\n      throw ClientAuthError$1.createNullOrUndefinedCacheRecord();\n    }\n\n    if (!!cacheRecord.account) {\n      this.setAccount(cacheRecord.account);\n    }\n\n    if (!!cacheRecord.idToken) {\n      this.setIdTokenCredential(cacheRecord.idToken);\n    }\n\n    if (!!cacheRecord.accessToken) {\n      this.saveAccessToken(cacheRecord.accessToken);\n    }\n\n    if (!!cacheRecord.refreshToken) {\n      this.setRefreshTokenCredential(cacheRecord.refreshToken);\n    }\n\n    if (!!cacheRecord.appMetadata) {\n      this.setAppMetadata(cacheRecord.appMetadata);\n    }\n  };\n  /**\r\n   * saves access token credential\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.saveAccessToken = function (credential) {\n    var _this = this;\n\n    var currentTokenCache = this.getCredentialsFilteredBy({\n      clientId: credential.clientId,\n      credentialType: credential.credentialType,\n      environment: credential.environment,\n      homeAccountId: credential.homeAccountId,\n      realm: credential.realm\n    });\n    var currentScopes = ScopeSet$1.fromString(credential.target);\n    var currentAccessTokens = Object.keys(currentTokenCache.accessTokens).map(function (key) {\n      return currentTokenCache.accessTokens[key];\n    });\n\n    if (currentAccessTokens) {\n      currentAccessTokens.forEach(function (tokenEntity) {\n        var tokenScopeSet = ScopeSet$1.fromString(tokenEntity.target);\n\n        if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\n          _this.removeCredential(tokenEntity);\n        }\n      });\n    }\n\n    this.setAccessTokenCredential(credential);\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredBy = function (accountFilter) {\n    return this.getAccountsFilteredByInternal(accountFilter ? accountFilter.homeAccountId : \"\", accountFilter ? accountFilter.environment : \"\", accountFilter ? accountFilter.realm : \"\");\n  };\n  /**\r\n   * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n   * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.getAccountsFilteredByInternal = function (homeAccountId, environment, realm) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAccounts = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n\n      matchingAccounts[cacheKey] = entity;\n    });\n    return matchingAccounts;\n  };\n  /**\r\n   * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.getCredentialsFilteredBy = function (filter) {\n    return this.getCredentialsFilteredByInternal(filter.homeAccountId, filter.environment, filter.credentialType, filter.clientId, filter.familyId, filter.realm, filter.target, filter.oboAssertion);\n  };\n  /**\r\n   * Support function to help match credentials\r\n   * @param homeAccountId\r\n   * @param environment\r\n   * @param credentialType\r\n   * @param clientId\r\n   * @param realm\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.getCredentialsFilteredByInternal = function (homeAccountId, environment, credentialType, clientId, familyId, realm, target, oboAssertion) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingCredentials = {\n      idTokens: {},\n      accessTokens: {},\n      refreshTokens: {}\n    };\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity$1.getCredentialType(cacheKey);\n\n      if (credType === Constants$1.NOT_DEFINED) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getSpecificCredential(cacheKey, credType);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!oboAssertion && !_this.matchOboAssertion(entity, oboAssertion)) {\n        return;\n      }\n\n      if (!!homeAccountId && !_this.matchHomeAccountId(entity, homeAccountId)) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!realm && !_this.matchRealm(entity, realm)) {\n        return;\n      }\n\n      if (!!credentialType && !_this.matchCredentialType(entity, credentialType)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      if (!!familyId && !_this.matchFamilyId(entity, familyId)) {\n        return;\n      }\n      /*\r\n       * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n       * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n       */\n\n\n      if (!!target && !_this.matchTarget(entity, target)) {\n        return;\n      }\n\n      switch (credType) {\n        case CredentialType.ID_TOKEN:\n          matchingCredentials.idTokens[cacheKey] = entity;\n          break;\n\n        case CredentialType.ACCESS_TOKEN:\n        case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n          matchingCredentials.accessTokens[cacheKey] = entity;\n          break;\n\n        case CredentialType.REFRESH_TOKEN:\n          matchingCredentials.refreshTokens[cacheKey] = entity;\n          break;\n      }\n    });\n    return matchingCredentials;\n  };\n  /**\r\n   * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredBy = function (filter) {\n    return this.getAppMetadataFilteredByInternal(filter.environment, filter.clientId);\n  };\n  /**\r\n   * Support function to help match appMetadata\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.getAppMetadataFilteredByInternal = function (environment, clientId) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var matchingAppMetadata = {};\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-appMetadata type cache entities\n      if (!_this.isAppMetadata(cacheKey)) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAppMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (!!environment && !_this.matchEnvironment(entity, environment)) {\n        return;\n      }\n\n      if (!!clientId && !_this.matchClientId(entity, clientId)) {\n        return;\n      }\n\n      matchingAppMetadata[cacheKey] = entity;\n    });\n    return matchingAppMetadata;\n  };\n  /**\r\n   * retrieve authorityMetadata that contains a matching alias\r\n   * @param filter\r\n   */\n\n\n  CacheManager.prototype.getAuthorityMetadataByAlias = function (host) {\n    var _this = this;\n\n    var allCacheKeys = this.getAuthorityMetadataKeys();\n    var matchedEntity = null;\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-authorityMetadata type cache entities\n      if (!_this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(_this.clientId) === -1) {\n        return;\n      } // Attempt retrieval\n\n\n      var entity = _this.getAuthorityMetadata(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      if (entity.aliases.indexOf(host) === -1) {\n        return;\n      }\n\n      matchedEntity = entity;\n    });\n    return matchedEntity;\n  };\n  /**\r\n   * Removes all accounts and related tokens from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAllAccounts = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      var entity = _this.getAccount(cacheKey);\n\n      if (!entity) {\n        return;\n      }\n\n      _this.removeAccount(cacheKey);\n    });\n    return true;\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccount = function (accountKey) {\n    var account = this.getAccount(accountKey);\n\n    if (!account) {\n      throw ClientAuthError$1.createNoAccountFoundError();\n    }\n\n    return this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT);\n  };\n  /**\r\n   * returns a boolean if the given account is removed\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.removeAccountContext = function (account) {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    var accountId = account.generateAccountId();\n    allCacheKeys.forEach(function (cacheKey) {\n      // don't parse any non-credential type cache entities\n      var credType = CredentialEntity$1.getCredentialType(cacheKey);\n\n      if (credType === Constants$1.NOT_DEFINED) {\n        return;\n      }\n\n      var cacheEntity = _this.getSpecificCredential(cacheKey, credType);\n\n      if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\n        _this.removeCredential(cacheEntity);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * returns a boolean if the given credential is removed\r\n   * @param credential\r\n   */\n\n\n  CacheManager.prototype.removeCredential = function (credential) {\n    var key = credential.generateCredentialKey();\n    return this.removeItem(key, CacheSchemaType.CREDENTIAL);\n  };\n  /**\r\n   * Removes all app metadata objects from cache.\r\n   */\n\n\n  CacheManager.prototype.removeAppMetadata = function () {\n    var _this = this;\n\n    var allCacheKeys = this.getKeys();\n    allCacheKeys.forEach(function (cacheKey) {\n      if (_this.isAppMetadata(cacheKey)) {\n        _this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\n      }\n    });\n    return true;\n  };\n  /**\r\n   * Retrieve the cached credentials into a cacherecord\r\n   * @param account\r\n   * @param clientId\r\n   * @param scopes\r\n   * @param environment\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readCacheRecord = function (account, clientId, scopes, environment, authScheme) {\n    var cachedAccount = this.readAccountFromCache(account);\n    var cachedIdToken = this.readIdTokenFromCache(clientId, account);\n    var cachedAccessToken = this.readAccessTokenFromCache(clientId, account, scopes, authScheme);\n    var cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\n    var cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\n\n    if (cachedAccount && cachedIdToken) {\n      cachedAccount.idTokenClaims = new AuthToken$1(cachedIdToken.secret, this.cryptoImpl).claims;\n    }\n\n    return {\n      account: cachedAccount,\n      idToken: cachedIdToken,\n      accessToken: cachedAccessToken,\n      refreshToken: cachedRefreshToken,\n      appMetadata: cachedAppMetadata\n    };\n  };\n  /**\r\n   * Retrieve AccountEntity from cache\r\n   * @param account\r\n   */\n\n\n  CacheManager.prototype.readAccountFromCache = function (account) {\n    var accountKey = AccountEntity$1.generateAccountCacheKey(account);\n    return this.getAccount(accountKey);\n  };\n  /**\r\n   * Retrieve IdTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param inputRealm\r\n   */\n\n\n  CacheManager.prototype.readIdTokenFromCache = function (clientId, account) {\n    var idTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.ID_TOKEN,\n      clientId: clientId,\n      realm: account.tenantId\n    };\n    var credentialCache = this.getCredentialsFilteredBy(idTokenFilter);\n    var idTokens = Object.keys(credentialCache.idTokens).map(function (key) {\n      return credentialCache.idTokens[key];\n    });\n    var numIdTokens = idTokens.length;\n\n    if (numIdTokens < 1) {\n      return null;\n    } else if (numIdTokens > 1) {\n      throw ClientAuthError$1.createMultipleMatchingTokensInCacheError();\n    }\n\n    return idTokens[0];\n  };\n  /**\r\n   * Retrieve AccessTokenEntity from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param scopes\r\n   * @param authScheme\r\n   */\n\n\n  CacheManager.prototype.readAccessTokenFromCache = function (clientId, account, scopes, authScheme) {\n    var credentialType = authScheme === AuthenticationScheme.POP ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\n    var accessTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: credentialType,\n      clientId: clientId,\n      realm: account.tenantId,\n      target: scopes.printScopesLowerCase()\n    };\n    var credentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\n    var accessTokens = Object.keys(credentialCache.accessTokens).map(function (key) {\n      return credentialCache.accessTokens[key];\n    });\n    var numAccessTokens = accessTokens.length;\n\n    if (numAccessTokens < 1) {\n      return null;\n    } else if (numAccessTokens > 1) {\n      throw ClientAuthError$1.createMultipleMatchingTokensInCacheError();\n    }\n\n    return accessTokens[0];\n  };\n  /**\r\n   * Helper to retrieve the appropriate refresh token from cache\r\n   * @param clientId\r\n   * @param account\r\n   * @param familyRT\r\n   */\n\n\n  CacheManager.prototype.readRefreshTokenFromCache = function (clientId, account, familyRT) {\n    var id = familyRT ? THE_FAMILY_ID : undefined;\n    var refreshTokenFilter = {\n      homeAccountId: account.homeAccountId,\n      environment: account.environment,\n      credentialType: CredentialType.REFRESH_TOKEN,\n      clientId: clientId,\n      familyId: id\n    };\n    var credentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\n    var refreshTokens = Object.keys(credentialCache.refreshTokens).map(function (key) {\n      return credentialCache.refreshTokens[key];\n    });\n    var numRefreshTokens = refreshTokens.length;\n\n    if (numRefreshTokens < 1) {\n      return null;\n    } // address the else case after remove functions address environment aliases\n\n\n    return refreshTokens[0];\n  };\n  /**\r\n   * Retrieve AppMetadataEntity from cache\r\n   */\n\n\n  CacheManager.prototype.readAppMetadataFromCache = function (environment, clientId) {\n    var appMetadataFilter = {\n      environment: environment,\n      clientId: clientId\n    };\n    var appMetadata = this.getAppMetadataFilteredBy(appMetadataFilter);\n    var appMetadataEntries = Object.keys(appMetadata).map(function (key) {\n      return appMetadata[key];\n    });\n    var numAppMetadata = appMetadataEntries.length;\n\n    if (numAppMetadata < 1) {\n      return null;\n    } else if (numAppMetadata > 1) {\n      throw ClientAuthError$1.createMultipleMatchingAppMetadataInCacheError();\n    }\n\n    return appMetadataEntries[0];\n  };\n  /**\r\n   * Return the family_id value associated  with FOCI\r\n   * @param environment\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.isAppMetadataFOCI = function (environment, clientId) {\n    var appMetadata = this.readAppMetadataFromCache(environment, clientId);\n    return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\n  };\n  /**\r\n   * helper to match account ids\r\n   * @param value\r\n   * @param homeAccountId\r\n   */\n\n\n  CacheManager.prototype.matchHomeAccountId = function (entity, homeAccountId) {\n    return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);\n  };\n  /**\r\n   * helper to match assertion\r\n   * @param value\r\n   * @param oboAssertion\r\n   */\n\n\n  CacheManager.prototype.matchOboAssertion = function (entity, oboAssertion) {\n    return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion);\n  };\n  /**\r\n   * helper to match environment\r\n   * @param value\r\n   * @param environment\r\n   */\n\n\n  CacheManager.prototype.matchEnvironment = function (entity, environment) {\n    var cloudMetadata = this.getAuthorityMetadataByAlias(environment);\n\n    if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\r\n   * helper to match credential type\r\n   * @param entity\r\n   * @param credentialType\r\n   */\n\n\n  CacheManager.prototype.matchCredentialType = function (entity, credentialType) {\n    return entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase();\n  };\n  /**\r\n   * helper to match client ids\r\n   * @param entity\r\n   * @param clientId\r\n   */\n\n\n  CacheManager.prototype.matchClientId = function (entity, clientId) {\n    return !!(entity.clientId && clientId === entity.clientId);\n  };\n  /**\r\n   * helper to match family ids\r\n   * @param entity\r\n   * @param familyId\r\n   */\n\n\n  CacheManager.prototype.matchFamilyId = function (entity, familyId) {\n    return !!(entity.familyId && familyId === entity.familyId);\n  };\n  /**\r\n   * helper to match realm\r\n   * @param entity\r\n   * @param realm\r\n   */\n\n\n  CacheManager.prototype.matchRealm = function (entity, realm) {\n    return !!(entity.realm && realm === entity.realm);\n  };\n  /**\r\n   * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n   * @param entity\r\n   * @param target\r\n   */\n\n\n  CacheManager.prototype.matchTarget = function (entity, target) {\n    var isNotAccessTokenCredential = entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME;\n\n    if (isNotAccessTokenCredential || !entity.target) {\n      return false;\n    }\n\n    var entityScopeSet = ScopeSet$1.fromString(entity.target);\n    var requestTargetScopeSet = ScopeSet$1.fromString(target);\n\n    if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\n      requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\n    } else {\n      requestTargetScopeSet.removeScope(Constants$1.OFFLINE_ACCESS_SCOPE);\n    }\n\n    return entityScopeSet.containsScopeSet(requestTargetScopeSet);\n  };\n  /**\r\n   * returns if a given cache entity is of the type appmetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAppMetadata = function (key) {\n    return key.indexOf(APP_METADATA) !== -1;\n  };\n  /**\r\n   * returns if a given cache entity is of the type authoritymetadata\r\n   * @param key\r\n   */\n\n\n  CacheManager.prototype.isAuthorityMetadata = function (key) {\n    return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\n  };\n  /**\r\n   * returns cache key used for cloud instance metadata\r\n   */\n\n\n  CacheManager.prototype.generateAuthorityMetadataCacheKey = function (authority) {\n    return AUTHORITY_METADATA_CONSTANTS.CACHE_KEY + \"-\" + this.clientId + \"-\" + authority;\n  };\n  /**\r\n   * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n   * @param key\r\n   * @param credType\r\n   */\n\n\n  CacheManager.prototype.getSpecificCredential = function (key, credType) {\n    switch (credType) {\n      case CredentialType.ID_TOKEN:\n        {\n          return this.getIdTokenCredential(key);\n        }\n\n      case CredentialType.ACCESS_TOKEN:\n      case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\n        {\n          return this.getAccessTokenCredential(key);\n        }\n\n      case CredentialType.REFRESH_TOKEN:\n        {\n          return this.getRefreshTokenCredential(key);\n        }\n\n      default:\n        return null;\n    }\n  };\n  /**\r\n   * Helper to convert serialized data to object\r\n   * @param obj\r\n   * @param json\r\n   */\n\n\n  CacheManager.toObject = function (obj, json) {\n    for (var propertyName in json) {\n      obj[propertyName] = json[propertyName];\n    }\n\n    return obj;\n  };\n\n  return CacheManager;\n}();\n\nvar DefaultStorageClass = function (_super) {\n  __extends(DefaultStorageClass, _super);\n\n  function DefaultStorageClass() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  DefaultStorageClass.prototype.setAccount = function () {\n    var notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccount = function () {\n    var notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getIdTokenCredential = function () {\n    var notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAccessTokenCredential = function () {\n    var notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getRefreshTokenCredential = function () {\n    var notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAppMetadata = function () {\n    var notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAppMetadata = function () {\n    var notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setServerTelemetry = function () {\n    var notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getServerTelemetry = function () {\n    var notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadata = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getAuthorityMetadataKeys = function () {\n    var notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.setThrottlingCache = function () {\n    var notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getThrottlingCache = function () {\n    var notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.removeItem = function () {\n    var notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.containsKey = function () {\n    var notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.getKeys = function () {\n    var notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  DefaultStorageClass.prototype.clear = function () {\n    var notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\n    throw AuthError$1.createUnexpectedError(notImplErr);\n  };\n\n  return DefaultStorageClass;\n}(CacheManager);\n\nexport { CacheManager, DefaultStorageClass };","map":{"version":3,"sources":["../../src/cache/CacheManager.ts"],"names":["AccountEntity","AuthToken","ClientAuthError","ScopeSet","CredentialEntity","Constants","AuthError"],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { AccountCache, AccountFilter, CredentialFilter, CredentialCache, ValidCredentialType, AppMetadataFilter, AppMetadataCache } from \"./utils/CacheTypes\";\r\nimport { CacheRecord } from \"./entities/CacheRecord\";\r\nimport { CacheSchemaType, CredentialType, Constants, APP_METADATA, THE_FAMILY_ID, AUTHORITY_METADATA_CONSTANTS, AuthenticationScheme } from \"../utils/Constants\";\r\nimport { CredentialEntity } from \"./entities/CredentialEntity\";\r\nimport { ScopeSet } from \"../request/ScopeSet\";\r\nimport { AccountEntity } from \"./entities/AccountEntity\";\r\nimport { AccessTokenEntity } from \"./entities/AccessTokenEntity\";\r\nimport { IdTokenEntity } from \"./entities/IdTokenEntity\";\r\nimport { RefreshTokenEntity } from \"./entities/RefreshTokenEntity\";\r\nimport { AuthError } from \"../error/AuthError\";\r\nimport { ICacheManager } from \"./interface/ICacheManager\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\nimport { AccountInfo } from \"../account/AccountInfo\";\r\nimport { AppMetadataEntity } from \"./entities/AppMetadataEntity\";\r\nimport { ServerTelemetryEntity } from \"./entities/ServerTelemetryEntity\";\r\nimport { ThrottlingEntity } from \"./entities/ThrottlingEntity\";\r\nimport { AuthToken } from \"../account/AuthToken\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { AuthorityMetadataEntity } from \"./entities/AuthorityMetadataEntity\";\r\n\r\n/**\r\n * Interface class which implement cache storage functions used by MSAL to perform validity checks, and store tokens.\r\n */\r\nexport abstract class CacheManager implements ICacheManager {\r\n    protected clientId: string;\r\n    protected cryptoImpl: ICrypto;\r\n\r\n    constructor(clientId: string, cryptoImpl: ICrypto) {\r\n        this.clientId = clientId;\r\n        this.cryptoImpl = cryptoImpl;\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     *  @param accountKey\r\n     */\r\n    abstract getAccount(accountKey: string): AccountEntity | null;\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param account\r\n     */\r\n    abstract setAccount(account: AccountEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param idTokenKey\r\n     */\r\n    abstract getIdTokenCredential(idTokenKey: string): IdTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param idToken\r\n     */\r\n    abstract setIdTokenCredential(idToken: IdTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param accessTokenKey\r\n     */\r\n    abstract getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param accessToken\r\n     */\r\n    abstract setAccessTokenCredential(accessToken: AccessTokenEntity): void;\r\n\r\n    /**\r\n     * fetch the idToken entity from the platform cache\r\n     * @param refreshTokenKey\r\n     */\r\n    abstract getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null;\r\n\r\n    /**\r\n     * set idToken entity to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    abstract setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void;\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    abstract getAppMetadata(appMetadataKey: string): AppMetadataEntity | null;\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    abstract setAppMetadata(appMetadata: AppMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    abstract getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null;\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    abstract setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void;\r\n\r\n    /**\r\n     * fetch cloud discovery metadata entity from the platform cache\r\n     * @param key\r\n     */\r\n    abstract getAuthorityMetadata(key: string): AuthorityMetadataEntity | null;\r\n\r\n    /**\r\n     * \r\n     */\r\n    abstract getAuthorityMetadataKeys(): Array<string>;\r\n\r\n    /**\r\n     * set cloud discovery metadata entity to the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    abstract setAuthorityMetadata(key: string, value: AuthorityMetadataEntity): void;\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    abstract getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null;\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    abstract setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void;;\r\n\r\n    /**\r\n     * Function to remove an item from cache given its key.\r\n     * @param key\r\n     */\r\n    abstract removeItem(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which returns boolean whether cache contains a specific key.\r\n     * @param key\r\n     */\r\n    abstract containsKey(key: string, type?: string): boolean;\r\n\r\n    /**\r\n     * Function which retrieves all current keys from the cache.\r\n     */\r\n    abstract getKeys(): string[];\r\n\r\n    /**\r\n     * Function which clears cache.\r\n     */\r\n    abstract clear(): void;\r\n\r\n    /**\r\n     * Returns all accounts in cache\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        const currentAccounts: AccountCache = this.getAccountsFilteredBy();\r\n        const accountValues: AccountEntity[] = Object.keys(currentAccounts).map(accountKey => currentAccounts[accountKey]);\r\n        const numAccounts = accountValues.length;\r\n        if (numAccounts < 1) {\r\n            return [];\r\n        } else {\r\n            const allAccounts = accountValues.map<AccountInfo>((value) => {\r\n                const accountEntity = CacheManager.toObject<AccountEntity>(new AccountEntity(), value);\r\n                const accountInfo = accountEntity.getAccountInfo();\r\n                const idToken = this.readIdTokenFromCache(this.clientId, accountInfo);\r\n                if (idToken && !accountInfo.idTokenClaims) {\r\n                    accountInfo.idTokenClaims = new AuthToken(idToken.secret, this.cryptoImpl).claims;\r\n                }\r\n\r\n                return accountInfo;\r\n                \r\n            });\r\n            return allAccounts;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves a cache record\r\n     * @param cacheRecord\r\n     */\r\n    saveCacheRecord(cacheRecord: CacheRecord): void {\r\n        if (!cacheRecord) {\r\n            throw ClientAuthError.createNullOrUndefinedCacheRecord();\r\n        }\r\n\r\n        if (!!cacheRecord.account) {\r\n            this.setAccount(cacheRecord.account);\r\n        }\r\n\r\n        if (!!cacheRecord.idToken) {\r\n            this.setIdTokenCredential(cacheRecord.idToken);\r\n        }\r\n\r\n        if (!!cacheRecord.accessToken) {\r\n            this.saveAccessToken(cacheRecord.accessToken);\r\n        }\r\n\r\n        if (!!cacheRecord.refreshToken) {\r\n            this.setRefreshTokenCredential(cacheRecord.refreshToken);\r\n        }\r\n\r\n        if (!!cacheRecord.appMetadata) {\r\n            this.setAppMetadata(cacheRecord.appMetadata);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * saves access token credential\r\n     * @param credential\r\n     */\r\n    private saveAccessToken(credential: AccessTokenEntity): void {\r\n        const currentTokenCache = this.getCredentialsFilteredBy({\r\n            clientId: credential.clientId,\r\n            credentialType: credential.credentialType,\r\n            environment: credential.environment,\r\n            homeAccountId: credential.homeAccountId,\r\n            realm: credential.realm,\r\n        });\r\n        const currentScopes = ScopeSet.fromString(credential.target);\r\n        const currentAccessTokens: AccessTokenEntity[] = Object.keys(currentTokenCache.accessTokens).map(key => currentTokenCache.accessTokens[key]);\r\n        if (currentAccessTokens) {\r\n            currentAccessTokens.forEach((tokenEntity) => {\r\n                const tokenScopeSet = ScopeSet.fromString(tokenEntity.target);\r\n                if (tokenScopeSet.intersectingScopeSets(currentScopes)) {\r\n                    this.removeCredential(tokenEntity);\r\n                }\r\n            });\r\n        }\r\n        this.setAccessTokenCredential(credential);\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    getAccountsFilteredBy(accountFilter?: AccountFilter): AccountCache {\r\n        return this.getAccountsFilteredByInternal(\r\n            accountFilter ? accountFilter.homeAccountId : \"\",\r\n            accountFilter ? accountFilter.environment : \"\",\r\n            accountFilter ? accountFilter.realm : \"\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * retrieve accounts matching all provided filters; if no filter is set, get all accounts\r\n     * not checking for casing as keys are all generated in lower case, remember to convert to lower case if object properties are compared\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param realm\r\n     */\r\n    private getAccountsFilteredByInternal(\r\n        homeAccountId?: string,\r\n        environment?: string,\r\n        realm?: string\r\n    ): AccountCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAccounts: AccountCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            const entity: AccountEntity | null = this.getAccount(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!homeAccountId && !this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!realm && !this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n\r\n            matchingAccounts[cacheKey] = entity;\r\n        });\r\n\r\n        return matchingAccounts;\r\n    }\r\n\r\n    /**\r\n     * retrieve credentails matching all provided filters; if no filter is set, get all credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    getCredentialsFilteredBy(filter: CredentialFilter): CredentialCache {\r\n        return this.getCredentialsFilteredByInternal(\r\n            filter.homeAccountId,\r\n            filter.environment,\r\n            filter.credentialType,\r\n            filter.clientId,\r\n            filter.familyId,\r\n            filter.realm,\r\n            filter.target,\r\n            filter.oboAssertion\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match credentials\r\n     * @param homeAccountId\r\n     * @param environment\r\n     * @param credentialType\r\n     * @param clientId\r\n     * @param realm\r\n     * @param target\r\n     */\r\n    private getCredentialsFilteredByInternal(\r\n        homeAccountId?: string,\r\n        environment?: string,\r\n        credentialType?: string,\r\n        clientId?: string,\r\n        familyId?: string,\r\n        realm?: string,\r\n        target?: string,\r\n        oboAssertion?: string\r\n    ): CredentialCache {\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingCredentials: CredentialCache = {\r\n            idTokens: {},\r\n            accessTokens: {},\r\n            refreshTokens: {},\r\n        };\r\n        \r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-credential type cache entities\r\n            const credType = CredentialEntity.getCredentialType(cacheKey);\r\n\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getSpecificCredential(cacheKey, credType);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!oboAssertion && !this.matchOboAssertion(entity, oboAssertion)) {\r\n                return;\r\n            }\r\n\r\n            if (!!homeAccountId && !this.matchHomeAccountId(entity, homeAccountId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!realm && !this.matchRealm(entity, realm)) {\r\n                return;\r\n            }\r\n\r\n            if (!!credentialType && !this.matchCredentialType(entity, credentialType)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            if (!!familyId && !this.matchFamilyId(entity, familyId)) {\r\n                return;\r\n            }\r\n\r\n            /*\r\n             * idTokens do not have \"target\", target specific refreshTokens do exist for some types of authentication\r\n             * Resource specific refresh tokens case will be added when the support is deemed necessary\r\n             */\r\n            if (!!target && !this.matchTarget(entity, target)) {\r\n                return;\r\n            }\r\n\r\n            switch (credType) {\r\n                case CredentialType.ID_TOKEN:\r\n                    matchingCredentials.idTokens[cacheKey] = entity as IdTokenEntity;\r\n                    break;\r\n                case CredentialType.ACCESS_TOKEN:\r\n                case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME:\r\n                    matchingCredentials.accessTokens[cacheKey] = entity as AccessTokenEntity;\r\n                    break;\r\n                case CredentialType.REFRESH_TOKEN:\r\n                    matchingCredentials.refreshTokens[cacheKey] = entity as RefreshTokenEntity;\r\n                    break;\r\n            }\r\n        });\r\n\r\n        return matchingCredentials;\r\n    }\r\n\r\n    /**\r\n     * retrieve appMetadata matching all provided filters; if no filter is set, get all appMetadata\r\n     * @param filter\r\n     */\r\n    getAppMetadataFilteredBy(filter: AppMetadataFilter): AppMetadataCache {\r\n        return this.getAppMetadataFilteredByInternal(\r\n            filter.environment,\r\n            filter.clientId,\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Support function to help match appMetadata\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    private getAppMetadataFilteredByInternal(\r\n        environment?: string,\r\n        clientId?: string\r\n    ): AppMetadataCache {\r\n\r\n        const allCacheKeys = this.getKeys();\r\n        const matchingAppMetadata: AppMetadataCache = {};\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-appMetadata type cache entities\r\n            if (!this.isAppMetadata(cacheKey)) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAppMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (!!environment && !this.matchEnvironment(entity, environment)) {\r\n                return;\r\n            }\r\n\r\n            if (!!clientId && !this.matchClientId(entity, clientId)) {\r\n                return;\r\n            }\r\n\r\n            matchingAppMetadata[cacheKey] = entity;\r\n\r\n        });\r\n\r\n        return matchingAppMetadata;\r\n    }\r\n\r\n    /**\r\n     * retrieve authorityMetadata that contains a matching alias\r\n     * @param filter\r\n     */\r\n    getAuthorityMetadataByAlias(host: string): AuthorityMetadataEntity | null {\r\n        const allCacheKeys = this.getAuthorityMetadataKeys();\r\n        let matchedEntity = null;\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-authorityMetadata type cache entities\r\n            if (!this.isAuthorityMetadata(cacheKey) || cacheKey.indexOf(this.clientId) === -1) {\r\n                return;\r\n            }\r\n\r\n            // Attempt retrieval\r\n            const entity = this.getAuthorityMetadata(cacheKey);\r\n\r\n            if (!entity) {\r\n                return;\r\n            }\r\n\r\n            if (entity.aliases.indexOf(host) === -1) {\r\n                return;\r\n            }\r\n\r\n            matchedEntity = entity;\r\n\r\n        });\r\n        \r\n        return matchedEntity;\r\n    }\r\n\r\n    /**\r\n     * Removes all accounts and related tokens from cache.\r\n     */\r\n    removeAllAccounts(): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            const entity = this.getAccount(cacheKey);\r\n            if (!entity) {\r\n                return;\r\n            }\r\n            this.removeAccount(cacheKey);\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    removeAccount(accountKey: string): boolean {\r\n        const account = this.getAccount(accountKey);\r\n        if (!account) {\r\n            throw ClientAuthError.createNoAccountFoundError();\r\n        }\r\n        return (this.removeAccountContext(account) && this.removeItem(accountKey, CacheSchemaType.ACCOUNT));\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given account is removed\r\n     * @param account\r\n     */\r\n    removeAccountContext(account: AccountEntity): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        const accountId = account.generateAccountId();\r\n\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            // don't parse any non-credential type cache entities\r\n            const credType = CredentialEntity.getCredentialType(cacheKey);\r\n            if (credType === Constants.NOT_DEFINED) {\r\n                return;\r\n            }\r\n\r\n            const cacheEntity = this.getSpecificCredential(cacheKey, credType);\r\n            if (!!cacheEntity && accountId === cacheEntity.generateAccountId()) {\r\n                this.removeCredential(cacheEntity);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * returns a boolean if the given credential is removed\r\n     * @param credential\r\n     */\r\n    removeCredential(credential: CredentialEntity): boolean {\r\n        const key = credential.generateCredentialKey();\r\n        return this.removeItem(key, CacheSchemaType.CREDENTIAL);\r\n    }\r\n\r\n    /**\r\n     * Removes all app metadata objects from cache.\r\n     */\r\n    removeAppMetadata(): boolean {\r\n        const allCacheKeys = this.getKeys();\r\n        allCacheKeys.forEach((cacheKey) => {\r\n            if (this.isAppMetadata(cacheKey)) {\r\n                this.removeItem(cacheKey, CacheSchemaType.APP_METADATA);\r\n            }\r\n        });\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the cached credentials into a cacherecord\r\n     * @param account\r\n     * @param clientId\r\n     * @param scopes\r\n     * @param environment\r\n     * @param authScheme\r\n     */\r\n    readCacheRecord(account: AccountInfo, clientId: string, scopes: ScopeSet, environment: string, authScheme: AuthenticationScheme): CacheRecord {\r\n        const cachedAccount = this.readAccountFromCache(account);\r\n        const cachedIdToken = this.readIdTokenFromCache(clientId, account);\r\n        const cachedAccessToken = this.readAccessTokenFromCache(clientId, account, scopes, authScheme);\r\n        const cachedRefreshToken = this.readRefreshTokenFromCache(clientId, account, false);\r\n        const cachedAppMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n\r\n        if (cachedAccount && cachedIdToken) {\r\n            cachedAccount.idTokenClaims = new AuthToken(cachedIdToken.secret, this.cryptoImpl).claims;\r\n        }\r\n\r\n        return {\r\n            account: cachedAccount,\r\n            idToken: cachedIdToken,\r\n            accessToken: cachedAccessToken,\r\n            refreshToken: cachedRefreshToken,\r\n            appMetadata: cachedAppMetadata,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccountEntity from cache\r\n     * @param account\r\n     */\r\n    readAccountFromCache(account: AccountInfo): AccountEntity | null {\r\n        const accountKey: string = AccountEntity.generateAccountCacheKey(account);\r\n        return this.getAccount(accountKey);\r\n    }\r\n\r\n    /**\r\n     * Retrieve IdTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param inputRealm\r\n     */\r\n    readIdTokenFromCache(clientId: string, account: AccountInfo): IdTokenEntity | null {\r\n        const idTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.ID_TOKEN,\r\n            clientId: clientId,\r\n            realm: account.tenantId,\r\n        };\r\n\r\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(idTokenFilter);\r\n        const idTokens = Object.keys(credentialCache.idTokens).map((key) => credentialCache.idTokens[key]);\r\n        const numIdTokens = idTokens.length;\r\n\r\n        if (numIdTokens < 1) {\r\n            return null;\r\n        } else if (numIdTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n\r\n        return idTokens[0] as IdTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AccessTokenEntity from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param scopes\r\n     * @param authScheme\r\n     */\r\n    readAccessTokenFromCache(clientId: string, account: AccountInfo, scopes: ScopeSet, authScheme: AuthenticationScheme): AccessTokenEntity | null {\r\n        const credentialType = (authScheme === AuthenticationScheme.POP) ? CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME : CredentialType.ACCESS_TOKEN;\r\n\r\n        const accessTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: credentialType,\r\n            clientId,\r\n            realm: account.tenantId,\r\n            target: scopes.printScopesLowerCase(),\r\n        };\r\n\r\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(accessTokenFilter);\r\n\r\n        const accessTokens = Object.keys(credentialCache.accessTokens).map((key) => credentialCache.accessTokens[key]);\r\n\r\n        const numAccessTokens = accessTokens.length;\r\n        if (numAccessTokens < 1) {\r\n            return null;\r\n        } else if (numAccessTokens > 1) {\r\n            throw ClientAuthError.createMultipleMatchingTokensInCacheError();\r\n        }\r\n\r\n        return accessTokens[0] as AccessTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Helper to retrieve the appropriate refresh token from cache\r\n     * @param clientId\r\n     * @param account\r\n     * @param familyRT\r\n     */\r\n    readRefreshTokenFromCache(clientId: string, account: AccountInfo, familyRT: boolean): RefreshTokenEntity | null {\r\n        const id = familyRT ? THE_FAMILY_ID : undefined;\r\n        const refreshTokenFilter: CredentialFilter = {\r\n            homeAccountId: account.homeAccountId,\r\n            environment: account.environment,\r\n            credentialType: CredentialType.REFRESH_TOKEN,\r\n            clientId: clientId,\r\n            familyId: id\r\n        };\r\n\r\n        const credentialCache: CredentialCache = this.getCredentialsFilteredBy(refreshTokenFilter);\r\n        const refreshTokens = Object.keys(credentialCache.refreshTokens).map((key) => credentialCache.refreshTokens[key]);\r\n\r\n        const numRefreshTokens = refreshTokens.length;\r\n        if (numRefreshTokens < 1) {\r\n            return null;\r\n        }\r\n        // address the else case after remove functions address environment aliases\r\n\r\n        return refreshTokens[0] as RefreshTokenEntity;\r\n    }\r\n\r\n    /**\r\n     * Retrieve AppMetadataEntity from cache\r\n     */\r\n    readAppMetadataFromCache(environment: string, clientId: string): AppMetadataEntity | null {\r\n        const appMetadataFilter: AppMetadataFilter = {\r\n            environment,\r\n            clientId,\r\n        };\r\n\r\n        const appMetadata: AppMetadataCache = this.getAppMetadataFilteredBy(appMetadataFilter);\r\n        const appMetadataEntries: AppMetadataEntity[] = Object.keys(appMetadata).map((key) => appMetadata[key]);\r\n\r\n        const numAppMetadata = appMetadataEntries.length;\r\n        if (numAppMetadata < 1) {\r\n            return null;\r\n        } else if (numAppMetadata > 1) {\r\n            throw ClientAuthError.createMultipleMatchingAppMetadataInCacheError();\r\n        }\r\n\r\n        return appMetadataEntries[0] as AppMetadataEntity;\r\n    }\r\n\r\n    /**\r\n     * Return the family_id value associated  with FOCI\r\n     * @param environment\r\n     * @param clientId\r\n     */\r\n    isAppMetadataFOCI(environment: string, clientId: string): boolean {\r\n        const appMetadata = this.readAppMetadataFromCache(environment, clientId);\r\n        return !!(appMetadata && appMetadata.familyId === THE_FAMILY_ID);\r\n    }\r\n\r\n    /**\r\n     * helper to match account ids\r\n     * @param value\r\n     * @param homeAccountId\r\n     */\r\n    private matchHomeAccountId(entity: AccountEntity | CredentialEntity, homeAccountId: string): boolean {\r\n        return !!(entity.homeAccountId && homeAccountId === entity.homeAccountId);\r\n    }\r\n\r\n    /**\r\n     * helper to match assertion\r\n     * @param value\r\n     * @param oboAssertion\r\n     */\r\n    private matchOboAssertion(entity: AccountEntity | CredentialEntity, oboAssertion: string): boolean {\r\n        return !!(entity.oboAssertion && oboAssertion === entity.oboAssertion);\r\n    }\r\n\r\n    /**\r\n     * helper to match environment\r\n     * @param value\r\n     * @param environment\r\n     */\r\n    private matchEnvironment(entity: AccountEntity | CredentialEntity | AppMetadataEntity, environment: string): boolean {\r\n        const cloudMetadata = this.getAuthorityMetadataByAlias(environment);\r\n        if (cloudMetadata && cloudMetadata.aliases.indexOf(entity.environment) > -1) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * helper to match credential type\r\n     * @param entity\r\n     * @param credentialType\r\n     */\r\n    private matchCredentialType(entity: CredentialEntity, credentialType: string): boolean {\r\n        return (entity.credentialType && credentialType.toLowerCase() === entity.credentialType.toLowerCase());\r\n    }\r\n\r\n    /**\r\n     * helper to match client ids\r\n     * @param entity\r\n     * @param clientId\r\n     */\r\n    private matchClientId(entity: CredentialEntity | AppMetadataEntity, clientId: string): boolean {\r\n        return !!(entity.clientId && clientId === entity.clientId);\r\n    }\r\n\r\n    /**\r\n     * helper to match family ids\r\n     * @param entity\r\n     * @param familyId\r\n     */\r\n    private matchFamilyId(entity: CredentialEntity | AppMetadataEntity, familyId: string): boolean {\r\n        return !!(entity.familyId && familyId === entity.familyId);\r\n    }\r\n\r\n    /**\r\n     * helper to match realm\r\n     * @param entity\r\n     * @param realm\r\n     */\r\n    private matchRealm(entity: AccountEntity | CredentialEntity, realm: string): boolean {\r\n        return !!(entity.realm && realm === entity.realm);\r\n    }\r\n\r\n    /**\r\n     * Returns true if the target scopes are a subset of the current entity's scopes, false otherwise.\r\n     * @param entity\r\n     * @param target\r\n     */\r\n    private matchTarget(entity: CredentialEntity, target: string): boolean {\r\n        const isNotAccessTokenCredential = (entity.credentialType !== CredentialType.ACCESS_TOKEN && entity.credentialType !== CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME);\r\n\r\n        if ( isNotAccessTokenCredential || !entity.target) {\r\n            return false;\r\n        }\r\n\r\n        const entityScopeSet: ScopeSet = ScopeSet.fromString(entity.target);\r\n        const requestTargetScopeSet: ScopeSet = ScopeSet.fromString(target);\r\n\r\n        if (!requestTargetScopeSet.containsOnlyOIDCScopes()) {\r\n            requestTargetScopeSet.removeOIDCScopes(); // ignore OIDC scopes\r\n        } else {\r\n            requestTargetScopeSet.removeScope(Constants.OFFLINE_ACCESS_SCOPE);\r\n        }\r\n        return entityScopeSet.containsScopeSet(requestTargetScopeSet);\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type appmetadata\r\n     * @param key\r\n     */\r\n    private isAppMetadata(key: string): boolean {\r\n        return key.indexOf(APP_METADATA) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns if a given cache entity is of the type authoritymetadata\r\n     * @param key\r\n     */\r\n    protected isAuthorityMetadata(key: string): boolean {\r\n        return key.indexOf(AUTHORITY_METADATA_CONSTANTS.CACHE_KEY) !== -1;\r\n    }\r\n\r\n    /**\r\n     * returns cache key used for cloud instance metadata\r\n     */\r\n    generateAuthorityMetadataCacheKey(authority: string): string {\r\n        return `${AUTHORITY_METADATA_CONSTANTS.CACHE_KEY}-${this.clientId}-${authority}`;\r\n    }\r\n\r\n    /**\r\n     * Returns the specific credential (IdToken/AccessToken/RefreshToken) from the cache\r\n     * @param key\r\n     * @param credType\r\n     */\r\n    private getSpecificCredential(key: string, credType: string): ValidCredentialType | null {\r\n        switch (credType) {\r\n            case CredentialType.ID_TOKEN: {\r\n                return this.getIdTokenCredential(key);\r\n            }\r\n            case CredentialType.ACCESS_TOKEN:\r\n            case CredentialType.ACCESS_TOKEN_WITH_AUTH_SCHEME: {\r\n                return this.getAccessTokenCredential(key);\r\n            }\r\n            case CredentialType.REFRESH_TOKEN: {\r\n                return this.getRefreshTokenCredential(key);\r\n            }\r\n            default:\r\n                return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper to convert serialized data to object\r\n     * @param obj\r\n     * @param json\r\n     */\r\n    static toObject<T>(obj: T, json: object): T {\r\n        for (const propertyName in json) {\r\n            obj[propertyName] = json[propertyName];\r\n        }\r\n        return obj;\r\n    }\r\n}\r\n\r\nexport class DefaultStorageClass extends CacheManager {\r\n    setAccount(): void {\r\n        const notImplErr = \"Storage interface - setAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccount(): AccountEntity {\r\n        const notImplErr = \"Storage interface - getAccount() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setIdTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getIdTokenCredential(): IdTokenEntity {\r\n        const notImplErr = \"Storage interface - getIdTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAccessTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAccessTokenCredential(): AccessTokenEntity {\r\n        const notImplErr = \"Storage interface - getAccessTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setRefreshTokenCredential(): void {\r\n        const notImplErr = \"Storage interface - setRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getRefreshTokenCredential(): RefreshTokenEntity {\r\n        const notImplErr = \"Storage interface - getRefreshTokenCredential() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAppMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAppMetadata(): AppMetadataEntity {\r\n        const notImplErr = \"Storage interface - getAppMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setServerTelemetry(): void {\r\n        const notImplErr = \"Storage interface - setServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getServerTelemetry(): ServerTelemetryEntity {\r\n        const notImplErr = \"Storage interface - getServerTelemetry() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setAuthorityMetadata(): void {\r\n        const notImplErr = \"Storage interface - setAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadata(): AuthorityMetadataEntity | null {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadata() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const notImplErr = \"Storage interface - getAuthorityMetadataKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    setThrottlingCache(): void {\r\n        const notImplErr = \"Storage interface - setThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getThrottlingCache(): ThrottlingEntity {\r\n        const notImplErr = \"Storage interface - getThrottlingCache() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    removeItem(): boolean {\r\n        const notImplErr = \"Storage interface - removeItem() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    containsKey(): boolean {\r\n        const notImplErr = \"Storage interface - containsKey() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    getKeys(): string[] {\r\n        const notImplErr = \"Storage interface - getKeys() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n    clear(): void {\r\n        const notImplErr = \"Storage interface - clear() has not been implemented for the cacheStorage interface.\";\r\n        throw AuthError.createUnexpectedError(notImplErr);\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}