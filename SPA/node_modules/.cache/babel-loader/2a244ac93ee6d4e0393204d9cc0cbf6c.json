{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\n/**\r\n * @class\r\n * Class for PageIterator\r\n */\n\nexport class PageIterator {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * Creates new instance for PageIterator\r\n   * @param {Client} client - The graph client instance\r\n   * @param {PageCollection} pageCollection - The page collection object\r\n   * @param {PageIteratorCallback} callBack - The callback function\r\n   * @param {GraphRequestOptions} requestOptions - The request options\r\n   * @returns An instance of a PageIterator\r\n   */\n  constructor(client, pageCollection, callback, requestOptions) {\n    this.client = client;\n    this.collection = pageCollection.value;\n    this.nextLink = pageCollection[\"@odata.nextLink\"];\n    this.deltaLink = pageCollection[\"@odata.deltaLink\"];\n    this.callback = callback;\n    this.complete = false;\n    this.requestOptions = requestOptions;\n  }\n  /**\r\n   * @private\r\n   * Iterates over a collection by enqueuing entries one by one and kicking the callback with the enqueued entry\r\n   * @returns A boolean indicating the continue flag to process next page\r\n   */\n\n\n  iterationHelper() {\n    if (this.collection === undefined) {\n      return false;\n    }\n\n    let advance = true;\n\n    while (advance && this.collection.length !== 0) {\n      const item = this.collection.shift();\n      advance = this.callback(item);\n    }\n\n    return advance;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * Helper to make a get request to fetch next page with nextLink url and update the page iterator instance with the returned response\r\n   * @returns A promise that resolves to a response data with next page collection\r\n   */\n\n\n  fetchAndUpdateNextPageData() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        let graphRequest = this.client.api(this.nextLink);\n\n        if (this.requestOptions) {\n          if (this.requestOptions.headers) {\n            graphRequest = graphRequest.headers(this.requestOptions.headers);\n          }\n\n          if (this.requestOptions.middlewareOptions) {\n            graphRequest = graphRequest.middlewareOptions(this.requestOptions.middlewareOptions);\n          }\n\n          if (this.requestOptions.options) {\n            graphRequest = graphRequest.options(this.requestOptions.options);\n          }\n        }\n\n        const response = yield graphRequest.get();\n        this.collection = response.value;\n        this.nextLink = response[\"@odata.nextLink\"];\n        this.deltaLink = response[\"@odata.deltaLink\"];\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * Getter to get the deltaLink in the current response\r\n   * @returns A deltaLink which is being used to make delta requests in future\r\n   */\n\n\n  getDeltaLink() {\n    return this.deltaLink;\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Iterates over the collection and kicks callback for each item on iteration. Fetches next set of data through nextLink and iterates over again\r\n   * This happens until the nextLink is drained out or the user responds with a red flag to continue from callback\r\n   * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy.\r\n   */\n\n\n  iterate() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        let advance = this.iterationHelper();\n\n        while (advance) {\n          if (this.nextLink !== undefined) {\n            yield this.fetchAndUpdateNextPageData();\n            advance = this.iterationHelper();\n          } else {\n            advance = false;\n          }\n        }\n\n        if (this.nextLink === undefined && this.collection.length === 0) {\n          this.complete = true;\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * To resume the iteration\r\n   * Note: This internally calls the iterate method, It's just for more readability.\r\n   * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy\r\n   */\n\n\n  resume() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        return this.iterate();\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * To get the completeness status of the iterator\r\n   * @returns Boolean indicating the completeness\r\n   */\n\n\n  isComplete() {\n    return this.complete;\n  }\n\n}","map":{"version":3,"sources":["../../../src/tasks/PageIterator.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\n/**\r\n * @class\r\n * Class for PageIterator\r\n */\r\nexport class PageIterator {\r\n    /**\r\n     * @public\r\n     * @constructor\r\n     * Creates new instance for PageIterator\r\n     * @param {Client} client - The graph client instance\r\n     * @param {PageCollection} pageCollection - The page collection object\r\n     * @param {PageIteratorCallback} callBack - The callback function\r\n     * @param {GraphRequestOptions} requestOptions - The request options\r\n     * @returns An instance of a PageIterator\r\n     */\r\n    constructor(client, pageCollection, callback, requestOptions) {\r\n        this.client = client;\r\n        this.collection = pageCollection.value;\r\n        this.nextLink = pageCollection[\"@odata.nextLink\"];\r\n        this.deltaLink = pageCollection[\"@odata.deltaLink\"];\r\n        this.callback = callback;\r\n        this.complete = false;\r\n        this.requestOptions = requestOptions;\r\n    }\r\n    /**\r\n     * @private\r\n     * Iterates over a collection by enqueuing entries one by one and kicking the callback with the enqueued entry\r\n     * @returns A boolean indicating the continue flag to process next page\r\n     */\r\n    iterationHelper() {\r\n        if (this.collection === undefined) {\r\n            return false;\r\n        }\r\n        let advance = true;\r\n        while (advance && this.collection.length !== 0) {\r\n            const item = this.collection.shift();\r\n            advance = this.callback(item);\r\n        }\r\n        return advance;\r\n    }\r\n    /**\r\n     * @private\r\n     * @async\r\n     * Helper to make a get request to fetch next page with nextLink url and update the page iterator instance with the returned response\r\n     * @returns A promise that resolves to a response data with next page collection\r\n     */\r\n    fetchAndUpdateNextPageData() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                let graphRequest = this.client.api(this.nextLink);\r\n                if (this.requestOptions) {\r\n                    if (this.requestOptions.headers) {\r\n                        graphRequest = graphRequest.headers(this.requestOptions.headers);\r\n                    }\r\n                    if (this.requestOptions.middlewareOptions) {\r\n                        graphRequest = graphRequest.middlewareOptions(this.requestOptions.middlewareOptions);\r\n                    }\r\n                    if (this.requestOptions.options) {\r\n                        graphRequest = graphRequest.options(this.requestOptions.options);\r\n                    }\r\n                }\r\n                const response = yield graphRequest.get();\r\n                this.collection = response.value;\r\n                this.nextLink = response[\"@odata.nextLink\"];\r\n                this.deltaLink = response[\"@odata.deltaLink\"];\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * Getter to get the deltaLink in the current response\r\n     * @returns A deltaLink which is being used to make delta requests in future\r\n     */\r\n    getDeltaLink() {\r\n        return this.deltaLink;\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Iterates over the collection and kicks callback for each item on iteration. Fetches next set of data through nextLink and iterates over again\r\n     * This happens until the nextLink is drained out or the user responds with a red flag to continue from callback\r\n     * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy.\r\n     */\r\n    iterate() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                let advance = this.iterationHelper();\r\n                while (advance) {\r\n                    if (this.nextLink !== undefined) {\r\n                        yield this.fetchAndUpdateNextPageData();\r\n                        advance = this.iterationHelper();\r\n                    }\r\n                    else {\r\n                        advance = false;\r\n                    }\r\n                }\r\n                if (this.nextLink === undefined && this.collection.length === 0) {\r\n                    this.complete = true;\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * To resume the iteration\r\n     * Note: This internally calls the iterate method, It's just for more readability.\r\n     * @returns A Promise that resolves to nothing on completion and throws error incase of any discrepancy\r\n     */\r\n    resume() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                return this.iterate();\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * To get the completeness status of the iterator\r\n     * @returns Boolean indicating the completeness\r\n     */\r\n    isComplete() {\r\n        return this.complete;\r\n    }\r\n}\r\n//# sourceMappingURL=PageIterator.js.map"]},"metadata":{},"sourceType":"module"}