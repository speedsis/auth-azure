{"ast":null,"code":"/*! @azure/msal-common v4.5.0 2021-07-22 */\n'use strict';\n\nimport { Constants as Constants$1 } from './Constants.js';\nimport { ClientAuthError as ClientAuthError$1 } from '../error/ClientAuthError.js';\nimport { StringUtils as StringUtils$1 } from './StringUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * Class which provides helpers for OAuth 2.0 protocol specific values\r\n */\n\nvar ProtocolUtils = function () {\n  function ProtocolUtils() {}\n  /**\r\n   * Appends user state with random guid, or returns random guid.\r\n   * @param userState\r\n   * @param randomGuid\r\n   */\n\n\n  ProtocolUtils.setRequestState = function (cryptoObj, userState, meta) {\n    var libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);\n    return !StringUtils$1.isEmpty(userState) ? \"\" + libraryState + Constants$1.RESOURCE_DELIM + userState : libraryState;\n  };\n  /**\r\n   * Generates the state value used by the common library.\r\n   * @param randomGuid\r\n   * @param cryptoObj\r\n   */\n\n\n  ProtocolUtils.generateLibraryState = function (cryptoObj, meta) {\n    if (!cryptoObj) {\n      throw ClientAuthError$1.createNoCryptoObjectError(\"generateLibraryState\");\n    } // Create a state object containing a unique id and the timestamp of the request creation\n\n\n    var stateObj = {\n      id: cryptoObj.createNewGuid()\n    };\n\n    if (meta) {\n      stateObj.meta = meta;\n    }\n\n    var stateString = JSON.stringify(stateObj);\n    return cryptoObj.base64Encode(stateString);\n  };\n  /**\r\n   * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\r\n   * @param state\r\n   * @param cryptoObj\r\n   */\n\n\n  ProtocolUtils.parseRequestState = function (cryptoObj, state) {\n    if (!cryptoObj) {\n      throw ClientAuthError$1.createNoCryptoObjectError(\"parseRequestState\");\n    }\n\n    if (StringUtils$1.isEmpty(state)) {\n      throw ClientAuthError$1.createInvalidStateError(state, \"Null, undefined or empty state\");\n    }\n\n    try {\n      // Split the state between library state and user passed state and decode them separately\n      var splitState = decodeURIComponent(state).split(Constants$1.RESOURCE_DELIM);\n      var libraryState = splitState[0];\n      var userState = splitState.length > 1 ? splitState.slice(1).join(Constants$1.RESOURCE_DELIM) : \"\";\n      var libraryStateString = cryptoObj.base64Decode(libraryState);\n      var libraryStateObj = JSON.parse(libraryStateString);\n      return {\n        userRequestState: !StringUtils$1.isEmpty(userState) ? userState : \"\",\n        libraryState: libraryStateObj\n      };\n    } catch (e) {\n      throw ClientAuthError$1.createInvalidStateError(state, e);\n    }\n  };\n\n  return ProtocolUtils;\n}();\n\nexport { ProtocolUtils };","map":{"version":3,"sources":["../../src/utils/ProtocolUtils.ts"],"names":["StringUtils","Constants","ClientAuthError"],"mappings":";;;;;;AAAA;;;;;AA8BA;;;;;AAGA,WAAA,aAAA,GAAA,CAiEC;;;;;;;;AA1DU,EAAA,aAAA,CAAA,eAAA,GAAP,UAAuB,SAAvB,EAA2C,SAA3C,EAA+D,IAA/D,EAA4F;AACxF,QAAM,YAAY,GAAG,aAAa,CAAC,oBAAd,CAAmC,SAAnC,EAA8C,IAA9C,CAArB;AACA,WAAO,CAACA,aAAW,CAAC,OAAZA,CAAoB,SAApBA,CAAD,GAAkC,KAAG,YAAH,GAAkBC,WAAS,CAAC,cAA5B,GAA6C,SAA/E,GAA6F,YAApG;AACH,GAHM;;;;;;;;AAUA,EAAA,aAAA,CAAA,oBAAA,GAAP,UAA4B,SAA5B,EAAgD,IAAhD,EAA6E;AACzE,QAAI,CAAC,SAAL,EAAgB;AACZ,YAAMC,iBAAe,CAAC,yBAAhBA,CAA0C,sBAA1CA,CAAN;AACH,KAHwE,C;;;AAMzE,QAAM,QAAQ,GAAuB;AACjC,MAAA,EAAE,EAAE,SAAS,CAAC,aAAV;AAD6B,KAArC;;AAIA,QAAI,IAAJ,EAAU;AACN,MAAA,QAAQ,CAAC,IAAT,GAAgB,IAAhB;AACH;;AAED,QAAM,WAAW,GAAG,IAAI,CAAC,SAAL,CAAe,QAAf,CAApB;AAEA,WAAO,SAAS,CAAC,YAAV,CAAuB,WAAvB,CAAP;AACH,GAjBM;;;;;;;;AAwBA,EAAA,aAAA,CAAA,iBAAA,GAAP,UAAyB,SAAzB,EAA6C,KAA7C,EAA0D;AACtD,QAAI,CAAC,SAAL,EAAgB;AACZ,YAAMA,iBAAe,CAAC,yBAAhBA,CAA0C,mBAA1CA,CAAN;AACH;;AAED,QAAIF,aAAW,CAAC,OAAZA,CAAoB,KAApBA,CAAJ,EAAgC;AAC5B,YAAME,iBAAe,CAAC,uBAAhBA,CAAwC,KAAxCA,EAA+C,gCAA/CA,CAAN;AACH;;AAED,QAAI;;AAEA,UAAM,UAAU,GAAG,kBAAkB,CAAC,KAAD,CAAlB,CAA0B,KAA1B,CAAgCD,WAAS,CAAC,cAA1C,CAAnB;AACA,UAAM,YAAY,GAAG,UAAU,CAAC,CAAD,CAA/B;AACA,UAAM,SAAS,GAAG,UAAU,CAAC,MAAX,GAAoB,CAApB,GAAwB,UAAU,CAAC,KAAX,CAAiB,CAAjB,EAAoB,IAApB,CAAyBA,WAAS,CAAC,cAAnC,CAAxB,GAA6E,EAA/F;AACA,UAAM,kBAAkB,GAAG,SAAS,CAAC,YAAV,CAAuB,YAAvB,CAA3B;AACA,UAAM,eAAe,GAAG,IAAI,CAAC,KAAL,CAAW,kBAAX,CAAxB;AACA,aAAO;AACH,QAAA,gBAAgB,EAAE,CAACD,aAAW,CAAC,OAAZA,CAAoB,SAApBA,CAAD,GAAkC,SAAlC,GAA8C,EAD7D;AAEH,QAAA,YAAY,EAAE;AAFX,OAAP;AAIH,KAXD,CAWE,OAAM,CAAN,EAAS;AACP,YAAME,iBAAe,CAAC,uBAAhBA,CAAwC,KAAxCA,EAA+C,CAA/CA,CAAN;AACH;AACJ,GAvBM;;AAwBX,SAAA,aAAA;AAAC,C","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { StringUtils } from \"./StringUtils\";\r\nimport { Constants } from \"./Constants\";\r\nimport { ICrypto } from \"../crypto/ICrypto\";\r\nimport { ClientAuthError } from \"../error/ClientAuthError\";\r\n\r\n/**\r\n * Type which defines the object that is stringified, encoded and sent in the state value.\r\n * Contains the following:\r\n * - id - unique identifier for this request\r\n * - ts - timestamp for the time the request was made. Used to ensure that token expiration is not calculated incorrectly.\r\n * - platformState - string value sent from the platform.\r\n */\r\nexport type LibraryStateObject = {\r\n    id: string,\r\n    meta?: Record<string, string>\r\n};\r\n\r\n/**\r\n * Type which defines the stringified and encoded object sent to the service in the authorize request.\r\n */\r\nexport type RequestStateObject = {\r\n    userRequestState: string,\r\n    libraryState: LibraryStateObject\r\n};\r\n\r\n/**\r\n * Class which provides helpers for OAuth 2.0 protocol specific values\r\n */\r\nexport class ProtocolUtils {\r\n\r\n    /**\r\n     * Appends user state with random guid, or returns random guid.\r\n     * @param userState \r\n     * @param randomGuid \r\n     */\r\n    static setRequestState(cryptoObj: ICrypto, userState?: string, meta?: Record<string, string>): string {\r\n        const libraryState = ProtocolUtils.generateLibraryState(cryptoObj, meta);\r\n        return !StringUtils.isEmpty(userState) ? `${libraryState}${Constants.RESOURCE_DELIM}${userState}` : libraryState;\r\n    }\r\n\r\n    /**\r\n     * Generates the state value used by the common library.\r\n     * @param randomGuid \r\n     * @param cryptoObj \r\n     */\r\n    static generateLibraryState(cryptoObj: ICrypto, meta?: Record<string, string>): string {\r\n        if (!cryptoObj) {\r\n            throw ClientAuthError.createNoCryptoObjectError(\"generateLibraryState\");\r\n        }\r\n\r\n        // Create a state object containing a unique id and the timestamp of the request creation\r\n        const stateObj: LibraryStateObject = {\r\n            id: cryptoObj.createNewGuid()\r\n        };\r\n\r\n        if (meta) {\r\n            stateObj.meta = meta;\r\n        }\r\n\r\n        const stateString = JSON.stringify(stateObj);\r\n\r\n        return cryptoObj.base64Encode(stateString);\r\n    }\r\n\r\n    /**\r\n     * Parses the state into the RequestStateObject, which contains the LibraryState info and the state passed by the user.\r\n     * @param state \r\n     * @param cryptoObj \r\n     */\r\n    static parseRequestState(cryptoObj: ICrypto, state: string): RequestStateObject {\r\n        if (!cryptoObj) {\r\n            throw ClientAuthError.createNoCryptoObjectError(\"parseRequestState\");\r\n        }\r\n\r\n        if (StringUtils.isEmpty(state)) {\r\n            throw ClientAuthError.createInvalidStateError(state, \"Null, undefined or empty state\");\r\n        }\r\n\r\n        try {\r\n            // Split the state between library state and user passed state and decode them separately\r\n            const splitState = decodeURIComponent(state).split(Constants.RESOURCE_DELIM);\r\n            const libraryState = splitState[0];\r\n            const userState = splitState.length > 1 ? splitState.slice(1).join(Constants.RESOURCE_DELIM) : \"\";\r\n            const libraryStateString = cryptoObj.base64Decode(libraryState);\r\n            const libraryStateObj = JSON.parse(libraryStateString) as LibraryStateObject;\r\n            return {\r\n                userRequestState: !StringUtils.isEmpty(userState) ? userState : \"\",\r\n                libraryState: libraryStateObj\r\n            };\r\n        } catch(e) {\r\n            throw ClientAuthError.createInvalidStateError(state, e);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}