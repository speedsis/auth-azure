{"ast":null,"code":"/*! @azure/msal-browser v2.16.0 2021-07-22 */\n'use strict';\n\nimport { __extends, __spread } from '../_virtual/_tslib.js';\nimport { DEFAULT_CRYPTO_IMPLEMENTATION, AccountEntity, CacheManager, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, ServerTelemetryEntity, AuthorityMetadataEntity, PersistentCacheKeys, ThrottlingEntity, Constants, StringUtils, ProtocolUtils, CcsCredentialType } from '@azure/msal-common';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { BrowserCacheLocation, TemporaryCacheKeys } from '../utils/BrowserConstants.js';\nimport { BrowserStorage } from './BrowserStorage.js';\nimport { MemoryStorage } from './MemoryStorage.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\n\nvar BrowserCacheManager = function (_super) {\n  __extends(BrowserCacheManager, _super);\n\n  function BrowserCacheManager(clientId, cacheConfig, cryptoImpl, logger) {\n    var _this = _super.call(this, clientId, cryptoImpl) || this; // Cookie life calculation (hours * minutes * seconds * ms)\n\n\n    _this.COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\n    _this.cacheConfig = cacheConfig;\n    _this.logger = logger;\n    _this.internalStorage = new MemoryStorage();\n    _this.browserStorage = _this.setupBrowserStorage(_this.cacheConfig.cacheLocation);\n    _this.temporaryCacheStorage = _this.setupTemporaryCacheStorage(_this.cacheConfig.cacheLocation); // Migrate any cache entries from older versions of MSAL.\n\n    _this.migrateCacheEntries();\n\n    return _this;\n  }\n  /**\r\n   * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupBrowserStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(cacheLocation);\n        } catch (e) {\n          this.logger.verbose(e);\n          break;\n        }\n\n    }\n\n    this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\n    return new MemoryStorage();\n  };\n  /**\r\n   *\r\n   * @param cacheLocation\r\n   */\n\n\n  BrowserCacheManager.prototype.setupTemporaryCacheStorage = function (cacheLocation) {\n    switch (cacheLocation) {\n      case BrowserCacheLocation.LocalStorage:\n      case BrowserCacheLocation.SessionStorage:\n        try {\n          // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\n          return new BrowserStorage(BrowserCacheLocation.SessionStorage);\n        } catch (e) {\n          this.logger.verbose(e);\n          return this.internalStorage;\n        }\n\n      case BrowserCacheLocation.MemoryStorage:\n      default:\n        return this.internalStorage;\n    }\n  };\n  /**\r\n   * Migrate all old cache entries to new schema. No rollback supported.\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntries = function () {\n    var _this = this;\n\n    var idTokenKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ID_TOKEN;\n    var clientInfoKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.CLIENT_INFO;\n    var errorKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR;\n    var errorDescKey = Constants.CACHE_PREFIX + \".\" + PersistentCacheKeys.ERROR_DESC;\n    var idTokenValue = this.browserStorage.getItem(idTokenKey);\n    var clientInfoValue = this.browserStorage.getItem(clientInfoKey);\n    var errorValue = this.browserStorage.getItem(errorKey);\n    var errorDescValue = this.browserStorage.getItem(errorDescKey);\n    var values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\n    var keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\n    keysToMigrate.forEach(function (cacheKey, index) {\n      return _this.migrateCacheEntry(cacheKey, values[index]);\n    });\n  };\n  /**\r\n   * Utility function to help with migration.\r\n   * @param newKey\r\n   * @param value\r\n   * @param storeAuthStateInCookie\r\n   */\n\n\n  BrowserCacheManager.prototype.migrateCacheEntry = function (newKey, value) {\n    if (value) {\n      this.setTemporaryCache(newKey, value, true);\n    }\n  };\n  /**\r\n   * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n   * @param input\r\n   */\n\n\n  BrowserCacheManager.prototype.validateAndParseJson = function (jsonValue) {\n    try {\n      var parsedJson = JSON.parse(jsonValue);\n      /**\r\n       * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n       * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n       * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n       *\r\n       */\n\n      return parsedJson && typeof parsedJson === \"object\" ? parsedJson : null;\n    } catch (error) {\n      return null;\n    }\n  };\n  /**\r\n   * fetches the entry from the browser storage based off the key\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getItem = function (key) {\n    return this.browserStorage.getItem(key);\n  };\n  /**\r\n   * sets the entry in the browser storage\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setItem = function (key, value) {\n    this.browserStorage.setItem(key, value);\n  };\n  /**\r\n   * fetch the account entity from the platform cache\r\n   * @param accountKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccount = function (accountKey) {\n    var account = this.getItem(accountKey);\n\n    if (!account) {\n      return null;\n    }\n\n    var parsedAccount = this.validateAndParseJson(account);\n\n    if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\n      return null;\n    }\n\n    return CacheManager.toObject(new AccountEntity(), parsedAccount);\n  };\n  /**\r\n   * set account entity in the platform cache\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccount = function (account) {\n    this.logger.trace(\"BrowserCacheManager.setAccount called\");\n    var key = account.generateAccountKey();\n    this.setItem(key, JSON.stringify(account));\n  };\n  /**\r\n   * generates idToken entity from a string\r\n   * @param idTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getIdTokenCredential = function (idTokenKey) {\n    var value = this.getItem(idTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedIdToken = this.validateAndParseJson(value);\n\n    if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\n      this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\n    return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\n  };\n  /**\r\n   * set IdToken credential to the platform cache\r\n   * @param idToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setIdTokenCredential = function (idToken) {\n    this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\n    var idTokenKey = idToken.generateCredentialKey();\n    this.setItem(idTokenKey, JSON.stringify(idToken));\n  };\n  /**\r\n   * generates accessToken entity from a string\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccessTokenCredential = function (accessTokenKey) {\n    var value = this.getItem(accessTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedAccessToken = this.validateAndParseJson(value);\n\n    if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\n      this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\n    return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\n  };\n  /**\r\n   * set accessToken credential to the platform cache\r\n   * @param accessToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setAccessTokenCredential = function (accessToken) {\n    this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\n    var accessTokenKey = accessToken.generateCredentialKey();\n    this.setItem(accessTokenKey, JSON.stringify(accessToken));\n  };\n  /**\r\n   * generates refreshToken entity from a string\r\n   * @param refreshTokenKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getRefreshTokenCredential = function (refreshTokenKey) {\n    var value = this.getItem(refreshTokenKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    var parsedRefreshToken = this.validateAndParseJson(value);\n\n    if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\n      this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\n    return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\n  };\n  /**\r\n   * set refreshToken credential to the platform cache\r\n   * @param refreshToken\r\n   */\n\n\n  BrowserCacheManager.prototype.setRefreshTokenCredential = function (refreshToken) {\n    this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\n    var refreshTokenKey = refreshToken.generateCredentialKey();\n    this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\n  };\n  /**\r\n   * fetch appMetadata entity from the platform cache\r\n   * @param appMetadataKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getAppMetadata = function (appMetadataKey) {\n    var value = this.getItem(appMetadataKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\n    return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\n  };\n  /**\r\n   * set appMetadata entity to the platform cache\r\n   * @param appMetadata\r\n   */\n\n\n  BrowserCacheManager.prototype.setAppMetadata = function (appMetadata) {\n    this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\n    var appMetadataKey = appMetadata.generateAppMetadataKey();\n    this.setItem(appMetadataKey, JSON.stringify(appMetadata));\n  };\n  /**\r\n   * fetch server telemetry entity from the platform cache\r\n   * @param serverTelemetryKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getServerTelemetry = function (serverTelemetryKey) {\n    var value = this.getItem(serverTelemetryKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\n    return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\n  };\n  /**\r\n   * set server telemetry entity to the platform cache\r\n   * @param serverTelemetryKey\r\n   * @param serverTelemetry\r\n   */\n\n\n  BrowserCacheManager.prototype.setServerTelemetry = function (serverTelemetryKey, serverTelemetry) {\n    this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\n    this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadata = function (key) {\n    var value = this.internalStorage.getItem(key);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\n      return null;\n    }\n\n    var parsedMetadata = this.validateAndParseJson(value);\n\n    if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\n      this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\n      return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\n    }\n\n    return null;\n  };\n  /**\r\n   *\r\n   */\n\n\n  BrowserCacheManager.prototype.getAuthorityMetadataKeys = function () {\n    var _this = this;\n\n    var allKeys = this.internalStorage.getKeys();\n    return allKeys.filter(function (key) {\n      return _this.isAuthorityMetadata(key);\n    });\n  };\n  /**\r\n   *\r\n   * @param entity\r\n   */\n\n\n  BrowserCacheManager.prototype.setAuthorityMetadata = function (key, entity) {\n    this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\n    this.internalStorage.setItem(key, JSON.stringify(entity));\n  };\n  /**\r\n   * Gets the active account\r\n   */\n\n\n  BrowserCacheManager.prototype.getActiveAccount = function () {\n    var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n    var activeAccountId = this.browserStorage.getItem(activeAccountIdKey);\n\n    if (!activeAccountId) {\n      return null;\n    }\n\n    return this.getAccountInfoByFilter({\n      localAccountId: activeAccountId\n    })[0] || null;\n  };\n  /**\r\n   * Sets the active account's localAccountId in cache\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.setActiveAccount = function (account) {\n    var activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\n\n    if (account) {\n      this.logger.verbose(\"setActiveAccount: Active account set\");\n      this.browserStorage.setItem(activeAccountIdKey, account.localAccountId);\n    } else {\n      this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\n      this.browserStorage.removeItem(activeAccountIdKey);\n    }\n  };\n  /**\r\n   * Gets a list of accounts that match all of the filters provided\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.getAccountInfoByFilter = function (accountFilter) {\n    var allAccounts = this.getAllAccounts();\n    return allAccounts.filter(function (accountObj) {\n      if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\n        return false;\n      }\n\n      if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\n        return false;\n      }\n\n      if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\n        return false;\n      }\n\n      if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\n        return false;\n      }\n\n      if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\n        return false;\n      }\n\n      return true;\n    });\n  };\n  /**\r\n   * fetch throttling entity from the platform cache\r\n   * @param throttlingCacheKey\r\n   */\n\n\n  BrowserCacheManager.prototype.getThrottlingCache = function (throttlingCacheKey) {\n    var value = this.getItem(throttlingCacheKey);\n\n    if (!value) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    var parsedThrottlingCache = this.validateAndParseJson(value);\n\n    if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\n      this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\n    return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\n  };\n  /**\r\n   * set throttling entity to the platform cache\r\n   * @param throttlingCacheKey\r\n   * @param throttlingCache\r\n   */\n\n\n  BrowserCacheManager.prototype.setThrottlingCache = function (throttlingCacheKey, throttlingCache) {\n    this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\n    this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\n  };\n  /**\r\n   * Gets cache item with given key.\r\n   * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.getTemporaryCache = function (cacheKey, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      var itemCookie = this.getItemCookie(key);\n\n      if (itemCookie) {\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\n        return itemCookie;\n      }\n    }\n\n    var value = this.temporaryCacheStorage.getItem(key);\n\n    if (!value) {\n      // If temp cache item not found in session/memory, check local storage for items set by old versions\n      if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\n        var item = this.browserStorage.getItem(key);\n\n        if (item) {\n          this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\n          return item;\n        }\n      }\n\n      this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\n      return null;\n    }\n\n    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\n    return value;\n  };\n  /**\r\n   * Sets the cache item with the key and value given.\r\n   * Stores in cookie if storeAuthStateInCookie is set to true.\r\n   * This can cause cookie overflow if used incorrectly.\r\n   * @param key\r\n   * @param value\r\n   */\n\n\n  BrowserCacheManager.prototype.setTemporaryCache = function (cacheKey, value, generateKey) {\n    var key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\n    this.temporaryCacheStorage.setItem(key, value);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\n      this.setItemCookie(key, value);\n    }\n  };\n  /**\r\n   * Removes the cache item with the given key.\r\n   * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.removeItem = function (key) {\n    this.browserStorage.removeItem(key);\n    this.temporaryCacheStorage.removeItem(key);\n\n    if (this.cacheConfig.storeAuthStateInCookie) {\n      this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\n      this.clearItemCookie(key);\n    }\n\n    return true;\n  };\n  /**\r\n   * Checks whether key is in cache.\r\n   * @param key\r\n   */\n\n\n  BrowserCacheManager.prototype.containsKey = function (key) {\n    return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\n  };\n  /**\r\n   * Gets all keys in window.\r\n   */\n\n\n  BrowserCacheManager.prototype.getKeys = function () {\n    return __spread(this.browserStorage.getKeys(), this.temporaryCacheStorage.getKeys());\n  };\n  /**\r\n   * Clears all cache entries created by MSAL (except tokens).\r\n   */\n\n\n  BrowserCacheManager.prototype.clear = function () {\n    var _this = this;\n\n    this.removeAllAccounts();\n    this.removeAppMetadata();\n    this.getKeys().forEach(function (cacheKey) {\n      // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\n      if ((_this.browserStorage.containsKey(cacheKey) || _this.temporaryCacheStorage.containsKey(cacheKey)) && (cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1 || cacheKey.indexOf(_this.clientId) !== -1)) {\n        _this.removeItem(cacheKey);\n      }\n    });\n    this.internalStorage.clear();\n  };\n  /**\r\n   * Add value to cookies\r\n   * @param cookieName\r\n   * @param cookieValue\r\n   * @param expires\r\n   */\n\n\n  BrowserCacheManager.prototype.setItemCookie = function (cookieName, cookieValue, expires) {\n    var cookieStr = encodeURIComponent(cookieName) + \"=\" + encodeURIComponent(cookieValue) + \";path=/;\";\n\n    if (expires) {\n      var expireTime = this.getCookieExpirationTime(expires);\n      cookieStr += \"expires=\" + expireTime + \";\";\n    }\n\n    if (this.cacheConfig.secureCookies) {\n      cookieStr += \"Secure;\";\n    }\n\n    document.cookie = cookieStr;\n  };\n  /**\r\n   * Get one item by key from cookies\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.getItemCookie = function (cookieName) {\n    var name = encodeURIComponent(cookieName) + \"=\";\n    var cookieList = document.cookie.split(\";\");\n\n    for (var i = 0; i < cookieList.length; i++) {\n      var cookie = cookieList[i];\n\n      while (cookie.charAt(0) === \" \") {\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(name) === 0) {\n        return decodeURIComponent(cookie.substring(name.length, cookie.length));\n      }\n    }\n\n    return \"\";\n  };\n  /**\r\n   * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n   */\n\n\n  BrowserCacheManager.prototype.clearMsalCookies = function () {\n    var _this = this;\n\n    var cookiePrefix = Constants.CACHE_PREFIX + \".\" + this.clientId;\n    var cookieList = document.cookie.split(\";\");\n    cookieList.forEach(function (cookie) {\n      while (cookie.charAt(0) === \" \") {\n        // eslint-disable-next-line no-param-reassign\n        cookie = cookie.substring(1);\n      }\n\n      if (cookie.indexOf(cookiePrefix) === 0) {\n        var cookieKey = cookie.split(\"=\")[0];\n\n        _this.clearItemCookie(cookieKey);\n      }\n    });\n  };\n  /**\r\n   * Clear an item in the cookies by key\r\n   * @param cookieName\r\n   */\n\n\n  BrowserCacheManager.prototype.clearItemCookie = function (cookieName) {\n    this.setItemCookie(cookieName, \"\", -1);\n  };\n  /**\r\n   * Get cookie expiration time\r\n   * @param cookieLifeDays\r\n   */\n\n\n  BrowserCacheManager.prototype.getCookieExpirationTime = function (cookieLifeDays) {\n    var today = new Date();\n    var expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\n    return expr.toUTCString();\n  };\n  /**\r\n   * Gets the cache object referenced by the browser\r\n   */\n\n\n  BrowserCacheManager.prototype.getCache = function () {\n    return this.browserStorage;\n  };\n  /**\r\n   * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n   */\n\n\n  BrowserCacheManager.prototype.setCache = function () {// sets nothing\n  };\n  /**\r\n   * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n   * @param key\r\n   * @param addInstanceId\r\n   */\n\n\n  BrowserCacheManager.prototype.generateCacheKey = function (key) {\n    var generatedKey = this.validateAndParseJson(key);\n\n    if (!generatedKey) {\n      if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\n        return key;\n      }\n\n      return Constants.CACHE_PREFIX + \".\" + this.clientId + \".\" + key;\n    }\n\n    return JSON.stringify(key);\n  };\n  /**\r\n   * Create authorityKey to cache authority\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateAuthorityKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.AUTHORITY + \".\" + stateId);\n  };\n  /**\r\n   * Create Nonce key to cache nonce\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.generateNonceKey = function (stateString) {\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.NONCE_IDTOKEN + \".\" + stateId);\n  };\n  /**\r\n   * Creates full cache key for the request state\r\n   * @param stateString State string for the request\r\n   */\n\n\n  BrowserCacheManager.prototype.generateStateKey = function (stateString) {\n    // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\n    var stateId = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString).libraryState.id;\n    return this.generateCacheKey(TemporaryCacheKeys.REQUEST_STATE + \".\" + stateId);\n  };\n  /**\r\n   * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedAuthority = function (cachedState) {\n    var stateCacheKey = this.generateStateKey(cachedState);\n    var state = this.getTemporaryCache(stateCacheKey);\n\n    if (!state) {\n      return null;\n    }\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    return this.getTemporaryCache(authorityCacheKey);\n  };\n  /**\r\n   * Updates account, authority, and state in cache\r\n   * @param serverAuthenticationRequest\r\n   * @param account\r\n   */\n\n\n  BrowserCacheManager.prototype.updateCacheEntries = function (state, nonce, authorityInstance, loginHint, account) {\n    this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\"); // Cache the request state\n\n    var stateCacheKey = this.generateStateKey(state);\n    this.setTemporaryCache(stateCacheKey, state, false); // Cache the nonce\n\n    var nonceCacheKey = this.generateNonceKey(state);\n    this.setTemporaryCache(nonceCacheKey, nonce, false); // Cache authorityKey\n\n    var authorityCacheKey = this.generateAuthorityKey(state);\n    this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\n\n    if (account) {\n      var ccsCredential = {\n        credential: account.homeAccountId,\n        type: CcsCredentialType.HOME_ACCOUNT_ID\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    } else if (!StringUtils.isEmpty(loginHint)) {\n      var ccsCredential = {\n        credential: loginHint,\n        type: CcsCredentialType.UPN\n      };\n      this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\n    }\n  };\n  /**\r\n   * Reset all temporary cache items\r\n   * @param state\r\n   */\n\n\n  BrowserCacheManager.prototype.resetRequestCache = function (state) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.resetRequestCache called\"); // check state and remove associated cache items\n\n    if (!StringUtils.isEmpty(state)) {\n      this.getKeys().forEach(function (key) {\n        if (key.indexOf(state) !== -1) {\n          _this.removeItem(key);\n        }\n      });\n    } // delete generic interactive request parameters\n\n\n    if (state) {\n      this.removeItem(this.generateStateKey(state));\n      this.removeItem(this.generateNonceKey(state));\n      this.removeItem(this.generateAuthorityKey(state));\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS_KEY));\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\n  };\n  /**\r\n   * Removes temporary cache for the provided state\r\n   * @param stateString\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByState = function (stateString) {\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\"); // Interaction is completed - remove interaction status.\n\n    if (stateString) {\n      var stateKey = this.generateStateKey(stateString);\n      var cachedState = this.temporaryCacheStorage.getItem(stateKey);\n      this.logger.infoPii(\"BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: \" + cachedState);\n      this.resetRequestCache(cachedState || \"\");\n    }\n\n    this.clearMsalCookies();\n  };\n  /**\r\n   * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n   * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n   * @param interactionType\r\n   */\n\n\n  BrowserCacheManager.prototype.cleanRequestByInteractionType = function (interactionType) {\n    var _this = this;\n\n    this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\"); // Loop through all keys to find state key\n\n    this.getKeys().forEach(function (key) {\n      // If this key is not the state key, move on\n      if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\n        return;\n      } // Retrieve state value, return if not a valid value\n\n\n      var stateValue = _this.temporaryCacheStorage.getItem(key);\n\n      if (!stateValue) {\n        return;\n      } // Extract state and ensure it matches given InteractionType, then clean request cache\n\n\n      var parsedState = BrowserProtocolUtils.extractBrowserRequestState(_this.cryptoImpl, stateValue);\n\n      if (parsedState && parsedState.interactionType === interactionType) {\n        _this.logger.infoPii(\"BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: \" + stateValue);\n\n        _this.resetRequestCache(stateValue);\n      }\n    });\n    this.clearMsalCookies();\n  };\n\n  BrowserCacheManager.prototype.cacheCodeRequest = function (authCodeRequest, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\n    var encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\n    this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\n  };\n  /**\r\n   * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n   */\n\n\n  BrowserCacheManager.prototype.getCachedRequest = function (state, browserCrypto) {\n    this.logger.trace(\"BrowserCacheManager.getCachedRequest called\"); // Get token request from cache and parse as TokenExchangeParameters.\n\n    var encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\n\n    if (!encodedTokenRequest) {\n      throw BrowserAuthError.createNoTokenRequestCacheError();\n    }\n\n    var parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest));\n\n    if (!parsedRequest) {\n      throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\n    }\n\n    this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS)); // Get cached authority and use if no authority is cached with request.\n\n    if (StringUtils.isEmpty(parsedRequest.authority)) {\n      var authorityCacheKey = this.generateAuthorityKey(state);\n      var cachedAuthority = this.getTemporaryCache(authorityCacheKey);\n\n      if (!cachedAuthority) {\n        throw BrowserAuthError.createNoCachedAuthorityError();\n      }\n\n      parsedRequest.authority = cachedAuthority;\n    }\n\n    return parsedRequest;\n  };\n\n  return BrowserCacheManager;\n}(CacheManager);\n\nvar DEFAULT_BROWSER_CACHE_MANAGER = function (clientId, logger) {\n  var cacheOptions = {\n    cacheLocation: BrowserCacheLocation.MemoryStorage,\n    storeAuthStateInCookie: false,\n    secureCookies: false\n  };\n  return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\n};\n\nexport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER };","map":{"version":3,"sources":["../../src/cache/BrowserCacheManager.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { Constants, PersistentCacheKeys, StringUtils, CommonAuthorizationCodeRequest, ICrypto, AccountEntity, IdTokenEntity, AccessTokenEntity, RefreshTokenEntity, AppMetadataEntity, CacheManager, ServerTelemetryEntity, ThrottlingEntity, ProtocolUtils, Logger, AuthorityMetadataEntity, DEFAULT_CRYPTO_IMPLEMENTATION, AccountInfo, CcsCredential, CcsCredentialType } from \"@azure/msal-common\";\r\nimport { CacheOptions } from \"../config/Configuration\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { BrowserCacheLocation, InteractionType, TemporaryCacheKeys } from \"../utils/BrowserConstants\";\r\nimport { BrowserStorage } from \"./BrowserStorage\";\r\nimport { MemoryStorage } from \"./MemoryStorage\";\r\nimport { IWindowStorage } from \"./IWindowStorage\";\r\nimport { BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\r\n\r\n/**\r\n * This class implements the cache storage interface for MSAL through browser local or session storage.\r\n * Cookies are only used if storeAuthStateInCookie is true, and are only used for\r\n * parameters such as state and nonce, generally.\r\n */\r\nexport class BrowserCacheManager extends CacheManager {\r\n\r\n    // Cache configuration, either set by user or default values.\r\n    private cacheConfig: Required<CacheOptions>;\r\n    // Window storage object (either local or sessionStorage)\r\n    private browserStorage: IWindowStorage;\r\n    // Internal in-memory storage object used for data used by msal that does not need to persist across page loads\r\n    private internalStorage: MemoryStorage;\r\n    // Temporary cache\r\n    private temporaryCacheStorage: IWindowStorage;\r\n    // Client id of application. Used in cache keys to partition cache correctly in the case of multiple instances of MSAL.\r\n    private logger: Logger;\r\n\r\n    // Cookie life calculation (hours * minutes * seconds * ms)\r\n    private readonly COOKIE_LIFE_MULTIPLIER = 24 * 60 * 60 * 1000;\r\n\r\n    constructor(clientId: string, cacheConfig: Required<CacheOptions>, cryptoImpl: ICrypto, logger: Logger) {\r\n        super(clientId, cryptoImpl);\r\n\r\n        this.cacheConfig = cacheConfig;\r\n        this.logger = logger;\r\n\r\n        this.internalStorage = new MemoryStorage();\r\n        this.browserStorage = this.setupBrowserStorage(this.cacheConfig.cacheLocation);\r\n        this.temporaryCacheStorage = this.setupTemporaryCacheStorage(this.cacheConfig.cacheLocation);\r\n\r\n        // Migrate any cache entries from older versions of MSAL.\r\n        this.migrateCacheEntries();\r\n    }\r\n\r\n    /**\r\n     * Returns a window storage class implementing the IWindowStorage interface that corresponds to the configured cacheLocation.\r\n     * @param cacheLocation\r\n     */\r\n    private setupBrowserStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                    return new BrowserStorage(cacheLocation);\r\n                } catch (e) {\r\n                    this.logger.verbose(e);\r\n                    break;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                break;\r\n        }\r\n        this.cacheConfig.cacheLocation = BrowserCacheLocation.MemoryStorage;\r\n        return new MemoryStorage();\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param cacheLocation\r\n     */\r\n    private setupTemporaryCacheStorage(cacheLocation: BrowserCacheLocation | string): IWindowStorage {\r\n        switch (cacheLocation) {\r\n            case BrowserCacheLocation.LocalStorage:\r\n            case BrowserCacheLocation.SessionStorage:\r\n                try {\r\n                    // Temporary cache items will always be stored in session storage to mitigate problems caused by multiple tabs\r\n                    return new BrowserStorage(BrowserCacheLocation.SessionStorage);\r\n                } catch (e) {\r\n                    this.logger.verbose(e);\r\n                    return this.internalStorage;\r\n                }\r\n            case BrowserCacheLocation.MemoryStorage:\r\n            default:\r\n                return this.internalStorage;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Migrate all old cache entries to new schema. No rollback supported.\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    private migrateCacheEntries(): void {\r\n        const idTokenKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ID_TOKEN}`;\r\n        const clientInfoKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.CLIENT_INFO}`;\r\n        const errorKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR}`;\r\n        const errorDescKey = `${Constants.CACHE_PREFIX}.${PersistentCacheKeys.ERROR_DESC}`;\r\n\r\n        const idTokenValue = this.browserStorage.getItem(idTokenKey);\r\n        const clientInfoValue = this.browserStorage.getItem(clientInfoKey);\r\n        const errorValue = this.browserStorage.getItem(errorKey);\r\n        const errorDescValue = this.browserStorage.getItem(errorDescKey);\r\n\r\n        const values = [idTokenValue, clientInfoValue, errorValue, errorDescValue];\r\n        const keysToMigrate = [PersistentCacheKeys.ID_TOKEN, PersistentCacheKeys.CLIENT_INFO, PersistentCacheKeys.ERROR, PersistentCacheKeys.ERROR_DESC];\r\n\r\n        keysToMigrate.forEach((cacheKey:string, index: number) => this.migrateCacheEntry(cacheKey, values[index]));\r\n    }\r\n\r\n    /**\r\n     * Utility function to help with migration.\r\n     * @param newKey\r\n     * @param value\r\n     * @param storeAuthStateInCookie\r\n     */\r\n    private migrateCacheEntry(newKey: string, value: string|null): void {\r\n        if (value) {\r\n            this.setTemporaryCache(newKey, value, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses passed value as JSON object, JSON.parse() will throw an error.\r\n     * @param input\r\n     */\r\n    private validateAndParseJson(jsonValue: string): object | null {\r\n        try {\r\n            const parsedJson = JSON.parse(jsonValue);\r\n            /**\r\n             * There are edge cases in which JSON.parse will successfully parse a non-valid JSON object\r\n             * (e.g. JSON.parse will parse an escaped string into an unescaped string), so adding a type check\r\n             * of the parsed value is necessary in order to be certain that the string represents a valid JSON object.\r\n             *\r\n             */\r\n            return (parsedJson && typeof parsedJson === \"object\") ? parsedJson : null;\r\n        } catch (error) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * fetches the entry from the browser storage based off the key\r\n     * @param key\r\n     */\r\n    getItem(key: string): string | null {\r\n        return this.browserStorage.getItem(key);\r\n    }\r\n\r\n    /**\r\n     * sets the entry in the browser storage\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setItem(key: string, value: string): void {\r\n        this.browserStorage.setItem(key, value);\r\n    }\r\n\r\n    /**\r\n     * fetch the account entity from the platform cache\r\n     * @param accountKey\r\n     */\r\n    getAccount(accountKey: string): AccountEntity | null {\r\n        const account = this.getItem(accountKey);\r\n        if (!account) {\r\n            return null;\r\n        }\r\n\r\n        const parsedAccount = this.validateAndParseJson(account);\r\n        if (!parsedAccount || !AccountEntity.isAccountEntity(parsedAccount)) {\r\n            return null;\r\n        }\r\n\r\n        return CacheManager.toObject<AccountEntity>(new AccountEntity(), parsedAccount);\r\n    }\r\n\r\n    /**\r\n     * set account entity in the platform cache\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setAccount(account: AccountEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAccount called\");\r\n        const key = account.generateAccountKey();\r\n        this.setItem(key, JSON.stringify(account));\r\n    }\r\n\r\n    /**\r\n     * generates idToken entity from a string\r\n     * @param idTokenKey\r\n     */\r\n    getIdTokenCredential(idTokenKey: string): IdTokenEntity | null {\r\n        const value = this.getItem(idTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedIdToken = this.validateAndParseJson(value);\r\n        if (!parsedIdToken || !IdTokenEntity.isIdTokenEntity(parsedIdToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getIdTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new IdTokenEntity(), parsedIdToken);\r\n    }\r\n\r\n    /**\r\n     * set IdToken credential to the platform cache\r\n     * @param idToken\r\n     */\r\n    setIdTokenCredential(idToken: IdTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setIdTokenCredential called\");\r\n        const idTokenKey = idToken.generateCredentialKey();\r\n        this.setItem(idTokenKey, JSON.stringify(idToken));\r\n    }\r\n\r\n    /**\r\n     * generates accessToken entity from a string\r\n     * @param key\r\n     */\r\n    getAccessTokenCredential(accessTokenKey: string): AccessTokenEntity | null {\r\n        const value = this.getItem(accessTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedAccessToken = this.validateAndParseJson(value);\r\n        if (!parsedAccessToken || !AccessTokenEntity.isAccessTokenEntity(parsedAccessToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAccessTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new AccessTokenEntity(), parsedAccessToken);\r\n    }\r\n\r\n    /**\r\n     * set accessToken credential to the platform cache\r\n     * @param accessToken\r\n     */\r\n    setAccessTokenCredential(accessToken: AccessTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAccessTokenCredential called\");\r\n        const accessTokenKey = accessToken.generateCredentialKey();\r\n        this.setItem(accessTokenKey, JSON.stringify(accessToken));\r\n    }\r\n\r\n    /**\r\n     * generates refreshToken entity from a string\r\n     * @param refreshTokenKey\r\n     */\r\n    getRefreshTokenCredential(refreshTokenKey: string): RefreshTokenEntity | null {\r\n        const value = this.getItem(refreshTokenKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedRefreshToken = this.validateAndParseJson(value);\r\n        if (!parsedRefreshToken || !RefreshTokenEntity.isRefreshTokenEntity(parsedRefreshToken)) {\r\n            this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getRefreshTokenCredential: cache hit\");\r\n        return CacheManager.toObject(new RefreshTokenEntity(), parsedRefreshToken);\r\n    }\r\n\r\n    /**\r\n     * set refreshToken credential to the platform cache\r\n     * @param refreshToken\r\n     */\r\n    setRefreshTokenCredential(refreshToken: RefreshTokenEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setRefreshTokenCredential called\");\r\n        const refreshTokenKey = refreshToken.generateCredentialKey();\r\n        this.setItem(refreshTokenKey, JSON.stringify(refreshToken));\r\n    }\r\n\r\n    /**\r\n     * fetch appMetadata entity from the platform cache\r\n     * @param appMetadataKey\r\n     */\r\n    getAppMetadata(appMetadataKey: string): AppMetadataEntity | null {\r\n        const value = this.getItem(appMetadataKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !AppMetadataEntity.isAppMetadataEntity(appMetadataKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAppMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getAppMetadata: cache hit\");\r\n        return CacheManager.toObject(new AppMetadataEntity(), parsedMetadata);\r\n    }\r\n\r\n    /**\r\n     * set appMetadata entity to the platform cache\r\n     * @param appMetadata\r\n     */\r\n    setAppMetadata(appMetadata: AppMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAppMetadata called\");\r\n        const appMetadataKey = appMetadata.generateAppMetadataKey();\r\n        this.setItem(appMetadataKey, JSON.stringify(appMetadata));\r\n    }\r\n\r\n    /**\r\n     * fetch server telemetry entity from the platform cache\r\n     * @param serverTelemetryKey\r\n     */\r\n    getServerTelemetry(serverTelemetryKey: string): ServerTelemetryEntity | null {\r\n        const value = this.getItem(serverTelemetryKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (!parsedMetadata || !ServerTelemetryEntity.isServerTelemetryEntity(serverTelemetryKey, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getServerTelemetry: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getServerTelemetry: cache hit\");\r\n        return CacheManager.toObject(new ServerTelemetryEntity(), parsedMetadata);\r\n    }\r\n\r\n    /**\r\n     * set server telemetry entity to the platform cache\r\n     * @param serverTelemetryKey\r\n     * @param serverTelemetry\r\n     */\r\n    setServerTelemetry(serverTelemetryKey: string, serverTelemetry: ServerTelemetryEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setServerTelemetry called\");\r\n        this.setItem(serverTelemetryKey, JSON.stringify(serverTelemetry));\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadata(key: string) : AuthorityMetadataEntity | null {\r\n        const value = this.internalStorage.getItem(key);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: called, no cache hit\");\r\n            return null;\r\n        }\r\n        const parsedMetadata = this.validateAndParseJson(value);\r\n        if (parsedMetadata && AuthorityMetadataEntity.isAuthorityMetadataEntity(key, parsedMetadata)) {\r\n            this.logger.trace(\"BrowserCacheManager.getAuthorityMetadata: cache hit\");\r\n            return CacheManager.toObject(new AuthorityMetadataEntity(), parsedMetadata);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     *\r\n     */\r\n    getAuthorityMetadataKeys(): Array<string> {\r\n        const allKeys = this.internalStorage.getKeys();\r\n        return allKeys.filter((key) => {\r\n            return this.isAuthorityMetadata(key);\r\n        });\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param entity\r\n     */\r\n    setAuthorityMetadata(key: string, entity: AuthorityMetadataEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setAuthorityMetadata called\");\r\n        this.internalStorage.setItem(key, JSON.stringify(entity));\r\n    }\r\n\r\n    /**\r\n     * Gets the active account\r\n     */\r\n    getActiveAccount(): AccountInfo | null {\r\n        const activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        const activeAccountId = this.browserStorage.getItem(activeAccountIdKey);\r\n        if (!activeAccountId) {\r\n            return null;\r\n        }\r\n        return this.getAccountInfoByFilter({localAccountId: activeAccountId})[0] || null;\r\n    }\r\n\r\n    /**\r\n     * Sets the active account's localAccountId in cache\r\n     * @param account \r\n     */\r\n    setActiveAccount(account: AccountInfo | null): void {\r\n        const activeAccountIdKey = this.generateCacheKey(PersistentCacheKeys.ACTIVE_ACCOUNT);\r\n        if (account) {\r\n            this.logger.verbose(\"setActiveAccount: Active account set\");\r\n            this.browserStorage.setItem(activeAccountIdKey, account.localAccountId);\r\n        } else {\r\n            this.logger.verbose(\"setActiveAccount: No account passed, active account not set\");\r\n            this.browserStorage.removeItem(activeAccountIdKey);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a list of accounts that match all of the filters provided\r\n     * @param account \r\n     */\r\n    getAccountInfoByFilter(accountFilter: Partial<Omit<AccountInfo, \"idTokenClaims\"|\"name\">>): AccountInfo[] {\r\n        const allAccounts = this.getAllAccounts();\r\n        return allAccounts.filter((accountObj) => {\r\n            if (accountFilter.username && accountFilter.username.toLowerCase() !== accountObj.username.toLowerCase()) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.homeAccountId && accountFilter.homeAccountId !== accountObj.homeAccountId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.localAccountId && accountFilter.localAccountId !== accountObj.localAccountId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.tenantId && accountFilter.tenantId !== accountObj.tenantId) {\r\n                return false;\r\n            }\r\n\r\n            if (accountFilter.environment && accountFilter.environment !== accountObj.environment) {\r\n                return false;\r\n            }\r\n            \r\n            return true;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * fetch throttling entity from the platform cache\r\n     * @param throttlingCacheKey\r\n     */\r\n    getThrottlingCache(throttlingCacheKey: string): ThrottlingEntity | null {\r\n        const value = this.getItem(throttlingCacheKey);\r\n        if (!value) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        const parsedThrottlingCache = this.validateAndParseJson(value);\r\n        if (!parsedThrottlingCache || !ThrottlingEntity.isThrottlingEntity(throttlingCacheKey, parsedThrottlingCache)) {\r\n            this.logger.trace(\"BrowserCacheManager.getThrottlingCache: called, no cache hit\");\r\n            return null;\r\n        }\r\n\r\n        this.logger.trace(\"BrowserCacheManager.getThrottlingCache: cache hit\");\r\n        return CacheManager.toObject(new ThrottlingEntity(), parsedThrottlingCache);\r\n    }\r\n\r\n    /**\r\n     * set throttling entity to the platform cache\r\n     * @param throttlingCacheKey\r\n     * @param throttlingCache\r\n     */\r\n    setThrottlingCache(throttlingCacheKey: string, throttlingCache: ThrottlingEntity): void {\r\n        this.logger.trace(\"BrowserCacheManager.setThrottlingCache called\");\r\n        this.setItem(throttlingCacheKey, JSON.stringify(throttlingCache));\r\n    }\r\n\r\n    /**\r\n     * Gets cache item with given key.\r\n     * Will retrieve from cookies if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    getTemporaryCache(cacheKey: string, generateKey?: boolean): string | null {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            const itemCookie = this.getItemCookie(key);\r\n            if (itemCookie) {\r\n                this.logger.trace(\"BrowserCacheManager.getTemporaryCache: storeAuthStateInCookies set to true, retrieving from cookies\");\r\n                return itemCookie;\r\n            }\r\n        }\r\n\r\n        const value = this.temporaryCacheStorage.getItem(key);\r\n        if (!value) {\r\n            // If temp cache item not found in session/memory, check local storage for items set by old versions\r\n            if (this.cacheConfig.cacheLocation === BrowserCacheLocation.LocalStorage) {\r\n                const item = this.browserStorage.getItem(key);\r\n                if (item) {\r\n                    this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item found in local storage\");\r\n                    return item;\r\n                }\r\n            }\r\n            this.logger.trace(\"BrowserCacheManager.getTemporaryCache: No cache item found in local storage\");\r\n            return null;\r\n        }\r\n        this.logger.trace(\"BrowserCacheManager.getTemporaryCache: Temporary cache item returned\");\r\n        return value;\r\n    }\r\n\r\n    /**\r\n     * Sets the cache item with the key and value given.\r\n     * Stores in cookie if storeAuthStateInCookie is set to true.\r\n     * This can cause cookie overflow if used incorrectly.\r\n     * @param key\r\n     * @param value\r\n     */\r\n    setTemporaryCache(cacheKey: string, value: string, generateKey?: boolean): void {\r\n        const key = generateKey ? this.generateCacheKey(cacheKey) : cacheKey;\r\n\r\n        this.temporaryCacheStorage.setItem(key, value);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.setTemporaryCache: storeAuthStateInCookie set to true, setting item cookie\");\r\n            this.setItemCookie(key, value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes the cache item with the given key.\r\n     * Will also clear the cookie item if storeAuthStateInCookie is set to true.\r\n     * @param key\r\n     */\r\n    removeItem(key: string): boolean {\r\n        this.browserStorage.removeItem(key);\r\n        this.temporaryCacheStorage.removeItem(key);\r\n        if (this.cacheConfig.storeAuthStateInCookie) {\r\n            this.logger.trace(\"BrowserCacheManager.removeItem: storeAuthStateInCookie is true, clearing item cookie\");\r\n            this.clearItemCookie(key);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks whether key is in cache.\r\n     * @param key\r\n     */\r\n    containsKey(key: string): boolean {\r\n        return this.browserStorage.containsKey(key) || this.temporaryCacheStorage.containsKey(key);\r\n    }\r\n\r\n    /**\r\n     * Gets all keys in window.\r\n     */\r\n    getKeys(): string[] {\r\n        return [\r\n            ...this.browserStorage.getKeys(),\r\n            ...this.temporaryCacheStorage.getKeys()\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Clears all cache entries created by MSAL (except tokens).\r\n     */\r\n    clear(): void {\r\n        this.removeAllAccounts();\r\n        this.removeAppMetadata();\r\n        this.getKeys().forEach((cacheKey: string) => {\r\n            // Check if key contains msal prefix; For now, we are clearing all the cache items created by MSAL.js\r\n            if ((this.browserStorage.containsKey(cacheKey) || this.temporaryCacheStorage.containsKey(cacheKey)) && ((cacheKey.indexOf(Constants.CACHE_PREFIX) !== -1) || (cacheKey.indexOf(this.clientId) !== -1))) {\r\n                this.removeItem(cacheKey);\r\n            }\r\n        });\r\n\r\n        this.internalStorage.clear();\r\n    }\r\n\r\n    /**\r\n     * Add value to cookies\r\n     * @param cookieName\r\n     * @param cookieValue\r\n     * @param expires\r\n     */\r\n    setItemCookie(cookieName: string, cookieValue: string, expires?: number): void {\r\n        let cookieStr = `${encodeURIComponent(cookieName)}=${encodeURIComponent(cookieValue)};path=/;`;\r\n        if (expires) {\r\n            const expireTime = this.getCookieExpirationTime(expires);\r\n            cookieStr += `expires=${expireTime};`;\r\n        }\r\n\r\n        if (this.cacheConfig.secureCookies) {\r\n            cookieStr += \"Secure;\";\r\n        }\r\n        \r\n        document.cookie = cookieStr;\r\n    }\r\n\r\n    /**\r\n     * Get one item by key from cookies\r\n     * @param cookieName\r\n     */\r\n    getItemCookie(cookieName: string): string {\r\n        const name = `${encodeURIComponent(cookieName)}=`;\r\n        const cookieList = document.cookie.split(\";\");\r\n        for (let i: number = 0; i < cookieList.length; i++) {\r\n            let cookie = cookieList[i];\r\n            while (cookie.charAt(0) === \" \") {\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(name) === 0) {\r\n                return decodeURIComponent(cookie.substring(name.length, cookie.length));\r\n            }\r\n        }\r\n        return \"\";\r\n    }\r\n\r\n    /**\r\n     * Clear all msal-related cookies currently set in the browser. Should only be used to clear temporary cache items.\r\n     */\r\n    clearMsalCookies(): void {\r\n        const cookiePrefix = `${Constants.CACHE_PREFIX}.${this.clientId}`;\r\n        const cookieList = document.cookie.split(\";\");\r\n        cookieList.forEach((cookie: string): void => {\r\n            while (cookie.charAt(0) === \" \") {\r\n                // eslint-disable-next-line no-param-reassign\r\n                cookie = cookie.substring(1);\r\n            }\r\n            if (cookie.indexOf(cookiePrefix) === 0) {\r\n                const cookieKey = cookie.split(\"=\")[0];\r\n                this.clearItemCookie(cookieKey);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Clear an item in the cookies by key\r\n     * @param cookieName\r\n     */\r\n    clearItemCookie(cookieName: string): void {\r\n        this.setItemCookie(cookieName, \"\", -1);\r\n    }\r\n\r\n    /**\r\n     * Get cookie expiration time\r\n     * @param cookieLifeDays\r\n     */\r\n    getCookieExpirationTime(cookieLifeDays: number): string {\r\n        const today = new Date();\r\n        const expr = new Date(today.getTime() + cookieLifeDays * this.COOKIE_LIFE_MULTIPLIER);\r\n        return expr.toUTCString();\r\n    }\r\n\r\n    /**\r\n     * Gets the cache object referenced by the browser\r\n     */\r\n    getCache(): object {\r\n        return this.browserStorage;\r\n    }\r\n\r\n    /**\r\n     * interface compat, we cannot overwrite browser cache; Functionality is supported by individual entities in browser\r\n     */\r\n    setCache(): void {\r\n        // sets nothing\r\n    }\r\n\r\n    /**\r\n     * Prepend msal.<client-id> to each key; Skip for any JSON object as Key (defined schemas do not need the key appended: AccessToken Keys or the upcoming schema)\r\n     * @param key\r\n     * @param addInstanceId\r\n     */\r\n    generateCacheKey(key: string): string {\r\n        const generatedKey = this.validateAndParseJson(key);\r\n        if (!generatedKey) {\r\n            if (StringUtils.startsWith(key, Constants.CACHE_PREFIX) || StringUtils.startsWith(key, PersistentCacheKeys.ADAL_ID_TOKEN)) {\r\n                return key;\r\n            }\r\n            return `${Constants.CACHE_PREFIX}.${this.clientId}.${key}`;\r\n        }\r\n\r\n        return JSON.stringify(key);\r\n    }\r\n\r\n    /**\r\n     * Create authorityKey to cache authority\r\n     * @param state\r\n     */\r\n    generateAuthorityKey(stateString: string): string {\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.AUTHORITY}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Create Nonce key to cache nonce\r\n     * @param state\r\n     */\r\n    generateNonceKey(stateString: string): string {\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.NONCE_IDTOKEN}.${stateId}`);\r\n    }\r\n\r\n    /**\r\n     * Creates full cache key for the request state\r\n     * @param stateString State string for the request\r\n     */\r\n    generateStateKey(stateString: string): string {\r\n        // Use the library state id to key temp storage for uniqueness for multiple concurrent requests\r\n        const {\r\n            libraryState: {\r\n                id: stateId\r\n            }\r\n        } = ProtocolUtils.parseRequestState(this.cryptoImpl, stateString);\r\n        return this.generateCacheKey(`${TemporaryCacheKeys.REQUEST_STATE}.${stateId}`);\r\n    } \r\n\r\n    /**\r\n     * Gets the cached authority based on the cached state. Returns empty if no cached state found.\r\n     */\r\n    getCachedAuthority(cachedState: string): string | null {\r\n        const stateCacheKey = this.generateStateKey(cachedState);\r\n        const state = this.getTemporaryCache(stateCacheKey);\r\n        if (!state) {\r\n            return null;\r\n        }\r\n\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        return this.getTemporaryCache(authorityCacheKey);\r\n    }\r\n\r\n    /**\r\n     * Updates account, authority, and state in cache\r\n     * @param serverAuthenticationRequest\r\n     * @param account\r\n     */\r\n    updateCacheEntries(state: string, nonce: string, authorityInstance: string, loginHint: string, account: AccountInfo|null): void {\r\n        this.logger.trace(\"BrowserCacheManager.updateCacheEntries called\");\r\n        // Cache the request state\r\n        const stateCacheKey = this.generateStateKey(state);\r\n        this.setTemporaryCache(stateCacheKey, state, false);\r\n\r\n        // Cache the nonce\r\n        const nonceCacheKey = this.generateNonceKey(state);\r\n        this.setTemporaryCache(nonceCacheKey, nonce, false);\r\n\r\n        // Cache authorityKey\r\n        const authorityCacheKey = this.generateAuthorityKey(state);\r\n        this.setTemporaryCache(authorityCacheKey, authorityInstance, false);\r\n\r\n        if (account) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: account.homeAccountId,\r\n                type: CcsCredentialType.HOME_ACCOUNT_ID\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        } else if (!StringUtils.isEmpty(loginHint)) {\r\n            const ccsCredential: CcsCredential = {\r\n                credential: loginHint,\r\n                type: CcsCredentialType.UPN\r\n            };\r\n            this.setTemporaryCache(TemporaryCacheKeys.CCS_CREDENTIAL, JSON.stringify(ccsCredential), true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset all temporary cache items\r\n     * @param state\r\n     */\r\n    resetRequestCache(state: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.resetRequestCache called\");\r\n        // check state and remove associated cache items\r\n        if (!StringUtils.isEmpty(state)) {\r\n            this.getKeys().forEach(key => {\r\n                if (key.indexOf(state) !== -1) {\r\n                    this.removeItem(key);\r\n                }\r\n            });\r\n        }\r\n\r\n        // delete generic interactive request parameters\r\n        if (state) {\r\n            this.removeItem(this.generateStateKey(state));\r\n            this.removeItem(this.generateNonceKey(state));\r\n            this.removeItem(this.generateAuthorityKey(state));\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.ORIGIN_URI));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.URL_HASH));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS_KEY));\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.CCS_CREDENTIAL));\r\n    }\r\n\r\n    /**\r\n     * Removes temporary cache for the provided state\r\n     * @param stateString \r\n     */\r\n    cleanRequestByState(stateString: string): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByState called\");\r\n        // Interaction is completed - remove interaction status.\r\n        if (stateString) {\r\n            const stateKey = this.generateStateKey(stateString);\r\n            const cachedState = this.temporaryCacheStorage.getItem(stateKey);\r\n            this.logger.infoPii(`BrowserCacheManager.cleanRequestByState: Removing temporary cache items for state: ${cachedState}`);\r\n            this.resetRequestCache(cachedState || \"\");\r\n        }\r\n        this.clearMsalCookies();\r\n    }\r\n\r\n    /**\r\n     * Looks in temporary cache for any state values with the provided interactionType and removes all temporary cache items for that state\r\n     * Used in scenarios where temp cache needs to be cleaned but state is not known, such as clicking browser back button.\r\n     * @param interactionType \r\n     */\r\n    cleanRequestByInteractionType(interactionType: InteractionType): void {\r\n        this.logger.trace(\"BrowserCacheManager.cleanRequestByInteractionType called\");\r\n        // Loop through all keys to find state key\r\n        this.getKeys().forEach((key) => {\r\n            // If this key is not the state key, move on\r\n            if (key.indexOf(TemporaryCacheKeys.REQUEST_STATE) === -1) {\r\n                return;\r\n            }\r\n            \r\n            // Retrieve state value, return if not a valid value\r\n            const stateValue = this.temporaryCacheStorage.getItem(key);\r\n            if (!stateValue) {\r\n                return;\r\n            }\r\n            // Extract state and ensure it matches given InteractionType, then clean request cache\r\n            const parsedState = BrowserProtocolUtils.extractBrowserRequestState(this.cryptoImpl, stateValue);\r\n            if (parsedState && parsedState.interactionType === interactionType) {\r\n                this.logger.infoPii(`BrowserCacheManager.cleanRequestByInteractionType: Removing temporary cache items for state: ${stateValue}`);\r\n                this.resetRequestCache(stateValue);\r\n            }\r\n        });\r\n        this.clearMsalCookies();\r\n    }\r\n\r\n    cacheCodeRequest(authCodeRequest: CommonAuthorizationCodeRequest, browserCrypto: ICrypto): void {\r\n        this.logger.trace(\"BrowserCacheManager.cacheCodeRequest called\");\r\n\r\n        const encodedValue = browserCrypto.base64Encode(JSON.stringify(authCodeRequest));\r\n        this.setTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, encodedValue, true);\r\n    }\r\n\r\n    /**\r\n     * Gets the token exchange parameters from the cache. Throws an error if nothing is found.\r\n     */\r\n    getCachedRequest(state: string, browserCrypto: ICrypto): CommonAuthorizationCodeRequest {\r\n        this.logger.trace(\"BrowserCacheManager.getCachedRequest called\");\r\n        // Get token request from cache and parse as TokenExchangeParameters.\r\n        const encodedTokenRequest = this.getTemporaryCache(TemporaryCacheKeys.REQUEST_PARAMS, true);\r\n        if (!encodedTokenRequest) {\r\n            throw BrowserAuthError.createNoTokenRequestCacheError();\r\n        }\r\n\r\n        const parsedRequest = this.validateAndParseJson(browserCrypto.base64Decode(encodedTokenRequest)) as CommonAuthorizationCodeRequest;\r\n        if (!parsedRequest) {\r\n            throw BrowserAuthError.createUnableToParseTokenRequestCacheError();\r\n        }\r\n        this.removeItem(this.generateCacheKey(TemporaryCacheKeys.REQUEST_PARAMS));\r\n\r\n        // Get cached authority and use if no authority is cached with request.\r\n        if (StringUtils.isEmpty(parsedRequest.authority)) {\r\n            const authorityCacheKey: string = this.generateAuthorityKey(state);\r\n            const cachedAuthority = this.getTemporaryCache(authorityCacheKey);\r\n            if (!cachedAuthority) {\r\n                throw BrowserAuthError.createNoCachedAuthorityError();\r\n            }\r\n            parsedRequest.authority = cachedAuthority;\r\n        }\r\n\r\n        return parsedRequest;\r\n    }\r\n}\r\n\r\nexport const DEFAULT_BROWSER_CACHE_MANAGER = (clientId: string, logger: Logger): BrowserCacheManager => {\r\n    const cacheOptions = {\r\n        cacheLocation: BrowserCacheLocation.MemoryStorage,\r\n        storeAuthStateInCookie: false,\r\n        secureCookies: false\r\n    };\r\n    return new BrowserCacheManager(clientId, cacheOptions, DEFAULT_CRYPTO_IMPLEMENTATION, logger);\r\n};\r\n"]},"metadata":{},"sourceType":"module"}