{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { RequestMethod } from \"../RequestMethod\";\nimport { MiddlewareControl } from \"./MiddlewareControl\";\nimport { cloneRequestWithNewUrl } from \"./MiddlewareUtil\";\nimport { RedirectHandlerOptions } from \"./options/RedirectHandlerOptions\";\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\n/**\r\n * @class\r\n * Class\r\n * @implements Middleware\r\n * Class representing RedirectHandler\r\n */\n\nexport class RedirectHandler {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * To create an instance of RedirectHandler\r\n   * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance\r\n   * @returns An instance of RedirectHandler\r\n   */\n  constructor(options = new RedirectHandlerOptions()) {\n    this.options = options;\n  }\n  /**\r\n   * @private\r\n   * To check whether the response has the redirect status code or not\r\n   * @param {Response} response - The response object\r\n   * @returns A boolean representing whether the response contains the redirect status code or not\r\n   */\n\n\n  isRedirect(response) {\n    return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;\n  }\n  /**\r\n   * @private\r\n   * To check whether the response has location header or not\r\n   * @param {Response} response - The response object\r\n   * @returns A boolean representing the whether the response has location header or not\r\n   */\n\n\n  hasLocationHeader(response) {\n    return response.headers.has(RedirectHandler.LOCATION_HEADER);\n  }\n  /**\r\n   * @private\r\n   * To get the redirect url from location header in response object\r\n   * @param {Response} response - The response object\r\n   * @returns A redirect url from location header\r\n   */\n\n\n  getLocationHeader(response) {\n    return response.headers.get(RedirectHandler.LOCATION_HEADER);\n  }\n  /**\r\n   * @private\r\n   * To check whether the given url is a relative url or not\r\n   * @param {string} url - The url string value\r\n   * @returns A boolean representing whether the given url is a relative url or not\r\n   */\n\n\n  isRelativeURL(url) {\n    return url.indexOf(\"://\") === -1;\n  }\n  /**\r\n   * @private\r\n   * To check whether the authorization header in the request should be dropped for consequent redirected requests\r\n   * @param {string} requestUrl - The request url value\r\n   * @param {string} redirectUrl - The redirect url value\r\n   * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests\r\n   */\n\n\n  shouldDropAuthorizationHeader(requestUrl, redirectUrl) {\n    const schemeHostRegex = /^[A-Za-z].+?:\\/\\/.+?(?=\\/|$)/;\n    const requestMatches = schemeHostRegex.exec(requestUrl);\n    let requestAuthority;\n    let redirectAuthority;\n\n    if (requestMatches !== null) {\n      requestAuthority = requestMatches[0];\n    }\n\n    const redirectMatches = schemeHostRegex.exec(redirectUrl);\n\n    if (redirectMatches !== null) {\n      redirectAuthority = redirectMatches[0];\n    }\n\n    return typeof requestAuthority !== \"undefined\" && typeof redirectAuthority !== \"undefined\" && requestAuthority !== redirectAuthority;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To update a request url with the redirect url\r\n   * @param {string} redirectUrl - The redirect url value\r\n   * @param {Context} context - The context object value\r\n   * @returns Nothing\r\n   */\n\n\n  updateRequestUrl(redirectUrl, context) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      context.request = typeof context.request === \"string\" ? redirectUrl : yield cloneRequestWithNewUrl(redirectUrl, context.request);\n    });\n  }\n  /**\r\n   * @private\r\n   * To get the options for execution of the middleware\r\n   * @param {Context} context - The context object\r\n   * @returns A options for middleware execution\r\n   */\n\n\n  getOptions(context) {\n    let options;\n\n    if (context.middlewareControl instanceof MiddlewareControl) {\n      options = context.middlewareControl.getMiddlewareOptions(RedirectHandlerOptions);\n    }\n\n    if (typeof options === \"undefined\") {\n      options = Object.assign(new RedirectHandlerOptions(), this.options);\n    }\n\n    return options;\n  }\n  /**\r\n   * @private\r\n   * @async\r\n   * To execute the next middleware and to handle in case of redirect response returned by the server\r\n   * @param {Context} context - The context object\r\n   * @param {number} redirectCount - The redirect count value\r\n   * @param {RedirectHandlerOptions} options - The redirect handler options instance\r\n   * @returns A promise that resolves to nothing\r\n   */\n\n\n  executeWithRedirect(context, redirectCount, options) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.nextMiddleware.execute(context);\n        const response = context.response;\n\n        if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {\n          ++redirectCount;\n\n          if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {\n            context.options.method = RequestMethod.GET;\n            delete context.options.body;\n          } else {\n            const redirectUrl = this.getLocationHeader(response);\n\n            if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {\n              delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];\n            }\n\n            yield this.updateRequestUrl(redirectUrl, context);\n          }\n\n          yield this.executeWithRedirect(context, redirectCount, options);\n        } else {\n          return;\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * To execute the current middleware\r\n   * @param {Context} context - The context object of the request\r\n   * @returns A Promise that resolves to nothing\r\n   */\n\n\n  execute(context) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const redirectCount = 0;\n        const options = this.getOptions(context);\n        context.options.redirect = RedirectHandler.MANUAL_REDIRECT;\n        TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);\n        return yield this.executeWithRedirect(context, redirectCount, options);\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * To set the next middleware in the chain\r\n   * @param {Middleware} next - The middleware instance\r\n   * @returns Nothing\r\n   */\n\n\n  setNext(next) {\n    this.nextMiddleware = next;\n  }\n\n}\n/**\r\n * @private\r\n * @static\r\n * A member holding the array of redirect status codes\r\n */\n\nRedirectHandler.REDIRECT_STATUS_CODES = [301, 302, 303, 307, 308];\n/**\r\n * @private\r\n * @static\r\n * A member holding SeeOther status code\r\n */\n\nRedirectHandler.STATUS_CODE_SEE_OTHER = 303;\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of the location header\r\n */\n\nRedirectHandler.LOCATION_HEADER = \"Location\";\n/**\r\n * @private\r\n * @static\r\n * A member representing the authorization header name\r\n */\n\nRedirectHandler.AUTHORIZATION_HEADER = \"Authorization\";\n/**\r\n * @private\r\n * @static\r\n * A member holding the manual redirect value\r\n */\n\nRedirectHandler.MANUAL_REDIRECT = \"manual\";","map":{"version":3,"sources":["../../../src/middleware/RedirectHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { RequestMethod } from \"../RequestMethod\";\r\nimport { MiddlewareControl } from \"./MiddlewareControl\";\r\nimport { cloneRequestWithNewUrl } from \"./MiddlewareUtil\";\r\nimport { RedirectHandlerOptions } from \"./options/RedirectHandlerOptions\";\r\nimport { FeatureUsageFlag, TelemetryHandlerOptions } from \"./options/TelemetryHandlerOptions\";\r\n/**\r\n * @class\r\n * Class\r\n * @implements Middleware\r\n * Class representing RedirectHandler\r\n */\r\nexport class RedirectHandler {\r\n    /**\r\n     * @public\r\n     * @constructor\r\n     * To create an instance of RedirectHandler\r\n     * @param {RedirectHandlerOptions} [options = new RedirectHandlerOptions()] - The redirect handler options instance\r\n     * @returns An instance of RedirectHandler\r\n     */\r\n    constructor(options = new RedirectHandlerOptions()) {\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * @private\r\n     * To check whether the response has the redirect status code or not\r\n     * @param {Response} response - The response object\r\n     * @returns A boolean representing whether the response contains the redirect status code or not\r\n     */\r\n    isRedirect(response) {\r\n        return RedirectHandler.REDIRECT_STATUS_CODES.indexOf(response.status) !== -1;\r\n    }\r\n    /**\r\n     * @private\r\n     * To check whether the response has location header or not\r\n     * @param {Response} response - The response object\r\n     * @returns A boolean representing the whether the response has location header or not\r\n     */\r\n    hasLocationHeader(response) {\r\n        return response.headers.has(RedirectHandler.LOCATION_HEADER);\r\n    }\r\n    /**\r\n     * @private\r\n     * To get the redirect url from location header in response object\r\n     * @param {Response} response - The response object\r\n     * @returns A redirect url from location header\r\n     */\r\n    getLocationHeader(response) {\r\n        return response.headers.get(RedirectHandler.LOCATION_HEADER);\r\n    }\r\n    /**\r\n     * @private\r\n     * To check whether the given url is a relative url or not\r\n     * @param {string} url - The url string value\r\n     * @returns A boolean representing whether the given url is a relative url or not\r\n     */\r\n    isRelativeURL(url) {\r\n        return url.indexOf(\"://\") === -1;\r\n    }\r\n    /**\r\n     * @private\r\n     * To check whether the authorization header in the request should be dropped for consequent redirected requests\r\n     * @param {string} requestUrl - The request url value\r\n     * @param {string} redirectUrl - The redirect url value\r\n     * @returns A boolean representing whether the authorization header in the request should be dropped for consequent redirected requests\r\n     */\r\n    shouldDropAuthorizationHeader(requestUrl, redirectUrl) {\r\n        const schemeHostRegex = /^[A-Za-z].+?:\\/\\/.+?(?=\\/|$)/;\r\n        const requestMatches = schemeHostRegex.exec(requestUrl);\r\n        let requestAuthority;\r\n        let redirectAuthority;\r\n        if (requestMatches !== null) {\r\n            requestAuthority = requestMatches[0];\r\n        }\r\n        const redirectMatches = schemeHostRegex.exec(redirectUrl);\r\n        if (redirectMatches !== null) {\r\n            redirectAuthority = redirectMatches[0];\r\n        }\r\n        return typeof requestAuthority !== \"undefined\" && typeof redirectAuthority !== \"undefined\" && requestAuthority !== redirectAuthority;\r\n    }\r\n    /**\r\n     * @private\r\n     * @async\r\n     * To update a request url with the redirect url\r\n     * @param {string} redirectUrl - The redirect url value\r\n     * @param {Context} context - The context object value\r\n     * @returns Nothing\r\n     */\r\n    updateRequestUrl(redirectUrl, context) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            context.request = typeof context.request === \"string\" ? redirectUrl : yield cloneRequestWithNewUrl(redirectUrl, context.request);\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * To get the options for execution of the middleware\r\n     * @param {Context} context - The context object\r\n     * @returns A options for middleware execution\r\n     */\r\n    getOptions(context) {\r\n        let options;\r\n        if (context.middlewareControl instanceof MiddlewareControl) {\r\n            options = context.middlewareControl.getMiddlewareOptions(RedirectHandlerOptions);\r\n        }\r\n        if (typeof options === \"undefined\") {\r\n            options = Object.assign(new RedirectHandlerOptions(), this.options);\r\n        }\r\n        return options;\r\n    }\r\n    /**\r\n     * @private\r\n     * @async\r\n     * To execute the next middleware and to handle in case of redirect response returned by the server\r\n     * @param {Context} context - The context object\r\n     * @param {number} redirectCount - The redirect count value\r\n     * @param {RedirectHandlerOptions} options - The redirect handler options instance\r\n     * @returns A promise that resolves to nothing\r\n     */\r\n    executeWithRedirect(context, redirectCount, options) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield this.nextMiddleware.execute(context);\r\n                const response = context.response;\r\n                if (redirectCount < options.maxRedirects && this.isRedirect(response) && this.hasLocationHeader(response) && options.shouldRedirect(response)) {\r\n                    ++redirectCount;\r\n                    if (response.status === RedirectHandler.STATUS_CODE_SEE_OTHER) {\r\n                        context.options.method = RequestMethod.GET;\r\n                        delete context.options.body;\r\n                    }\r\n                    else {\r\n                        const redirectUrl = this.getLocationHeader(response);\r\n                        if (!this.isRelativeURL(redirectUrl) && this.shouldDropAuthorizationHeader(response.url, redirectUrl)) {\r\n                            delete context.options.headers[RedirectHandler.AUTHORIZATION_HEADER];\r\n                        }\r\n                        yield this.updateRequestUrl(redirectUrl, context);\r\n                    }\r\n                    yield this.executeWithRedirect(context, redirectCount, options);\r\n                }\r\n                else {\r\n                    return;\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * To execute the current middleware\r\n     * @param {Context} context - The context object of the request\r\n     * @returns A Promise that resolves to nothing\r\n     */\r\n    execute(context) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const redirectCount = 0;\r\n                const options = this.getOptions(context);\r\n                context.options.redirect = RedirectHandler.MANUAL_REDIRECT;\r\n                TelemetryHandlerOptions.updateFeatureUsageFlag(context, FeatureUsageFlag.REDIRECT_HANDLER_ENABLED);\r\n                return yield this.executeWithRedirect(context, redirectCount, options);\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * To set the next middleware in the chain\r\n     * @param {Middleware} next - The middleware instance\r\n     * @returns Nothing\r\n     */\r\n    setNext(next) {\r\n        this.nextMiddleware = next;\r\n    }\r\n}\r\n/**\r\n * @private\r\n * @static\r\n * A member holding the array of redirect status codes\r\n */\r\nRedirectHandler.REDIRECT_STATUS_CODES = [\r\n    301,\r\n    302,\r\n    303,\r\n    307,\r\n    308,\r\n];\r\n/**\r\n * @private\r\n * @static\r\n * A member holding SeeOther status code\r\n */\r\nRedirectHandler.STATUS_CODE_SEE_OTHER = 303;\r\n/**\r\n * @private\r\n * @static\r\n * A member holding the name of the location header\r\n */\r\nRedirectHandler.LOCATION_HEADER = \"Location\";\r\n/**\r\n * @private\r\n * @static\r\n * A member representing the authorization header name\r\n */\r\nRedirectHandler.AUTHORIZATION_HEADER = \"Authorization\";\r\n/**\r\n * @private\r\n * @static\r\n * A member holding the manual redirect value\r\n */\r\nRedirectHandler.MANUAL_REDIRECT = \"manual\";\r\n//# sourceMappingURL=RedirectHandler.js.map"]},"metadata":{},"sourceType":"module"}