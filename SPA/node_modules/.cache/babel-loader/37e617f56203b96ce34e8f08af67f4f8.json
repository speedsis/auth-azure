{"ast":null,"code":"/*! @azure/msal-browser v2.16.0 2021-07-22 */\n'use strict';\n\nimport { __awaiter, __generator, __assign, __spread } from '../_virtual/_tslib.js';\nimport { CryptoOps } from '../crypto/CryptoOps.js';\nimport { UrlString, ThrottlingUtils, StringUtils, PromptValue, AccountEntity, AuthorityFactory, AuthorizationCodeClient, SilentFlowClient, RefreshTokenClient, AuthenticationScheme, ServerTelemetryManager, ProtocolUtils, ResponseMode, PersistentCacheKeys, IdToken, Constants, Logger, DEFAULT_CRYPTO_IMPLEMENTATION, ServerError, InteractionRequiredAuthError } from '@azure/msal-common';\nimport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER } from '../cache/BrowserCacheManager.js';\nimport { buildConfiguration } from '../config/Configuration.js';\nimport { InteractionType, TemporaryCacheKeys, ApiId, BrowserConstants, BrowserCacheLocation } from '../utils/BrowserConstants.js';\nimport { BrowserUtils } from '../utils/BrowserUtils.js';\nimport { BrowserProtocolUtils } from '../utils/BrowserProtocolUtils.js';\nimport { RedirectHandler } from '../interaction_handler/RedirectHandler.js';\nimport { PopupHandler } from '../interaction_handler/PopupHandler.js';\nimport { SilentHandler } from '../interaction_handler/SilentHandler.js';\nimport { BrowserAuthError } from '../error/BrowserAuthError.js';\nimport { name, version } from '../packageMetadata.js';\nimport { EventType } from '../event/EventType.js';\nimport { BrowserConfigurationAuthError } from '../error/BrowserConfigurationAuthError.js';\nimport { PopupUtils } from '../utils/PopupUtils.js';\nimport { EventHandler } from '../event/EventHandler.js';\n/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\n\nvar ClientApplication = function () {\n  /**\r\n   * @constructor\r\n   * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object\r\n   *\r\n   * Important attributes in the Configuration object for auth are:\r\n   * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\r\n   * - authority: the authority URL for your application.\r\n   * - redirect_uri: the uri of your application registered in the portal.\r\n   *\r\n   * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\r\n   * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}\r\n   * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n   * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n   * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n   * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n   *\r\n   * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/\r\n   * Full B2C functionality will be available in this library in future versions.\r\n   *\r\n   * @param configuration Object for the MSAL PublicClientApplication instance\r\n   */\n  function ClientApplication(configuration) {\n    /*\r\n     * If loaded in an environment where window is not available,\r\n     * set internal flag to false so that further requests fail.\r\n     * This is to support server-side rendering environments.\r\n     */\n    this.isBrowserEnvironment = typeof window !== \"undefined\"; // Set the configuration.\n\n    this.config = buildConfiguration(configuration, this.isBrowserEnvironment); // Initialize logger\n\n    this.logger = new Logger(this.config.system.loggerOptions, name, version); // Initialize the network module class.\n\n    this.networkClient = this.config.system.networkClient; // Initialize the navigation client class.\n\n    this.navigationClient = this.config.system.navigationClient; // Initialize redirectResponse Map\n\n    this.redirectResponse = new Map(); // Initialize the crypto class.\n\n    this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps() : DEFAULT_CRYPTO_IMPLEMENTATION;\n    this.eventHandler = new EventHandler(this.logger, this.browserCrypto); // Initialize the browser storage class.\n\n    this.browserStorage = this.isBrowserEnvironment ? new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) : DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);\n  } // #region Redirect Flow\n\n  /**\r\n   * Event handler function which allows users to fire events after the PublicClientApplication object\r\n   * has loaded during redirect flows. This should be invoked on all page loads involved in redirect\r\n   * auth flows.\r\n   * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.\r\n   * @returns Token response or null. If the return value is null, then no auth redirect was detected.\r\n   */\n\n\n  ClientApplication.prototype.handleRedirectPromise = function (hash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var loggedInAccounts, redirectResponseKey, response;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);\n        this.logger.verbose(\"handleRedirectPromise called\");\n        loggedInAccounts = this.getAllAccounts();\n\n        if (this.isBrowserEnvironment) {\n          redirectResponseKey = hash || Constants.EMPTY_STRING;\n          response = this.redirectResponse.get(redirectResponseKey);\n\n          if (typeof response === \"undefined\") {\n            this.logger.verbose(\"handleRedirectPromise has been called for the first time, storing the promise\");\n            response = this.handleRedirectResponse(hash).then(function (result) {\n              if (result) {\n                // Emit login event if number of accounts change\n                var isLoggingIn = loggedInAccounts.length < _this.getAllAccounts().length;\n\n                if (isLoggingIn) {\n                  _this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);\n\n                  _this.logger.verbose(\"handleRedirectResponse returned result, login success\");\n                } else {\n                  _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);\n\n                  _this.logger.verbose(\"handleRedirectResponse returned result, acquire token success\");\n                }\n              }\n\n              _this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\n\n              return result;\n            }).catch(function (e) {\n              // Emit login event if there is an account\n              if (loggedInAccounts.length > 0) {\n                _this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\n              } else {\n                _this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\n              }\n\n              _this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\n\n              throw e;\n            });\n            this.redirectResponse.set(redirectResponseKey, response);\n          } else {\n            this.logger.verbose(\"handleRedirectPromise has been called previously, returning the result from the first call\");\n          }\n\n          return [2\n          /*return*/\n          , response];\n        }\n\n        this.logger.verbose(\"handleRedirectPromise returns null, not browser environment\");\n        return [2\n        /*return*/\n        , null];\n      });\n    });\n  };\n  /**\r\n   * Checks if navigateToLoginRequestUrl is set, and:\r\n   * - if true, performs logic to cache and navigate\r\n   * - if false, handles hash string and parses response\r\n   * @param hash\r\n   */\n\n\n  ClientApplication.prototype.handleRedirectResponse = function (hash) {\n    return __awaiter(this, void 0, void 0, function () {\n      var responseHash, state, loginRequestUrl, loginRequestUrlNormalized, currentUrlNormalized, handleHashResult, navigationOptions, processHashOnRedirect, homepage;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (!this.interactionInProgress()) {\n              this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\n              return [2\n              /*return*/\n              , null];\n            }\n\n            responseHash = this.getRedirectResponseHash(hash || window.location.hash);\n\n            if (!responseHash) {\n              // Not a recognized server response hash or hash not associated with a redirect request\n              this.logger.info(\"handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.\");\n              this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n              return [2\n              /*return*/\n              , null];\n            }\n\n            try {\n              state = this.validateAndExtractStateFromHash(responseHash, InteractionType.Redirect);\n              BrowserUtils.clearHash(window);\n              this.logger.verbose(\"State extracted from hash\");\n            } catch (e) {\n              this.logger.info(\"handleRedirectPromise was unable to extract state due to: \" + e);\n              this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n              return [2\n              /*return*/\n              , null];\n            }\n\n            loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || \"\";\n            loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\n            currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\n            if (!(loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl)) return [3\n            /*break*/\n            , 2]; // We are on the page we need to navigate to - handle hash\n\n            this.logger.verbose(\"Current page is loginRequestUrl, handling hash\");\n            return [4\n            /*yield*/\n            , this.handleHash(responseHash, state)];\n\n          case 1:\n            handleHashResult = _a.sent();\n\n            if (loginRequestUrl.indexOf(\"#\") > -1) {\n              // Replace current hash with non-msal hash, if present\n              BrowserUtils.replaceHash(loginRequestUrl);\n            }\n\n            return [2\n            /*return*/\n            , handleHashResult];\n\n          case 2:\n            if (!!this.config.auth.navigateToLoginRequestUrl) return [3\n            /*break*/\n            , 3];\n            this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling hash\");\n            return [2\n            /*return*/\n            , this.handleHash(responseHash, state)];\n\n          case 3:\n            if (!!BrowserUtils.isInIframe()) return [3\n            /*break*/\n            , 8];\n            /*\r\n             * Returned from authority using redirect - need to perform navigation before processing response\r\n             * Cache the hash to be retrieved after the next redirect\r\n             */\n\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseHash, true);\n            navigationOptions = {\n              apiId: ApiId.handleRedirectPromise,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: true\n            };\n            processHashOnRedirect = true;\n            if (!(!loginRequestUrl || loginRequestUrl === \"null\")) return [3\n            /*break*/\n            , 5];\n            homepage = BrowserUtils.getHomepage(); // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\n\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\n            this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\n            return [4\n            /*yield*/\n            , this.navigationClient.navigateInternal(homepage, navigationOptions)];\n\n          case 4:\n            processHashOnRedirect = _a.sent();\n            return [3\n            /*break*/\n            , 7];\n\n          case 5:\n            // Navigate to page that initiated the redirect request\n            this.logger.verbose(\"Navigating to loginRequestUrl: \" + loginRequestUrl);\n            return [4\n            /*yield*/\n            , this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions)];\n\n          case 6:\n            processHashOnRedirect = _a.sent();\n            _a.label = 7;\n\n          case 7:\n            // If navigateInternal implementation returns false, handle the hash now\n            if (!processHashOnRedirect) {\n              return [2\n              /*return*/\n              , this.handleHash(responseHash, state)];\n            }\n\n            _a.label = 8;\n\n          case 8:\n            return [2\n            /*return*/\n            , null];\n        }\n      });\n    });\n  };\n  /**\r\n   * Gets the response hash for a redirect request\r\n   * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\r\n   * @param hash\r\n   */\n\n\n  ClientApplication.prototype.getRedirectResponseHash = function (hash) {\n    this.logger.verbose(\"getRedirectResponseHash called\"); // Get current location hash from window or cache.\n\n    var isResponseHash = UrlString.hashContainsKnownProperties(hash);\n    var cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\n    this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\n\n    if (isResponseHash) {\n      this.logger.verbose(\"Hash contains known properties, returning response hash\");\n      return hash;\n    }\n\n    this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\n    return cachedHash;\n  };\n  /**\r\n   * @param hash\r\n   * @param interactionType\r\n   */\n\n\n  ClientApplication.prototype.validateAndExtractStateFromHash = function (hash, interactionType, requestCorrelationId) {\n    this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId); // Deserialize hash fragment response parameters.\n\n    var serverParams = UrlString.getDeserializedHash(hash);\n\n    if (!serverParams.state) {\n      throw BrowserAuthError.createHashDoesNotContainStateError();\n    }\n\n    var platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\n\n    if (!platformStateObj) {\n      throw BrowserAuthError.createUnableToParseStateError();\n    }\n\n    if (platformStateObj.interactionType !== interactionType) {\n      throw BrowserAuthError.createStateInteractionTypeMismatchError();\n    }\n\n    this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\n    return serverParams.state;\n  };\n  /**\r\n   * Checks if hash exists and handles in window.\r\n   * @param hash\r\n   * @param state\r\n   */\n\n\n  ClientApplication.prototype.handleHash = function (hash, state) {\n    return __awaiter(this, void 0, void 0, function () {\n      var cachedRequest, browserRequestLogger, serverTelemetryManager, currentAuthority, authClient, interactionHandler, e_1;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            cachedRequest = this.browserStorage.getCachedRequest(state, this.browserCrypto);\n            browserRequestLogger = this.logger.clone(name, version, cachedRequest.correlationId);\n            browserRequestLogger.verbose(\"handleHash called, retrieved cached request\");\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise, cachedRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 4,, 5]);\n\n            currentAuthority = this.browserStorage.getCachedAuthority(state);\n\n            if (!currentAuthority) {\n              throw BrowserAuthError.createNoCachedAuthorityError();\n            }\n\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, currentAuthority, cachedRequest.correlationId)];\n\n          case 2:\n            authClient = _a.sent();\n            browserRequestLogger.verbose(\"Auth code client created\");\n            interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, browserRequestLogger, this.browserCrypto);\n            return [4\n            /*yield*/\n            , interactionHandler.handleCodeResponse(hash, state, authClient.authority, this.networkClient, this.config.auth.clientId)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            e_1 = _a.sent();\n            serverTelemetryManager.cacheFailedRequest(e_1);\n            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\n            throw e_1;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects\r\n   * the page, so any code that follows this function will not execute.\r\n   *\r\n   * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current\r\n   * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.\r\n   *\r\n   * @param request\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenRedirect = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var isLoggedIn, validRequest, browserRequestLogger, serverTelemetryManager, authCodeRequest, authClient, interactionHandler, navigateUrl, redirectStartPage, e_2;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            // Preflight request\n            this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\n            this.logger.verbose(\"acquireTokenRedirect called\");\n            isLoggedIn = this.getAllAccounts().length > 0;\n\n            if (isLoggedIn) {\n              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);\n            } else {\n              this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);\n            }\n\n            validRequest = this.preflightInteractiveRequest(request, InteractionType.Redirect);\n            browserRequestLogger = this.logger.clone(name, version, validRequest.correlationId);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect, validRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 5,, 6]);\n\n            return [4\n            /*yield*/\n            , this.initializeAuthorizationCodeRequest(validRequest)];\n\n          case 2:\n            authCodeRequest = _a.sent();\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.correlationId)];\n\n          case 3:\n            authClient = _a.sent();\n            browserRequestLogger.verbose(\"Auth code client created\");\n            interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger, this.browserCrypto);\n            return [4\n            /*yield*/\n            , authClient.getAuthCodeUrl(validRequest)];\n\n          case 4:\n            navigateUrl = _a.sent();\n            redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\n            browserRequestLogger.verbosePii(\"Redirect start page: \" + redirectStartPage); // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\n\n            return [2\n            /*return*/\n            , interactionHandler.initiateAuthRequest(navigateUrl, {\n              navigationClient: this.navigationClient,\n              redirectTimeout: this.config.system.redirectNavigationTimeout,\n              redirectStartPage: redirectStartPage,\n              onRedirectNavigate: request.onRedirectNavigate\n            })];\n\n          case 5:\n            e_2 = _a.sent(); // If logged in, emit acquire token events\n\n            if (isLoggedIn) {\n              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e_2);\n            } else {\n              this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e_2);\n            }\n\n            serverTelemetryManager.cacheFailedRequest(e_2);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e_2;\n\n          case 6:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // #endregion\n  // #region Popup Flow\n\n  /**\r\n   * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\r\n   *\r\n   * @param request\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenPopup = function (request) {\n    var validRequest;\n\n    try {\n      this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\n      this.logger.verbose(\"acquireTokenPopup called\", request.correlationId);\n      validRequest = this.preflightInteractiveRequest(request, InteractionType.Popup);\n    } catch (e) {\n      // Since this function is syncronous we need to reject\n      return Promise.reject(e);\n    }\n\n    var popupName = PopupUtils.generatePopupName(this.config.auth.clientId, validRequest); // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n\n    if (this.config.system.asyncPopups) {\n      this.logger.verbose(\"asyncPopups set to true, acquiring token\", validRequest.correlationId);\n      return this.acquireTokenPopupAsync(validRequest, popupName);\n    } else {\n      // asyncPopups flag is set to false. Opens popup before acquiring token.\n      this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\", validRequest.correlationId);\n      var popup = PopupUtils.openSizedPopup(\"about:blank\", popupName);\n      return this.acquireTokenPopupAsync(validRequest, popupName, popup);\n    }\n  };\n  /**\r\n   * Helper which obtains an access_token for your API via opening a popup window in the user's browser\r\n   * @param validRequest\r\n   * @param popupName\r\n   * @param popup\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenPopupAsync = function (validRequest, popupName, popup) {\n    return __awaiter(this, void 0, void 0, function () {\n      var loggedInAccounts, browserRequestLogger, serverTelemetryManager, authCodeRequest, authClient, navigateUrl, interactionHandler, popupParameters, popupWindow, hash, state, result, isLoggingIn, e_3;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"acquireTokenPopupAsync called\", validRequest.correlationId);\n            loggedInAccounts = this.getAllAccounts();\n\n            if (loggedInAccounts.length > 0) {\n              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, validRequest);\n            } else {\n              this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, validRequest);\n            }\n\n            browserRequestLogger = this.logger.clone(name, version, validRequest.correlationId);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup, validRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7,, 8]);\n\n            return [4\n            /*yield*/\n            , this.initializeAuthorizationCodeRequest(validRequest)];\n\n          case 2:\n            authCodeRequest = _a.sent();\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.correlationId)];\n\n          case 3:\n            authClient = _a.sent();\n            browserRequestLogger.verbose(\"Auth code client created\");\n            return [4\n            /*yield*/\n            , authClient.getAuthCodeUrl(validRequest)];\n\n          case 4:\n            navigateUrl = _a.sent();\n            interactionHandler = new PopupHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger);\n            popupParameters = {\n              popup: popup,\n              popupName: popupName\n            };\n            popupWindow = interactionHandler.initiateAuthRequest(navigateUrl, popupParameters);\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n              popupWindow: popupWindow\n            }, null);\n            return [4\n            /*yield*/\n            , interactionHandler.monitorPopupForHash(popupWindow)];\n\n          case 5:\n            hash = _a.sent();\n            state = this.validateAndExtractStateFromHash(hash, InteractionType.Popup, validRequest.correlationId); // Remove throttle if it exists\n\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest.authority, authCodeRequest.scopes);\n            return [4\n            /*yield*/\n            , interactionHandler.handleCodeResponse(hash, state, authClient.authority, this.networkClient)];\n\n          case 6:\n            result = _a.sent();\n            isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;\n\n            if (isLoggingIn) {\n              this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result);\n            } else {\n              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);\n            }\n\n            return [2\n            /*return*/\n            , result];\n\n          case 7:\n            e_3 = _a.sent();\n\n            if (loggedInAccounts.length > 0) {\n              this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e_3);\n            } else {\n              this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e_3);\n            }\n\n            if (popup) {\n              // Close the synchronous popup if an error is thrown before the window unload event is registered\n              popup.close();\n            }\n\n            serverTelemetryManager.cacheFailedRequest(e_3);\n            this.browserStorage.cleanRequestByState(validRequest.state);\n            throw e_3;\n\n          case 8:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // #endregion\n  // #region Silent Flow\n\n  /**\r\n   * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:\r\n   * - Any browser using a form of Intelligent Tracking Prevention\r\n   * - If there is not an established session with the service\r\n   *\r\n   * In these cases, the request must be done inside a popup or full frame redirect.\r\n   *\r\n   * For the cases where interaction is required, you cannot send a request with prompt=none.\r\n   *\r\n   * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as\r\n   * you session on the server still exists.\r\n   * @param request {@link SsoSilentRequest}\r\n   *\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.ssoSilent = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentTokenResult, e_4;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.preflightBrowserEnvironmentCheck(InteractionType.Silent);\n            this.logger.verbose(\"ssoSilent called\", request.correlationId);\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, request);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 3,, 4]);\n\n            return [4\n            /*yield*/\n            , this.acquireTokenByIframe(request, ApiId.ssoSilent)];\n\n          case 2:\n            silentTokenResult = _a.sent();\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, silentTokenResult);\n            return [2\n            /*return*/\n            , silentTokenResult];\n\n          case 3:\n            e_4 = _a.sent();\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e_4);\n            throw e_4;\n\n          case 4:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * This function uses a hidden iframe to fetch an authorization code from the eSTS. To be used for silent refresh token acquisition and renewal.\r\n   * @param request\r\n   * @param apiId - ApiId of the calling function. Used for telemetry.\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenByIframe = function (request, apiId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentRequest, browserRequestLogger, serverTelemetryManager, authCodeRequest, authClient, navigateUrl, e_5;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"acquireTokenByIframe called\", request.correlationId); // Check that we have some SSO data\n\n            if (StringUtils.isEmpty(request.loginHint) && StringUtils.isEmpty(request.sid) && (!request.account || StringUtils.isEmpty(request.account.username))) {\n              throw BrowserAuthError.createSilentSSOInsufficientInfoError();\n            } // Check that prompt is set to none, throw error if it is set to anything else.\n\n\n            if (request.prompt && request.prompt !== PromptValue.NONE) {\n              throw BrowserAuthError.createSilentPromptValueError(request.prompt);\n            }\n\n            silentRequest = this.initializeAuthorizationRequest(__assign(__assign({}, request), {\n              prompt: PromptValue.NONE\n            }), InteractionType.Silent);\n            browserRequestLogger = this.logger.clone(name, version, silentRequest.correlationId);\n            serverTelemetryManager = this.initializeServerTelemetryManager(apiId, silentRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 6,, 7]);\n\n            return [4\n            /*yield*/\n            , this.initializeAuthorizationCodeRequest(silentRequest)];\n\n          case 2:\n            authCodeRequest = _a.sent();\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, silentRequest.authority, silentRequest.correlationId)];\n\n          case 3:\n            authClient = _a.sent();\n            browserRequestLogger.verbose(\"Auth code client created\");\n            return [4\n            /*yield*/\n            , authClient.getAuthCodeUrl(silentRequest)];\n\n          case 4:\n            navigateUrl = _a.sent();\n            return [4\n            /*yield*/\n            , this.silentTokenHelper(navigateUrl, authCodeRequest, authClient, browserRequestLogger)];\n\n          case 5:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 6:\n            e_5 = _a.sent();\n            serverTelemetryManager.cacheFailedRequest(e_5);\n            this.browserStorage.cleanRequestByState(silentRequest.state);\n            throw e_5;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Use this function to obtain a token before every call to the API / resource provider\r\n   *\r\n   * MSAL return's a cached token when available\r\n   * Or it send's a request to the STS to obtain a new token using a refresh token.\r\n   *\r\n   * @param {@link SilentRequest}\r\n   *\r\n   * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n   * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n   */\n\n\n  ClientApplication.prototype.acquireTokenByRefreshToken = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentRequest, browserRequestLogger, serverTelemetryManager, refreshTokenClient, e_6, isServerError, isInteractionRequiredError, isInvalidGrantError;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_NETWORK_START, InteractionType.Silent, request); // block the reload if it occurred inside a hidden iframe\n\n            BrowserUtils.blockReloadInHiddenIframes();\n            silentRequest = __assign(__assign({}, request), this.initializeBaseRequest(request));\n            browserRequestLogger = this.logger.clone(name, version, silentRequest.correlationId);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow, silentRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 4,, 7]);\n\n            return [4\n            /*yield*/\n            , this.createRefreshTokenClient(serverTelemetryManager, silentRequest.authority, silentRequest.correlationId)];\n\n          case 2:\n            refreshTokenClient = _a.sent();\n            browserRequestLogger.verbose(\"Refresh token client created\");\n            return [4\n            /*yield*/\n            , refreshTokenClient.acquireTokenByRefreshToken(silentRequest)];\n\n          case 3:\n            // Send request to renew token. Auth module will throw errors if token cannot be renewed.\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 4:\n            e_6 = _a.sent();\n            serverTelemetryManager.cacheFailedRequest(e_6);\n            isServerError = e_6 instanceof ServerError;\n            isInteractionRequiredError = e_6 instanceof InteractionRequiredAuthError;\n            isInvalidGrantError = e_6.errorCode === BrowserConstants.INVALID_GRANT_ERROR;\n            if (!(isServerError && isInvalidGrantError && !isInteractionRequiredError)) return [3\n            /*break*/\n            , 6];\n            browserRequestLogger.verbose(\"Refresh token expired or invalid, attempting acquire token by iframe\");\n            return [4\n            /*yield*/\n            , this.acquireTokenByIframe(request, ApiId.acquireTokenSilent_authCode)];\n\n          case 5:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 6:\n            throw e_6;\n\n          case 7:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper which acquires an authorization code silently using a hidden iframe from given url\r\n   * using the scopes requested as part of the id, and exchanges the code for a set of OAuth tokens.\r\n   * @param navigateUrl\r\n   * @param userRequestScopes\r\n   */\n\n\n  ClientApplication.prototype.silentTokenHelper = function (navigateUrl, authCodeRequest, authClient, browserRequestLogger) {\n    return __awaiter(this, void 0, void 0, function () {\n      var silentHandler, msalFrame, hash, state;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            silentHandler = new SilentHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger, this.config.system.navigateFrameWait);\n            return [4\n            /*yield*/\n            , silentHandler.initiateAuthRequest(navigateUrl)];\n\n          case 1:\n            msalFrame = _a.sent();\n            return [4\n            /*yield*/\n            , silentHandler.monitorIframeForHash(msalFrame, this.config.system.iframeHashTimeout)];\n\n          case 2:\n            hash = _a.sent();\n            state = this.validateAndExtractStateFromHash(hash, InteractionType.Silent, authCodeRequest.correlationId); // Handle response from hash string\n\n            return [2\n            /*return*/\n            , silentHandler.handleCodeResponse(hash, state, authClient.authority, this.networkClient)];\n        }\n      });\n    });\n  }; // #endregion\n  // #region Logout\n\n  /**\r\n   * Deprecated logout function. Use logoutRedirect or logoutPopup instead\r\n   * @param logoutRequest\r\n   * @deprecated\r\n   */\n\n\n  ClientApplication.prototype.logout = function (logoutRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        this.logger.warning(\"logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.\");\n        return [2\n        /*return*/\n        , this.logoutRedirect(logoutRequest)];\n      });\n    });\n  };\n  /**\r\n   * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n   * Default behaviour is to redirect the user to `window.location.href`.\r\n   * @param logoutRequest\r\n   */\n\n\n  ClientApplication.prototype.logoutRedirect = function (logoutRequest) {\n    return __awaiter(this, void 0, void 0, function () {\n      var validLogoutRequest, browserRequestLogger, serverTelemetryManager, authClient, logoutUri, navigationOptions, navigate, e_7;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\n            this.logger.verbose(\"logoutRedirect called\", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);\n            validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n            browserRequestLogger = this.logger.clone(name, version, validLogoutRequest.correlationId);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout, validLogoutRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 9,, 10]);\n\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority, validLogoutRequest === null || validLogoutRequest === void 0 ? void 0 : validLogoutRequest.correlationId)];\n\n          case 2:\n            authClient = _a.sent();\n            browserRequestLogger.verbose(\"Auth code client created\");\n            logoutUri = authClient.getLogoutUri(validLogoutRequest);\n\n            if (!validLogoutRequest.account || AccountEntity.accountInfoIsEqual(validLogoutRequest.account, this.getActiveAccount(), false)) {\n              browserRequestLogger.verbose(\"Setting active account to null\");\n              this.setActiveAccount(null);\n            }\n\n            navigationOptions = {\n              apiId: ApiId.logout,\n              timeout: this.config.system.redirectNavigationTimeout,\n              noHistory: false\n            };\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\n            if (!(logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\")) return [3\n            /*break*/\n            , 6];\n            navigate = logoutRequest.onRedirectNavigate(logoutUri);\n            if (!(navigate !== false)) return [3\n            /*break*/\n            , 4];\n            browserRequestLogger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\n            return [4\n            /*yield*/\n            , this.navigationClient.navigateExternal(logoutUri, navigationOptions)];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 4:\n            browserRequestLogger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\n            _a.label = 5;\n\n          case 5:\n            return [3\n            /*break*/\n            , 8];\n\n          case 6:\n            return [4\n            /*yield*/\n            , this.navigationClient.navigateExternal(logoutUri, navigationOptions)];\n\n          case 7:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            e_7 = _a.sent();\n            serverTelemetryManager.cacheFailedRequest(e_7);\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e_7);\n            throw e_7;\n\n          case 10:\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\r\n   * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\r\n   * @param logoutRequest\r\n   */\n\n\n  ClientApplication.prototype.logoutPopup = function (logoutRequest) {\n    var validLogoutRequest;\n\n    try {\n      this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\n      this.logger.verbose(\"logoutPopup called\", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId);\n      validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\n    } catch (e) {\n      // Since this function is synchronous we need to reject\n      return Promise.reject(e);\n    }\n\n    var popupName = PopupUtils.generateLogoutPopupName(this.config.auth.clientId, validLogoutRequest);\n    var popup; // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\n\n    if (this.config.system.asyncPopups) {\n      this.logger.verbose(\"asyncPopups set to true\", validLogoutRequest.correlationId);\n    } else {\n      // asyncPopups flag is set to false. Opens popup before logging out.\n      this.logger.verbose(\"asyncPopup set to false, opening popup\", validLogoutRequest.correlationId);\n      popup = PopupUtils.openSizedPopup(\"about:blank\", popupName);\n    }\n\n    var authority = logoutRequest && logoutRequest.authority;\n    var mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\n    return this.logoutPopupAsync(validLogoutRequest, popupName, authority, popup, mainWindowRedirectUri);\n  };\n  /**\r\n   *\r\n   * @param request\r\n   * @param popupName\r\n   * @param requestAuthority\r\n   * @param popup\r\n   */\n\n\n  ClientApplication.prototype.logoutPopupAsync = function (validRequest, popupName, requestAuthority, popup, mainWindowRedirectUri) {\n    return __awaiter(this, void 0, void 0, function () {\n      var browserRequestLogger, serverTelemetryManager, authClient, logoutUri, popupUtils, popupWindow, e_8, navigationOptions, absoluteUrl, e_9;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"logoutPopupAsync called\", validRequest.correlationId);\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\n            browserRequestLogger = this.logger.clone(name, version, validRequest.correlationId);\n            serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup, validRequest.correlationId);\n            _a.label = 1;\n\n          case 1:\n            _a.trys.push([1, 7,, 8]);\n\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.INTERACTION_STATUS_KEY, BrowserConstants.INTERACTION_IN_PROGRESS_VALUE, true);\n            return [4\n            /*yield*/\n            , this.createAuthCodeClient(serverTelemetryManager, requestAuthority, validRequest.correlationId)];\n\n          case 2:\n            authClient = _a.sent();\n            browserRequestLogger.verbose(\"Auth code client created\");\n            logoutUri = authClient.getLogoutUri(validRequest);\n\n            if (!validRequest.account || AccountEntity.accountInfoIsEqual(validRequest.account, this.getActiveAccount(), false)) {\n              browserRequestLogger.verbose(\"Setting active account to null\");\n              this.setActiveAccount(null);\n            }\n\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\n            popupUtils = new PopupUtils(this.browserStorage, this.logger);\n            popupWindow = popupUtils.openPopup(logoutUri, popupName, popup);\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {\n              popupWindow: popupWindow\n            }, null);\n            _a.label = 3;\n\n          case 3:\n            _a.trys.push([3, 5,, 6]); // Don't care if this throws an error (User Cancelled)\n\n\n            return [4\n            /*yield*/\n            , popupUtils.monitorPopupForSameOrigin(popupWindow)];\n\n          case 4:\n            // Don't care if this throws an error (User Cancelled)\n            _a.sent();\n\n            browserRequestLogger.verbose(\"Popup successfully redirected to postLogoutRedirectUri\");\n            return [3\n            /*break*/\n            , 6];\n\n          case 5:\n            e_8 = _a.sent();\n            browserRequestLogger.verbose(\"Error occurred while monitoring popup for same origin. Session on server may remain active. Error: \" + e_8);\n            return [3\n            /*break*/\n            , 6];\n\n          case 6:\n            popupUtils.cleanPopup(popupWindow);\n\n            if (mainWindowRedirectUri) {\n              navigationOptions = {\n                apiId: ApiId.logoutPopup,\n                timeout: this.config.system.redirectNavigationTimeout,\n                noHistory: false\n              };\n              absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\n              browserRequestLogger.verbose(\"Redirecting main window to url specified in the request\");\n              browserRequestLogger.verbosePii(\"Redirecing main window to: \" + absoluteUrl);\n              this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\n            } else {\n              browserRequestLogger.verbose(\"No main window navigation requested\");\n            }\n\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            e_9 = _a.sent();\n\n            if (popup) {\n              // Close the synchronous popup if an error is thrown before the window unload event is registered\n              popup.close();\n            }\n\n            this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS_KEY));\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e_9);\n            serverTelemetryManager.cacheFailedRequest(e_9);\n            throw e_9;\n\n          case 8:\n            this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  }; // #endregion\n  // #region Account APIs\n\n  /**\r\n   * Returns all accounts that MSAL currently has data for.\r\n   * (the account object is created at the time of successful login)\r\n   * or empty array when no accounts are found\r\n   * @returns Array of account objects in cache\r\n   */\n\n\n  ClientApplication.prototype.getAllAccounts = function () {\n    this.logger.verbose(\"getAllAccounts called\");\n    return this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : [];\n  };\n  /**\r\n   * Returns the signed in account matching username.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found.\r\n   * This API is provided for convenience but getAccountById should be used for best reliability\r\n   * @param userName\r\n   * @returns The account object stored in MSAL\r\n   */\n\n\n  ClientApplication.prototype.getAccountByUsername = function (userName) {\n    var allAccounts = this.getAllAccounts();\n\n    if (!StringUtils.isEmpty(userName) && allAccounts && allAccounts.length) {\n      this.logger.verbose(\"Account matching username found, returning\");\n      this.logger.verbosePii(\"Returning signed-in accounts matching username: \" + userName);\n      return allAccounts.filter(function (accountObj) {\n        return accountObj.username.toLowerCase() === userName.toLowerCase();\n      })[0] || null;\n    } else {\n      this.logger.verbose(\"getAccountByUsername: No matching account found, returning null\");\n      return null;\n    }\n  };\n  /**\r\n   * Returns the signed in account matching homeAccountId.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found\r\n   * @param homeAccountId\r\n   * @returns The account object stored in MSAL\r\n   */\n\n\n  ClientApplication.prototype.getAccountByHomeId = function (homeAccountId) {\n    var allAccounts = this.getAllAccounts();\n\n    if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\n      this.logger.verbose(\"Account matching homeAccountId found, returning\");\n      this.logger.verbosePii(\"Returning signed-in accounts matching homeAccountId: \" + homeAccountId);\n      return allAccounts.filter(function (accountObj) {\n        return accountObj.homeAccountId === homeAccountId;\n      })[0] || null;\n    } else {\n      this.logger.verbose(\"getAccountByHomeId: No matching account found, returning null\");\n      return null;\n    }\n  };\n  /**\r\n   * Returns the signed in account matching localAccountId.\r\n   * (the account object is created at the time of successful login)\r\n   * or null when no matching account is found\r\n   * @param localAccountId\r\n   * @returns The account object stored in MSAL\r\n   */\n\n\n  ClientApplication.prototype.getAccountByLocalId = function (localAccountId) {\n    var allAccounts = this.getAllAccounts();\n\n    if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\n      this.logger.verbose(\"Account matching localAccountId found, returning\");\n      this.logger.verbosePii(\"Returning signed-in accounts matching localAccountId: \" + localAccountId);\n      return allAccounts.filter(function (accountObj) {\n        return accountObj.localAccountId === localAccountId;\n      })[0] || null;\n    } else {\n      this.logger.verbose(\"getAccountByLocalId: No matching account found, returning null\");\n      return null;\n    }\n  };\n  /**\r\n   * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\r\n   * @param account\r\n   */\n\n\n  ClientApplication.prototype.setActiveAccount = function (account) {\n    this.browserStorage.setActiveAccount(account);\n  };\n  /**\r\n   * Gets the currently active account\r\n   */\n\n\n  ClientApplication.prototype.getActiveAccount = function () {\n    return this.browserStorage.getActiveAccount();\n  }; // #endregion\n  // #region Helpers\n\n  /**\r\n   *\r\n   * Use to get the redirect uri configured in MSAL or null.\r\n   * @param requestRedirectUri\r\n   * @returns Redirect URL\r\n   *\r\n   */\n\n\n  ClientApplication.prototype.getRedirectUri = function (requestRedirectUri) {\n    this.logger.verbose(\"getRedirectUri called\");\n    var redirectUri = requestRedirectUri || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();\n    return UrlString.getAbsoluteUrl(redirectUri, BrowserUtils.getCurrentUri());\n  };\n  /**\r\n   * Use to get the redirectStartPage either from request or use current window\r\n   * @param requestStartPage\r\n   */\n\n\n  ClientApplication.prototype.getRedirectStartPage = function (requestStartPage) {\n    var redirectStartPage = requestStartPage || window.location.href;\n    return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri());\n  };\n  /**\r\n   * Used to get a discovered version of the default authority.\r\n   * @param requestAuthority\r\n   * @param requestCorrelationId\r\n   */\n\n\n  ClientApplication.prototype.getDiscoveredAuthority = function (requestAuthority, requestCorrelationId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var authorityOptions;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"getDiscoveredAuthority called\", requestCorrelationId);\n            authorityOptions = {\n              protocolMode: this.config.auth.protocolMode,\n              knownAuthorities: this.config.auth.knownAuthorities,\n              cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\n              authorityMetadata: this.config.auth.authorityMetadata\n            };\n            if (!requestAuthority) return [3\n            /*break*/\n            , 2];\n            this.logger.verbose(\"Creating discovered authority with request authority\", requestCorrelationId);\n            return [4\n            /*yield*/\n            , AuthorityFactory.createDiscoveredInstance(requestAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions)];\n\n          case 1:\n            return [2\n            /*return*/\n            , _a.sent()];\n\n          case 2:\n            this.logger.verbose(\"Creating discovered authority with configured authority\", requestCorrelationId);\n            return [4\n            /*yield*/\n            , AuthorityFactory.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, authorityOptions)];\n\n          case 3:\n            return [2\n            /*return*/\n            , _a.sent()];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper to check whether interaction is in progress.\r\n   */\n\n\n  ClientApplication.prototype.interactionInProgress = function () {\n    // Check whether value in cache is present and equal to expected value\n    return this.browserStorage.getTemporaryCache(TemporaryCacheKeys.INTERACTION_STATUS_KEY, true) === BrowserConstants.INTERACTION_IN_PROGRESS_VALUE;\n  };\n  /**\r\n   * Creates an Authorization Code Client with the given authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param authorityUrl\r\n   */\n\n\n  ClientApplication.prototype.createAuthCodeClient = function (serverTelemetryManager, authorityUrl, correlationId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientConfig;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getClientConfiguration(serverTelemetryManager, authorityUrl, correlationId)];\n\n          case 1:\n            clientConfig = _a.sent();\n            return [2\n            /*return*/\n            , new AuthorizationCodeClient(clientConfig)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates an Silent Flow Client with the given authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param authorityUrl\r\n   */\n\n\n  ClientApplication.prototype.createSilentFlowClient = function (serverTelemetryManager, authorityUrl, correlationId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientConfig;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getClientConfiguration(serverTelemetryManager, authorityUrl, correlationId)];\n\n          case 1:\n            clientConfig = _a.sent();\n            return [2\n            /*return*/\n            , new SilentFlowClient(clientConfig)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates a Refresh Client with the given authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param authorityUrl\r\n   */\n\n\n  ClientApplication.prototype.createRefreshTokenClient = function (serverTelemetryManager, authorityUrl, correlationId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var clientConfig;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.getClientConfiguration(serverTelemetryManager, authorityUrl, correlationId)];\n\n          case 1:\n            clientConfig = _a.sent();\n            return [2\n            /*return*/\n            , new RefreshTokenClient(clientConfig)];\n        }\n      });\n    });\n  };\n  /**\r\n   * Creates a Client Configuration object with the given request authority, or the default authority.\r\n   * @param serverTelemetryManager\r\n   * @param requestAuthority\r\n   * @param requestCorrelationId\r\n   */\n\n\n  ClientApplication.prototype.getClientConfiguration = function (serverTelemetryManager, requestAuthority, requestCorrelationId) {\n    return __awaiter(this, void 0, void 0, function () {\n      var discoveredAuthority;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"getClientConfiguration called\", requestCorrelationId);\n            return [4\n            /*yield*/\n            , this.getDiscoveredAuthority(requestAuthority, requestCorrelationId)];\n\n          case 1:\n            discoveredAuthority = _a.sent();\n            return [2\n            /*return*/\n            , {\n              authOptions: {\n                clientId: this.config.auth.clientId,\n                authority: discoveredAuthority,\n                clientCapabilities: this.config.auth.clientCapabilities\n              },\n              systemOptions: {\n                tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\n                preventCorsPreflight: true\n              },\n              loggerOptions: {\n                loggerCallback: this.config.system.loggerOptions.loggerCallback,\n                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,\n                logLevel: this.config.system.loggerOptions.logLevel,\n                correlationId: requestCorrelationId\n              },\n              cryptoInterface: this.browserCrypto,\n              networkInterface: this.networkClient,\n              storageInterface: this.browserStorage,\n              serverTelemetryManager: serverTelemetryManager,\n              libraryInfo: {\n                sku: BrowserConstants.MSAL_SKU,\n                version: version,\n                cpu: \"\",\n                os: \"\"\n              }\n            }];\n        }\n      });\n    });\n  };\n  /**\r\n   * Helper to validate app environment before making a request.\r\n   * @param request\r\n   * @param interactionType\r\n   */\n\n\n  ClientApplication.prototype.preflightInteractiveRequest = function (request, interactionType) {\n    this.logger.verbose(\"preflightInteractiveRequest called, validating app environment\", request === null || request === void 0 ? void 0 : request.correlationId); // block the reload if it occurred inside a hidden iframe\n\n    BrowserUtils.blockReloadInHiddenIframes(); // Check if interaction is in progress. Throw error if true.\n\n    if (this.interactionInProgress()) {\n      throw BrowserAuthError.createInteractionInProgressError();\n    }\n\n    return this.initializeAuthorizationRequest(request, interactionType);\n  };\n  /**\r\n   * Helper to validate app environment before making an auth request\r\n   * * @param interactionType\r\n   */\n\n\n  ClientApplication.prototype.preflightBrowserEnvironmentCheck = function (interactionType) {\n    this.logger.verbose(\"preflightBrowserEnvironmentCheck started\"); // Block request if not in browser environment\n\n    BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment); // Block redirects if in an iframe\n\n    BrowserUtils.blockRedirectInIframe(interactionType, this.config.system.allowRedirectInIframe); // Block auth requests inside a hidden iframe\n\n    BrowserUtils.blockReloadInHiddenIframes(); // Block redirectUri opened in a popup from calling MSAL APIs\n\n    BrowserUtils.blockAcquireTokenInPopups(); // Block redirects if memory storage is enabled but storeAuthStateInCookie is not\n\n    if (interactionType === InteractionType.Redirect && this.config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage && !this.config.cache.storeAuthStateInCookie) {\n      throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();\n    }\n  };\n  /**\r\n   * Initializer function for all request APIs\r\n   * @param request\r\n   */\n\n\n  ClientApplication.prototype.initializeBaseRequest = function (request) {\n    this.logger.verbose(\"Initializing BaseAuthRequest\", request.correlationId);\n    var authority = request.authority || this.config.auth.authority;\n\n    var scopes = __spread(request && request.scopes || []);\n\n    var correlationId = request && request.correlationId || this.browserCrypto.createNewGuid(); // Set authenticationScheme to BEARER if not explicitly set in the request\n\n    if (!request.authenticationScheme) {\n      request.authenticationScheme = AuthenticationScheme.BEARER;\n      this.logger.verbose(\"Authentication Scheme wasn't explicitly set in request, defaulting to \\\"Bearer\\\" request\", request.correlationId);\n    } else {\n      this.logger.verbose(\"Authentication Scheme set to \\\"\" + request.authenticationScheme + \"\\\" as configured in Auth request\", request.correlationId);\n    }\n\n    var validatedRequest = __assign(__assign({}, request), {\n      correlationId: correlationId,\n      authority: authority,\n      scopes: scopes\n    });\n\n    return validatedRequest;\n  };\n  /**\r\n   *\r\n   * @param apiId\r\n   * @param correlationId\r\n   * @param forceRefresh\r\n   */\n\n\n  ClientApplication.prototype.initializeServerTelemetryManager = function (apiId, correlationId, forceRefresh) {\n    this.logger.verbose(\"initializeServerTelemetryManager called\", correlationId);\n    var telemetryPayload = {\n      clientId: this.config.auth.clientId,\n      correlationId: correlationId,\n      apiId: apiId,\n      forceRefresh: forceRefresh || false,\n      wrapperSKU: this.wrapperSKU,\n      wrapperVer: this.wrapperVer\n    };\n    return new ServerTelemetryManager(telemetryPayload, this.browserStorage);\n  };\n  /**\r\n   * Helper to initialize required request parameters for interactive APIs and ssoSilent()\r\n   * @param request\r\n   * @param interactionType\r\n   */\n\n\n  ClientApplication.prototype.initializeAuthorizationRequest = function (request, interactionType) {\n    this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n    var redirectUri = this.getRedirectUri(request.redirectUri);\n    var browserState = {\n      interactionType: interactionType\n    };\n    var state = ProtocolUtils.setRequestState(this.browserCrypto, request && request.state || \"\", browserState);\n\n    var validatedRequest = __assign(__assign({}, this.initializeBaseRequest(request)), {\n      redirectUri: redirectUri,\n      state: state,\n      nonce: request.nonce || this.browserCrypto.createNewGuid(),\n      responseMode: ResponseMode.FRAGMENT\n    });\n\n    var account = request.account || this.getActiveAccount();\n\n    if (account) {\n      this.logger.verbose(\"Setting validated request account\");\n      this.logger.verbosePii(\"Setting validated request account: \" + account);\n      validatedRequest.account = account;\n    } // Check for ADAL SSO\n\n\n    if (StringUtils.isEmpty(validatedRequest.loginHint)) {\n      // Only check for adal token if no SSO params are being used\n      var adalIdTokenString = this.browserStorage.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\n\n      if (adalIdTokenString) {\n        var adalIdToken = new IdToken(adalIdTokenString, this.browserCrypto);\n        this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\n\n        if (adalIdToken.claims && adalIdToken.claims.upn) {\n          this.logger.verbose(\"No SSO params used and ADAL token retrieved, setting ADAL upn as loginHint\");\n          validatedRequest.loginHint = adalIdToken.claims.upn;\n        }\n      }\n    }\n\n    this.browserStorage.updateCacheEntries(validatedRequest.state, validatedRequest.nonce, validatedRequest.authority, validatedRequest.loginHint || \"\", validatedRequest.account || null);\n    return validatedRequest;\n  };\n  /**\r\n   * Generates an auth code request tied to the url request.\r\n   * @param request\r\n   */\n\n\n  ClientApplication.prototype.initializeAuthorizationCodeRequest = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var generatedPkceParams, authCodeRequest;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\n            return [4\n            /*yield*/\n            , this.browserCrypto.generatePkceCodes()];\n\n          case 1:\n            generatedPkceParams = _a.sent();\n            authCodeRequest = __assign(__assign({}, request), {\n              redirectUri: request.redirectUri,\n              code: \"\",\n              codeVerifier: generatedPkceParams.verifier\n            });\n            request.codeChallenge = generatedPkceParams.challenge;\n            request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\n            return [2\n            /*return*/\n            , authCodeRequest];\n        }\n      });\n    });\n  };\n  /**\r\n   * Initializer for the logout request.\r\n   * @param logoutRequest\r\n   */\n\n\n  ClientApplication.prototype.initializeLogoutRequest = function (logoutRequest) {\n    this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest === null || logoutRequest === void 0 ? void 0 : logoutRequest.correlationId); // Check if interaction is in progress. Throw error if true.\n\n    if (this.interactionInProgress()) {\n      throw BrowserAuthError.createInteractionInProgressError();\n    }\n\n    var validLogoutRequest = __assign({\n      correlationId: this.browserCrypto.createNewGuid()\n    }, logoutRequest);\n    /*\r\n     * Only set redirect uri if logout request isn't provided or the set uri isn't null.\r\n     * Otherwise, use passed uri, config, or current page.\r\n     */\n\n\n    if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\n      if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else if (this.config.auth.postLogoutRedirectUri === null) {\n        this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\n      } else if (this.config.auth.postLogoutRedirectUri) {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\n      } else {\n        this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\n        validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\n      }\n    } else {\n      this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\n    }\n\n    return validLogoutRequest;\n  };\n  /**\r\n   * Adds event callbacks to array\r\n   * @param callback\r\n   */\n\n\n  ClientApplication.prototype.addEventCallback = function (callback) {\n    return this.eventHandler.addEventCallback(callback);\n  };\n  /**\r\n   * Removes callback with provided id from callback array\r\n   * @param callbackId\r\n   */\n\n\n  ClientApplication.prototype.removeEventCallback = function (callbackId) {\n    this.eventHandler.removeEventCallback(callbackId);\n  };\n  /**\r\n   * Returns the logger instance\r\n   */\n\n\n  ClientApplication.prototype.getLogger = function () {\n    return this.logger;\n  };\n  /**\r\n   * Replaces the default logger set in configurations with new Logger with new configurations\r\n   * @param logger Logger instance\r\n   */\n\n\n  ClientApplication.prototype.setLogger = function (logger) {\n    this.logger = logger;\n  };\n  /**\r\n   * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.\r\n   * @param sku\r\n   * @param version\r\n   */\n\n\n  ClientApplication.prototype.initializeWrapperLibrary = function (sku, version) {\n    // Validate the SKU passed in is one we expect\n    this.wrapperSKU = sku;\n    this.wrapperVer = version;\n  };\n  /**\r\n   * Sets navigation client\r\n   * @param navigationClient\r\n   */\n\n\n  ClientApplication.prototype.setNavigationClient = function (navigationClient) {\n    this.navigationClient = navigationClient;\n  };\n\n  return ClientApplication;\n}();\n\nexport { ClientApplication };","map":{"version":3,"sources":["../../src/app/ClientApplication.ts"],"names":[],"mappings":"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","sourcesContent":["/*\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License.\r\n */\r\n\r\nimport { CryptoOps } from \"../crypto/CryptoOps\";\r\nimport { Authority, StringUtils, UrlString, ServerAuthorizationCodeResponse, CommonAuthorizationCodeRequest, AuthorizationCodeClient, PromptValue, ServerError, InteractionRequiredAuthError, AccountInfo, AuthorityFactory, ServerTelemetryManager, SilentFlowClient, ClientConfiguration, BaseAuthRequest, ServerTelemetryRequest, PersistentCacheKeys, IdToken, ProtocolUtils, ResponseMode, Constants, INetworkModule, AuthenticationResult, Logger, ThrottlingUtils, RefreshTokenClient, AuthenticationScheme, CommonSilentFlowRequest, CommonEndSessionRequest, AccountEntity, ICrypto, DEFAULT_CRYPTO_IMPLEMENTATION, AuthorityOptions } from \"@azure/msal-common\";\r\nimport { BrowserCacheManager, DEFAULT_BROWSER_CACHE_MANAGER } from \"../cache/BrowserCacheManager\";\r\nimport { BrowserConfiguration, buildConfiguration, Configuration } from \"../config/Configuration\";\r\nimport { TemporaryCacheKeys, InteractionType, ApiId, BrowserConstants, BrowserCacheLocation, WrapperSKU } from \"../utils/BrowserConstants\";\r\nimport { BrowserUtils } from \"../utils/BrowserUtils\";\r\nimport { BrowserStateObject, BrowserProtocolUtils } from \"../utils/BrowserProtocolUtils\";\r\nimport { RedirectHandler } from \"../interaction_handler/RedirectHandler\";\r\nimport { PopupHandler, PopupParams } from \"../interaction_handler/PopupHandler\";\r\nimport { SilentHandler } from \"../interaction_handler/SilentHandler\";\r\nimport { RedirectRequest } from \"../request/RedirectRequest\";\r\nimport { PopupRequest } from \"../request/PopupRequest\";\r\nimport { AuthorizationUrlRequest } from \"../request/AuthorizationUrlRequest\";\r\nimport { BrowserAuthError } from \"../error/BrowserAuthError\";\r\nimport { SsoSilentRequest } from \"../request/SsoSilentRequest\";\r\nimport { version, name } from \"../packageMetadata\";\r\nimport { EventCallbackFunction } from \"../event/EventMessage\";\r\nimport { EventType } from \"../event/EventType\";\r\nimport { EndSessionRequest } from \"../request/EndSessionRequest\";\r\nimport { BrowserConfigurationAuthError } from \"../error/BrowserConfigurationAuthError\";\r\nimport { PopupUtils } from \"../utils/PopupUtils\";\r\nimport { EndSessionPopupRequest } from \"../request/EndSessionPopupRequest\";\r\nimport { INavigationClient } from \"../navigation/INavigationClient\";\r\nimport { NavigationOptions } from \"../navigation/NavigationOptions\";\r\nimport { EventHandler } from \"../event/EventHandler\";\r\n\r\nexport abstract class ClientApplication {\r\n\r\n    // Crypto interface implementation\r\n    protected readonly browserCrypto: ICrypto;\r\n\r\n    // Storage interface implementation\r\n    protected readonly browserStorage: BrowserCacheManager;\r\n\r\n    // Network interface implementation\r\n    protected readonly networkClient: INetworkModule;\r\n\r\n    // Navigation interface implementation\r\n    protected navigationClient: INavigationClient;\r\n\r\n    // Input configuration by developer/user\r\n    protected config: BrowserConfiguration;\r\n\r\n    // Logger\r\n    protected logger: Logger;\r\n\r\n    // Flag to indicate if in browser environment\r\n    protected isBrowserEnvironment: boolean;\r\n\r\n    // Set the SKU and Version for wrapper library if applicable\r\n    private wrapperSKU: string | undefined;\r\n    private wrapperVer: string | undefined;\r\n\r\n    protected eventHandler: EventHandler;\r\n\r\n    // Redirect Response Object\r\n    private redirectResponse: Map<string, Promise<AuthenticationResult | null>>;\r\n\r\n    /**\r\n     * @constructor\r\n     * Constructor for the PublicClientApplication used to instantiate the PublicClientApplication object\r\n     *\r\n     * Important attributes in the Configuration object for auth are:\r\n     * - clientID: the application ID of your application. You can obtain one by registering your application with our Application registration portal : https://portal.azure.com/#blade/Microsoft_AAD_IAM/ActiveDirectoryMenuBlade/RegisteredAppsPreview\r\n     * - authority: the authority URL for your application.\r\n     * - redirect_uri: the uri of your application registered in the portal.\r\n     *\r\n     * In Azure AD, authority is a URL indicating the Azure active directory that MSAL uses to obtain tokens.\r\n     * It is of the form https://login.microsoftonline.com/{Enter_the_Tenant_Info_Here}\r\n     * If your application supports Accounts in one organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with the Tenant Id or Tenant name (for example, contoso.microsoft.com).\r\n     * If your application supports Accounts in any organizational directory, replace \"Enter_the_Tenant_Info_Here\" value with organizations.\r\n     * If your application supports Accounts in any organizational directory and personal Microsoft accounts, replace \"Enter_the_Tenant_Info_Here\" value with common.\r\n     * To restrict support to Personal Microsoft accounts only, replace \"Enter_the_Tenant_Info_Here\" value with consumers.\r\n     *\r\n     * In Azure B2C, authority is of the form https://{instance}/tfp/{tenant}/{policyName}/\r\n     * Full B2C functionality will be available in this library in future versions.\r\n     *\r\n     * @param configuration Object for the MSAL PublicClientApplication instance\r\n     */\r\n    constructor(configuration: Configuration) {\r\n        /*\r\n         * If loaded in an environment where window is not available,\r\n         * set internal flag to false so that further requests fail.\r\n         * This is to support server-side rendering environments.\r\n         */\r\n        this.isBrowserEnvironment = typeof window !== \"undefined\";\r\n        // Set the configuration.\r\n        this.config = buildConfiguration(configuration, this.isBrowserEnvironment);\r\n\r\n        // Initialize logger\r\n        this.logger = new Logger(this.config.system.loggerOptions, name, version);\r\n        \r\n        // Initialize the network module class.\r\n        this.networkClient = this.config.system.networkClient;\r\n        \r\n        // Initialize the navigation client class.\r\n        this.navigationClient = this.config.system.navigationClient;\r\n        \r\n        // Initialize redirectResponse Map\r\n        this.redirectResponse = new Map();\r\n        \r\n        // Initialize the crypto class.\r\n        this.browserCrypto = this.isBrowserEnvironment ? new CryptoOps() : DEFAULT_CRYPTO_IMPLEMENTATION;\r\n\r\n        this.eventHandler = new EventHandler(this.logger, this.browserCrypto);\r\n\r\n        // Initialize the browser storage class.\r\n        this.browserStorage = this.isBrowserEnvironment ? \r\n            new BrowserCacheManager(this.config.auth.clientId, this.config.cache, this.browserCrypto, this.logger) : \r\n            DEFAULT_BROWSER_CACHE_MANAGER(this.config.auth.clientId, this.logger);\r\n    }\r\n\r\n    // #region Redirect Flow\r\n\r\n    /**\r\n     * Event handler function which allows users to fire events after the PublicClientApplication object\r\n     * has loaded during redirect flows. This should be invoked on all page loads involved in redirect\r\n     * auth flows.\r\n     * @param hash Hash to process. Defaults to the current value of window.location.hash. Only needs to be provided explicitly if the response to be handled is not contained in the current value.\r\n     * @returns Token response or null. If the return value is null, then no auth redirect was detected.\r\n     */\r\n    async handleRedirectPromise(hash?: string): Promise<AuthenticationResult | null> {\r\n        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_START, InteractionType.Redirect);\r\n        this.logger.verbose(\"handleRedirectPromise called\");\r\n        const loggedInAccounts = this.getAllAccounts();\r\n        if (this.isBrowserEnvironment) {\r\n            /**\r\n             * Store the promise on the PublicClientApplication instance if this is the first invocation of handleRedirectPromise,\r\n             * otherwise return the promise from the first invocation. Prevents race conditions when handleRedirectPromise is called\r\n             * several times concurrently.\r\n             */\r\n            const redirectResponseKey = hash || Constants.EMPTY_STRING;\r\n            let response = this.redirectResponse.get(redirectResponseKey);\r\n            if (typeof response === \"undefined\") {\r\n                this.logger.verbose(\"handleRedirectPromise has been called for the first time, storing the promise\");\r\n                response = this.handleRedirectResponse(hash)\r\n                    .then((result: AuthenticationResult | null) => {\r\n                        if (result) {\r\n                        // Emit login event if number of accounts change\r\n                            const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;\r\n                            if (isLoggingIn) {\r\n                                this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Redirect, result);\r\n                                this.logger.verbose(\"handleRedirectResponse returned result, login success\");\r\n                            } else {\r\n                                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Redirect, result);\r\n                                this.logger.verbose(\"handleRedirectResponse returned result, acquire token success\");\r\n                            }\r\n                        }\r\n                        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\r\n\r\n                        return result;\r\n                    })\r\n                    .catch((e) => {\r\n                    // Emit login event if there is an account\r\n                        if (loggedInAccounts.length > 0) {\r\n                            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\r\n                        } else {\r\n                            this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\r\n                        }\r\n                        this.eventHandler.emitEvent(EventType.HANDLE_REDIRECT_END, InteractionType.Redirect);\r\n\r\n                        throw e;\r\n                    });\r\n                this.redirectResponse.set(redirectResponseKey, response);\r\n            } else {\r\n                this.logger.verbose(\"handleRedirectPromise has been called previously, returning the result from the first call\");\r\n            }\r\n            \r\n            return response;\r\n        }\r\n        this.logger.verbose(\"handleRedirectPromise returns null, not browser environment\");\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Checks if navigateToLoginRequestUrl is set, and:\r\n     * - if true, performs logic to cache and navigate\r\n     * - if false, handles hash string and parses response\r\n     * @param hash\r\n     */\r\n    private async handleRedirectResponse(hash?: string): Promise<AuthenticationResult | null> {\r\n        if (!this.interactionInProgress()) {\r\n            this.logger.info(\"handleRedirectPromise called but there is no interaction in progress, returning null.\");\r\n            return null;\r\n        }\r\n\r\n        const responseHash = this.getRedirectResponseHash(hash || window.location.hash);\r\n        if (!responseHash) {\r\n            // Not a recognized server response hash or hash not associated with a redirect request\r\n            this.logger.info(\"handleRedirectPromise did not detect a response hash as a result of a redirect. Cleaning temporary cache.\");\r\n            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\r\n            return null;\r\n        }\r\n\r\n        let state: string;\r\n        try {\r\n            state = this.validateAndExtractStateFromHash(responseHash, InteractionType.Redirect);\r\n            BrowserUtils.clearHash(window);\r\n            this.logger.verbose(\"State extracted from hash\");\r\n        } catch (e) {\r\n            this.logger.info(`handleRedirectPromise was unable to extract state due to: ${e}`);\r\n            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\r\n            return null;\r\n        }\r\n\r\n        // If navigateToLoginRequestUrl is true, get the url where the redirect request was initiated\r\n        const loginRequestUrl = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, true) || \"\";\r\n        const loginRequestUrlNormalized = UrlString.removeHashFromUrl(loginRequestUrl);\r\n        const currentUrlNormalized = UrlString.removeHashFromUrl(window.location.href);\r\n\r\n        if (loginRequestUrlNormalized === currentUrlNormalized && this.config.auth.navigateToLoginRequestUrl) {\r\n            // We are on the page we need to navigate to - handle hash\r\n            this.logger.verbose(\"Current page is loginRequestUrl, handling hash\");\r\n            const handleHashResult = await this.handleHash(responseHash, state);\r\n\r\n            if (loginRequestUrl.indexOf(\"#\") > -1) {\r\n                // Replace current hash with non-msal hash, if present\r\n                BrowserUtils.replaceHash(loginRequestUrl);\r\n            }\r\n\r\n            return handleHashResult;\r\n        } else if (!this.config.auth.navigateToLoginRequestUrl) {\r\n            this.logger.verbose(\"NavigateToLoginRequestUrl set to false, handling hash\");\r\n            return this.handleHash(responseHash, state);\r\n        } else if (!BrowserUtils.isInIframe()) {\r\n            /*\r\n             * Returned from authority using redirect - need to perform navigation before processing response\r\n             * Cache the hash to be retrieved after the next redirect\r\n             */\r\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.URL_HASH, responseHash, true);\r\n            const navigationOptions: NavigationOptions = {\r\n                apiId: ApiId.handleRedirectPromise,\r\n                timeout: this.config.system.redirectNavigationTimeout,\r\n                noHistory: true\r\n            };\r\n\r\n            /**\r\n             * Default behavior is to redirect to the start page and not process the hash now. \r\n             * The start page is expected to also call handleRedirectPromise which will process the hash in one of the checks above.\r\n             */  \r\n            let processHashOnRedirect: boolean = true;\r\n            if (!loginRequestUrl || loginRequestUrl === \"null\") {\r\n                // Redirect to home page if login request url is null (real null or the string null)\r\n                const homepage = BrowserUtils.getHomepage();\r\n                // Cache the homepage under ORIGIN_URI to ensure cached hash is processed on homepage\r\n                this.browserStorage.setTemporaryCache(TemporaryCacheKeys.ORIGIN_URI, homepage, true);\r\n                this.logger.warning(\"Unable to get valid login request url from cache, redirecting to home page\");\r\n                processHashOnRedirect = await this.navigationClient.navigateInternal(homepage, navigationOptions);\r\n            } else {\r\n                // Navigate to page that initiated the redirect request\r\n                this.logger.verbose(`Navigating to loginRequestUrl: ${loginRequestUrl}`);\r\n                processHashOnRedirect = await this.navigationClient.navigateInternal(loginRequestUrl, navigationOptions);\r\n            }\r\n\r\n            // If navigateInternal implementation returns false, handle the hash now\r\n            if (!processHashOnRedirect) {\r\n                return this.handleHash(responseHash, state);\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the response hash for a redirect request\r\n     * Returns null if interactionType in the state value is not \"redirect\" or the hash does not contain known properties\r\n     * @param hash\r\n     */\r\n    private getRedirectResponseHash(hash: string): string | null {\r\n        this.logger.verbose(\"getRedirectResponseHash called\");\r\n        // Get current location hash from window or cache.\r\n        const isResponseHash: boolean = UrlString.hashContainsKnownProperties(hash);\r\n        const cachedHash = this.browserStorage.getTemporaryCache(TemporaryCacheKeys.URL_HASH, true);\r\n        this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.URL_HASH));\r\n\r\n        if (isResponseHash) {\r\n            this.logger.verbose(\"Hash contains known properties, returning response hash\");\r\n            return hash;\r\n        }\r\n\r\n        this.logger.verbose(\"Hash does not contain known properties, returning cached hash\");\r\n        return cachedHash;\r\n    }\r\n\r\n    /**\r\n     * @param hash\r\n     * @param interactionType\r\n     */\r\n    private validateAndExtractStateFromHash(hash: string, interactionType: InteractionType, requestCorrelationId?: string): string {\r\n        this.logger.verbose(\"validateAndExtractStateFromHash called\", requestCorrelationId);\r\n        // Deserialize hash fragment response parameters.\r\n        const serverParams: ServerAuthorizationCodeResponse = UrlString.getDeserializedHash(hash);\r\n        if (!serverParams.state) {\r\n            throw BrowserAuthError.createHashDoesNotContainStateError();\r\n        }\r\n\r\n        const platformStateObj = BrowserProtocolUtils.extractBrowserRequestState(this.browserCrypto, serverParams.state);\r\n        if (!platformStateObj) {\r\n            throw BrowserAuthError.createUnableToParseStateError();\r\n        }\r\n\r\n        if (platformStateObj.interactionType !== interactionType) {\r\n            throw BrowserAuthError.createStateInteractionTypeMismatchError();\r\n        }\r\n\r\n        this.logger.verbose(\"Returning state from hash\", requestCorrelationId);\r\n        return serverParams.state;\r\n    }\r\n\r\n    /**\r\n     * Checks if hash exists and handles in window.\r\n     * @param hash\r\n     * @param state\r\n     */\r\n    private async handleHash(hash: string, state: string): Promise<AuthenticationResult> {\r\n        const cachedRequest = this.browserStorage.getCachedRequest(state, this.browserCrypto);\r\n        const browserRequestLogger = this.logger.clone(name, version, cachedRequest.correlationId);\r\n        browserRequestLogger.verbose(\"handleHash called, retrieved cached request\");\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.handleRedirectPromise, cachedRequest.correlationId);\r\n\r\n        try {\r\n            // Hash contains known properties - handle and return in callback\r\n            const currentAuthority = this.browserStorage.getCachedAuthority(state);\r\n            if (!currentAuthority) {\r\n                throw BrowserAuthError.createNoCachedAuthorityError();\r\n            }\r\n\r\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, currentAuthority, cachedRequest.correlationId);\r\n            browserRequestLogger.verbose(\"Auth code client created\");\r\n            const interactionHandler = new RedirectHandler(authClient, this.browserStorage, cachedRequest, browserRequestLogger, this.browserCrypto);\r\n            return await interactionHandler.handleCodeResponse(hash, state, authClient.authority, this.networkClient, this.config.auth.clientId);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            this.browserStorage.cleanRequestByInteractionType(InteractionType.Redirect);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use when you want to obtain an access_token for your API by redirecting the user's browser window to the authorization endpoint. This function redirects\r\n     * the page, so any code that follows this function will not execute.\r\n     *\r\n     * IMPORTANT: It is NOT recommended to have code that is dependent on the resolution of the Promise. This function will navigate away from the current\r\n     * browser window. It currently returns a Promise in order to reflect the asynchronous nature of the code running in this function.\r\n     *\r\n     * @param request\r\n     */\r\n    async acquireTokenRedirect(request: RedirectRequest): Promise<void> {\r\n        // Preflight request\r\n        this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\r\n        this.logger.verbose(\"acquireTokenRedirect called\");\r\n\r\n        // If logged in, emit acquire token events\r\n        const isLoggedIn = this.getAllAccounts().length > 0;\r\n        if (isLoggedIn) {\r\n            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Redirect, request);\r\n        } else {\r\n            this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Redirect, request);\r\n        }\r\n\r\n        const validRequest: AuthorizationUrlRequest = this.preflightInteractiveRequest(request, InteractionType.Redirect);\r\n        const browserRequestLogger = this.logger.clone(name, version, validRequest.correlationId);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenRedirect, validRequest.correlationId);\r\n\r\n        try {\r\n            // Create auth code request and generate PKCE params\r\n            const authCodeRequest: CommonAuthorizationCodeRequest = await this.initializeAuthorizationCodeRequest(validRequest);\r\n\r\n            // Initialize the client\r\n            const authClient: AuthorizationCodeClient = await this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.correlationId);\r\n            browserRequestLogger.verbose(\"Auth code client created\");\r\n\r\n            // Create redirect interaction handler.\r\n            const interactionHandler = new RedirectHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger, this.browserCrypto);\r\n\r\n            // Create acquire token url.\r\n            const navigateUrl = await authClient.getAuthCodeUrl(validRequest);\r\n\r\n            const redirectStartPage = this.getRedirectStartPage(request.redirectStartPage);\r\n            browserRequestLogger.verbosePii(`Redirect start page: ${redirectStartPage}`);\r\n\r\n            // Show the UI once the url has been created. Response will come back in the hash, which will be handled in the handleRedirectCallback function.\r\n            return interactionHandler.initiateAuthRequest(navigateUrl, {\r\n                navigationClient: this.navigationClient,\r\n                redirectTimeout: this.config.system.redirectNavigationTimeout,\r\n                redirectStartPage: redirectStartPage,\r\n                onRedirectNavigate: request.onRedirectNavigate\r\n            });\r\n        } catch (e) {\r\n            // If logged in, emit acquire token events\r\n            if (isLoggedIn) {\r\n                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Redirect, null, e);\r\n            } else {\r\n                this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Redirect, null, e);\r\n            }\r\n\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            this.browserStorage.cleanRequestByState(validRequest.state);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region Popup Flow\r\n\r\n    /**\r\n     * Use when you want to obtain an access_token for your API via opening a popup window in the user's browser\r\n     *\r\n     * @param request\r\n     *\r\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n     */\r\n    acquireTokenPopup(request: PopupRequest): Promise<AuthenticationResult> {\r\n        let validRequest: AuthorizationUrlRequest;\r\n        try {\r\n            this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\r\n            this.logger.verbose(\"acquireTokenPopup called\", request.correlationId);\r\n            validRequest = this.preflightInteractiveRequest(request, InteractionType.Popup);\r\n        } catch (e) {\r\n            // Since this function is syncronous we need to reject\r\n            return Promise.reject(e);\r\n        }\r\n\r\n        const popupName = PopupUtils.generatePopupName(this.config.auth.clientId, validRequest);\r\n\r\n        // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\r\n        if (this.config.system.asyncPopups) {\r\n            this.logger.verbose(\"asyncPopups set to true, acquiring token\", validRequest.correlationId);\r\n            return this.acquireTokenPopupAsync(validRequest, popupName);\r\n        } else {\r\n            // asyncPopups flag is set to false. Opens popup before acquiring token.\r\n            this.logger.verbose(\"asyncPopup set to false, opening popup before acquiring token\", validRequest.correlationId);\r\n            const popup = PopupUtils.openSizedPopup(\"about:blank\", popupName);\r\n            return this.acquireTokenPopupAsync(validRequest, popupName, popup);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper which obtains an access_token for your API via opening a popup window in the user's browser\r\n     * @param validRequest\r\n     * @param popupName\r\n     * @param popup\r\n     *\r\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n     */\r\n    private async acquireTokenPopupAsync(validRequest: AuthorizationUrlRequest, popupName: string, popup?: Window|null): Promise<AuthenticationResult> {\r\n        this.logger.verbose(\"acquireTokenPopupAsync called\", validRequest.correlationId);\r\n        // If logged in, emit acquire token events\r\n        const loggedInAccounts = this.getAllAccounts();\r\n        if (loggedInAccounts.length > 0) {\r\n            this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_START, InteractionType.Popup, validRequest);\r\n        } else {\r\n            this.eventHandler.emitEvent(EventType.LOGIN_START, InteractionType.Popup, validRequest);\r\n        }\r\n\r\n        const browserRequestLogger = this.logger.clone(name, version, validRequest.correlationId);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenPopup, validRequest.correlationId);\r\n\r\n        try {\r\n            // Create auth code request and generate PKCE params\r\n            const authCodeRequest: CommonAuthorizationCodeRequest = await this.initializeAuthorizationCodeRequest(validRequest);\r\n\r\n            // Initialize the client\r\n            const authClient: AuthorizationCodeClient = await this.createAuthCodeClient(serverTelemetryManager, validRequest.authority, validRequest.correlationId);\r\n            browserRequestLogger.verbose(\"Auth code client created\");\r\n\r\n            // Create acquire token url.\r\n            const navigateUrl = await authClient.getAuthCodeUrl(validRequest);\r\n\r\n            // Create popup interaction handler.\r\n            const interactionHandler = new PopupHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger);\r\n\r\n            // Show the UI once the url has been created. Get the window handle for the popup.\r\n            const popupParameters: PopupParams = {\r\n                popup,\r\n                popupName\r\n            };\r\n            const popupWindow: Window = interactionHandler.initiateAuthRequest(navigateUrl, popupParameters);\r\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {popupWindow}, null);\r\n\r\n            // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\r\n            const hash = await interactionHandler.monitorPopupForHash(popupWindow);\r\n            const state = this.validateAndExtractStateFromHash(hash, InteractionType.Popup, validRequest.correlationId);\r\n\r\n            // Remove throttle if it exists\r\n            ThrottlingUtils.removeThrottle(this.browserStorage, this.config.auth.clientId, authCodeRequest.authority, authCodeRequest.scopes);\r\n\r\n            // Handle response from hash string.\r\n            const result = await interactionHandler.handleCodeResponse(hash, state, authClient.authority, this.networkClient);\r\n\r\n            // If logged in, emit acquire token events\r\n            const isLoggingIn = loggedInAccounts.length < this.getAllAccounts().length;\r\n            if (isLoggingIn) {\r\n                this.eventHandler.emitEvent(EventType.LOGIN_SUCCESS, InteractionType.Popup, result);\r\n            } else {\r\n                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_SUCCESS, InteractionType.Popup, result);\r\n            }\r\n\r\n            return result;\r\n        } catch (e) {\r\n            if (loggedInAccounts.length > 0) {\r\n                this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_FAILURE, InteractionType.Popup, null, e);\r\n            } else {\r\n                this.eventHandler.emitEvent(EventType.LOGIN_FAILURE, InteractionType.Popup, null, e);\r\n            }\r\n            \r\n            if (popup) {\r\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\r\n                popup.close();\r\n            }\r\n\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            this.browserStorage.cleanRequestByState(validRequest.state);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region Silent Flow\r\n\r\n    /**\r\n     * This function uses a hidden iframe to fetch an authorization code from the eSTS. There are cases where this may not work:\r\n     * - Any browser using a form of Intelligent Tracking Prevention\r\n     * - If there is not an established session with the service\r\n     *\r\n     * In these cases, the request must be done inside a popup or full frame redirect.\r\n     *\r\n     * For the cases where interaction is required, you cannot send a request with prompt=none.\r\n     *\r\n     * If your refresh token has expired, you can use this function to fetch a new set of tokens silently as long as\r\n     * you session on the server still exists.\r\n     * @param request {@link SsoSilentRequest}\r\n     *\r\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n     */\r\n    async ssoSilent(request: SsoSilentRequest): Promise<AuthenticationResult> {\r\n        this.preflightBrowserEnvironmentCheck(InteractionType.Silent);\r\n        this.logger.verbose(\"ssoSilent called\", request.correlationId);\r\n        this.eventHandler.emitEvent(EventType.SSO_SILENT_START, InteractionType.Silent, request);\r\n\r\n        try {\r\n            const silentTokenResult = await this.acquireTokenByIframe(request, ApiId.ssoSilent);\r\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_SUCCESS, InteractionType.Silent, silentTokenResult);\r\n            return silentTokenResult;\r\n        } catch (e) {\r\n            this.eventHandler.emitEvent(EventType.SSO_SILENT_FAILURE, InteractionType.Silent, null, e);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This function uses a hidden iframe to fetch an authorization code from the eSTS. To be used for silent refresh token acquisition and renewal.\r\n     * @param request\r\n     * @param apiId - ApiId of the calling function. Used for telemetry.\r\n     */\r\n    private async acquireTokenByIframe(request: SsoSilentRequest, apiId: ApiId): Promise<AuthenticationResult> {\r\n        this.logger.verbose(\"acquireTokenByIframe called\", request.correlationId);\r\n        // Check that we have some SSO data\r\n        if (StringUtils.isEmpty(request.loginHint) && StringUtils.isEmpty(request.sid) && (!request.account || StringUtils.isEmpty(request.account.username))) {\r\n            throw BrowserAuthError.createSilentSSOInsufficientInfoError();\r\n        }\r\n\r\n        // Check that prompt is set to none, throw error if it is set to anything else.\r\n        if (request.prompt && request.prompt !== PromptValue.NONE) {\r\n            throw BrowserAuthError.createSilentPromptValueError(request.prompt);\r\n        }\r\n\r\n        // Create silent request\r\n        const silentRequest: AuthorizationUrlRequest = this.initializeAuthorizationRequest({\r\n            ...request,\r\n            prompt: PromptValue.NONE\r\n        }, InteractionType.Silent);\r\n\r\n        const browserRequestLogger = this.logger.clone(name, version, silentRequest.correlationId);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(apiId, silentRequest.correlationId);\r\n\r\n        try {\r\n            // Create auth code request and generate PKCE params\r\n            const authCodeRequest: CommonAuthorizationCodeRequest = await this.initializeAuthorizationCodeRequest(silentRequest);\r\n\r\n            // Initialize the client\r\n            const authClient: AuthorizationCodeClient = await this.createAuthCodeClient(serverTelemetryManager, silentRequest.authority, silentRequest.correlationId);\r\n            browserRequestLogger.verbose(\"Auth code client created\");\r\n\r\n            // Create authorize request url\r\n            const navigateUrl = await authClient.getAuthCodeUrl(silentRequest);\r\n\r\n            return await this.silentTokenHelper(navigateUrl, authCodeRequest, authClient, browserRequestLogger);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            this.browserStorage.cleanRequestByState(silentRequest.state);\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Use this function to obtain a token before every call to the API / resource provider\r\n     *\r\n     * MSAL return's a cached token when available\r\n     * Or it send's a request to the STS to obtain a new token using a refresh token.\r\n     *\r\n     * @param {@link SilentRequest}\r\n     *\r\n     * To renew idToken, please pass clientId as the only scope in the Authentication Parameters\r\n     * @returns A promise that is fulfilled when this function has completed, or rejected if an error was raised.\r\n     */\r\n    protected async acquireTokenByRefreshToken(request: CommonSilentFlowRequest): Promise<AuthenticationResult> {\r\n        this.eventHandler.emitEvent(EventType.ACQUIRE_TOKEN_NETWORK_START, InteractionType.Silent, request);\r\n        // block the reload if it occurred inside a hidden iframe\r\n        BrowserUtils.blockReloadInHiddenIframes();\r\n        const silentRequest: CommonSilentFlowRequest = {\r\n            ...request,\r\n            ...this.initializeBaseRequest(request)\r\n        };\r\n        const browserRequestLogger = this.logger.clone(name, version, silentRequest.correlationId);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.acquireTokenSilent_silentFlow, silentRequest.correlationId);\r\n        try {\r\n            const refreshTokenClient = await this.createRefreshTokenClient(serverTelemetryManager, silentRequest.authority, silentRequest.correlationId);\r\n            browserRequestLogger.verbose(\"Refresh token client created\");\r\n            \r\n            // Send request to renew token. Auth module will throw errors if token cannot be renewed.\r\n            return await refreshTokenClient.acquireTokenByRefreshToken(silentRequest);\r\n        } catch (e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            const isServerError = e instanceof ServerError;\r\n            const isInteractionRequiredError = e instanceof InteractionRequiredAuthError;\r\n            const isInvalidGrantError = (e.errorCode === BrowserConstants.INVALID_GRANT_ERROR);\r\n            if (isServerError && isInvalidGrantError && !isInteractionRequiredError) {\r\n                browserRequestLogger.verbose(\"Refresh token expired or invalid, attempting acquire token by iframe\");\r\n                return await this.acquireTokenByIframe(request, ApiId.acquireTokenSilent_authCode);\r\n            }\r\n            throw e;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper which acquires an authorization code silently using a hidden iframe from given url\r\n     * using the scopes requested as part of the id, and exchanges the code for a set of OAuth tokens.\r\n     * @param navigateUrl\r\n     * @param userRequestScopes\r\n     */\r\n    private async silentTokenHelper(navigateUrl: string, authCodeRequest: CommonAuthorizationCodeRequest, authClient: AuthorizationCodeClient, browserRequestLogger: Logger): Promise<AuthenticationResult> {\r\n        // Create silent handler\r\n        const silentHandler = new SilentHandler(authClient, this.browserStorage, authCodeRequest, browserRequestLogger, this.config.system.navigateFrameWait);\r\n        // Get the frame handle for the silent request\r\n        const msalFrame = await silentHandler.initiateAuthRequest(navigateUrl);\r\n        // Monitor the window for the hash. Return the string value and close the popup when the hash is received. Default timeout is 60 seconds.\r\n        const hash = await silentHandler.monitorIframeForHash(msalFrame, this.config.system.iframeHashTimeout);\r\n        const state = this.validateAndExtractStateFromHash(hash, InteractionType.Silent, authCodeRequest.correlationId);\r\n\r\n        // Handle response from hash string\r\n        return silentHandler.handleCodeResponse(hash, state, authClient.authority, this.networkClient);\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region Logout\r\n\r\n    /**\r\n     * Deprecated logout function. Use logoutRedirect or logoutPopup instead\r\n     * @param logoutRequest \r\n     * @deprecated\r\n     */\r\n    async logout(logoutRequest?: EndSessionRequest): Promise<void> {\r\n        this.logger.warning(\"logout API is deprecated and will be removed in msal-browser v3.0.0. Use logoutRedirect instead.\");\r\n        return this.logoutRedirect(logoutRequest);\r\n    }\r\n\r\n    /**\r\n     * Use to log out the current user, and redirect the user to the postLogoutRedirectUri.\r\n     * Default behaviour is to redirect the user to `window.location.href`.\r\n     * @param logoutRequest\r\n     */\r\n    async logoutRedirect(logoutRequest?: EndSessionRequest): Promise<void> {\r\n        this.preflightBrowserEnvironmentCheck(InteractionType.Redirect);\r\n        this.logger.verbose(\"logoutRedirect called\", logoutRequest?.correlationId);\r\n        const validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\r\n        const browserRequestLogger = this.logger.clone(name, version, validLogoutRequest.correlationId);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logout, validLogoutRequest.correlationId);\r\n\r\n        try {\r\n            this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Redirect, logoutRequest);\r\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, logoutRequest && logoutRequest.authority, validLogoutRequest?.correlationId);\r\n            browserRequestLogger.verbose(\"Auth code client created\");\r\n\r\n            // create logout string and navigate user window to logout. Auth module will clear cache.\r\n            const logoutUri: string = authClient.getLogoutUri(validLogoutRequest);\r\n            \r\n            if (!validLogoutRequest.account || AccountEntity.accountInfoIsEqual(validLogoutRequest.account, this.getActiveAccount(), false)) {\r\n                browserRequestLogger.verbose(\"Setting active account to null\");\r\n                this.setActiveAccount(null);\r\n            }\r\n            \r\n            const navigationOptions: NavigationOptions = {\r\n                apiId: ApiId.logout,\r\n                timeout: this.config.system.redirectNavigationTimeout,\r\n                noHistory: false\r\n            };\r\n            \r\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Redirect, validLogoutRequest);\r\n            // Check if onRedirectNavigate is implemented, and invoke it if so\r\n            if (logoutRequest && typeof logoutRequest.onRedirectNavigate === \"function\") {\r\n                const navigate = logoutRequest.onRedirectNavigate(logoutUri);\r\n\r\n                if (navigate !== false) {\r\n                    browserRequestLogger.verbose(\"Logout onRedirectNavigate did not return false, navigating\");\r\n                    await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\r\n                    return;\r\n                } else {\r\n                    browserRequestLogger.verbose(\"Logout onRedirectNavigate returned false, stopping navigation\");\r\n                }\r\n            } else {\r\n                await this.navigationClient.navigateExternal(logoutUri, navigationOptions);\r\n                return;\r\n            }\r\n        } catch(e) {\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Redirect, null, e);\r\n            throw e;\r\n        }\r\n\r\n        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Redirect);\r\n    }\r\n\r\n    /**\r\n     * Clears local cache for the current user then opens a popup window prompting the user to sign-out of the server\r\n     * @param logoutRequest \r\n     */\r\n    logoutPopup(logoutRequest?: EndSessionPopupRequest): Promise<void> {\r\n        let validLogoutRequest: CommonEndSessionRequest;\r\n        try {\r\n            this.preflightBrowserEnvironmentCheck(InteractionType.Popup);\r\n            this.logger.verbose(\"logoutPopup called\", logoutRequest?.correlationId);\r\n            validLogoutRequest = this.initializeLogoutRequest(logoutRequest);\r\n        } catch (e) {\r\n            // Since this function is synchronous we need to reject\r\n            return Promise.reject(e);\r\n        }\r\n\r\n        const popupName = PopupUtils.generateLogoutPopupName(this.config.auth.clientId, validLogoutRequest);\r\n        let popup;\r\n\r\n        // asyncPopups flag is true. Acquires token without first opening popup. Popup will be opened later asynchronously.\r\n        if (this.config.system.asyncPopups) {\r\n            this.logger.verbose(\"asyncPopups set to true\", validLogoutRequest.correlationId);\r\n        } else {\r\n            // asyncPopups flag is set to false. Opens popup before logging out.\r\n            this.logger.verbose(\"asyncPopup set to false, opening popup\", validLogoutRequest.correlationId);\r\n            popup = PopupUtils.openSizedPopup(\"about:blank\", popupName);\r\n        }\r\n\r\n        const authority = logoutRequest && logoutRequest.authority;\r\n        const mainWindowRedirectUri = logoutRequest && logoutRequest.mainWindowRedirectUri;\r\n        return this.logoutPopupAsync(validLogoutRequest, popupName, authority, popup, mainWindowRedirectUri);\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param request \r\n     * @param popupName \r\n     * @param requestAuthority\r\n     * @param popup \r\n     */\r\n    private async logoutPopupAsync(validRequest: CommonEndSessionRequest, popupName: string, requestAuthority?: string, popup?: Window|null, mainWindowRedirectUri?: string): Promise<void> {\r\n        this.logger.verbose(\"logoutPopupAsync called\", validRequest.correlationId);\r\n        this.eventHandler.emitEvent(EventType.LOGOUT_START, InteractionType.Popup, validRequest);\r\n\r\n        const browserRequestLogger = this.logger.clone(name, version, validRequest.correlationId);\r\n        const serverTelemetryManager = this.initializeServerTelemetryManager(ApiId.logoutPopup, validRequest.correlationId);\r\n        \r\n        try {\r\n            this.browserStorage.setTemporaryCache(TemporaryCacheKeys.INTERACTION_STATUS_KEY, BrowserConstants.INTERACTION_IN_PROGRESS_VALUE, true);\r\n            // Initialize the client\r\n            const authClient = await this.createAuthCodeClient(serverTelemetryManager, requestAuthority, validRequest.correlationId);\r\n            browserRequestLogger.verbose(\"Auth code client created\");\r\n\r\n            // create logout string and navigate user window to logout. Auth module will clear cache.\r\n            const logoutUri: string = authClient.getLogoutUri(validRequest);\r\n            if (!validRequest.account || AccountEntity.accountInfoIsEqual(validRequest.account, this.getActiveAccount(), false)) {\r\n                browserRequestLogger.verbose(\"Setting active account to null\");\r\n                this.setActiveAccount(null);\r\n            }\r\n\r\n            this.eventHandler.emitEvent(EventType.LOGOUT_SUCCESS, InteractionType.Popup, validRequest);\r\n\r\n            const popupUtils = new PopupUtils(this.browserStorage, this.logger);\r\n            // Open the popup window to requestUrl.\r\n            const popupWindow = popupUtils.openPopup(logoutUri, popupName, popup);\r\n            this.eventHandler.emitEvent(EventType.POPUP_OPENED, InteractionType.Popup, {popupWindow}, null);\r\n\r\n            try {\r\n                // Don't care if this throws an error (User Cancelled)\r\n                await popupUtils.monitorPopupForSameOrigin(popupWindow);\r\n                browserRequestLogger.verbose(\"Popup successfully redirected to postLogoutRedirectUri\");\r\n            } catch (e) {\r\n                browserRequestLogger.verbose(`Error occurred while monitoring popup for same origin. Session on server may remain active. Error: ${e}`);\r\n            }\r\n\r\n            popupUtils.cleanPopup(popupWindow);\r\n\r\n            if (mainWindowRedirectUri) {\r\n                const navigationOptions: NavigationOptions = {\r\n                    apiId: ApiId.logoutPopup,\r\n                    timeout: this.config.system.redirectNavigationTimeout,\r\n                    noHistory: false\r\n                };\r\n                const absoluteUrl = UrlString.getAbsoluteUrl(mainWindowRedirectUri, BrowserUtils.getCurrentUri());\r\n\r\n                browserRequestLogger.verbose(\"Redirecting main window to url specified in the request\");\r\n                browserRequestLogger.verbosePii(`Redirecing main window to: ${absoluteUrl}`);\r\n                this.navigationClient.navigateInternal(absoluteUrl, navigationOptions);\r\n            } else {\r\n                browserRequestLogger.verbose(\"No main window navigation requested\");\r\n            }\r\n\r\n        } catch (e) {\r\n            if (popup) {\r\n                // Close the synchronous popup if an error is thrown before the window unload event is registered\r\n                popup.close();\r\n            }\r\n            \r\n            this.browserStorage.removeItem(this.browserStorage.generateCacheKey(TemporaryCacheKeys.INTERACTION_STATUS_KEY));\r\n            this.eventHandler.emitEvent(EventType.LOGOUT_FAILURE, InteractionType.Popup, null, e);\r\n            serverTelemetryManager.cacheFailedRequest(e);\r\n            throw e;\r\n        }\r\n\r\n        this.eventHandler.emitEvent(EventType.LOGOUT_END, InteractionType.Popup);\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region Account APIs\r\n\r\n    /**\r\n     * Returns all accounts that MSAL currently has data for.\r\n     * (the account object is created at the time of successful login)\r\n     * or empty array when no accounts are found\r\n     * @returns Array of account objects in cache\r\n     */\r\n    getAllAccounts(): AccountInfo[] {\r\n        this.logger.verbose(\"getAllAccounts called\");\r\n        return this.isBrowserEnvironment ? this.browserStorage.getAllAccounts() : [];\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching username.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found.\r\n     * This API is provided for convenience but getAccountById should be used for best reliability\r\n     * @param userName\r\n     * @returns The account object stored in MSAL\r\n     */\r\n    getAccountByUsername(userName: string): AccountInfo|null {\r\n        const allAccounts = this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(userName) && allAccounts && allAccounts.length) {\r\n            this.logger.verbose(\"Account matching username found, returning\");\r\n            this.logger.verbosePii(`Returning signed-in accounts matching username: ${userName}`);\r\n            return allAccounts.filter(accountObj => accountObj.username.toLowerCase() === userName.toLowerCase())[0] || null;\r\n        } else {\r\n            this.logger.verbose(\"getAccountByUsername: No matching account found, returning null\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching homeAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param homeAccountId\r\n     * @returns The account object stored in MSAL\r\n     */\r\n    getAccountByHomeId(homeAccountId: string): AccountInfo|null {\r\n        const allAccounts = this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(homeAccountId) && allAccounts && allAccounts.length) {\r\n            this.logger.verbose(\"Account matching homeAccountId found, returning\");\r\n            this.logger.verbosePii(`Returning signed-in accounts matching homeAccountId: ${homeAccountId}`);\r\n            return allAccounts.filter(accountObj => accountObj.homeAccountId === homeAccountId)[0] || null;\r\n        } else {\r\n            this.logger.verbose(\"getAccountByHomeId: No matching account found, returning null\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the signed in account matching localAccountId.\r\n     * (the account object is created at the time of successful login)\r\n     * or null when no matching account is found\r\n     * @param localAccountId\r\n     * @returns The account object stored in MSAL\r\n     */\r\n    getAccountByLocalId(localAccountId: string): AccountInfo | null {\r\n        const allAccounts = this.getAllAccounts();\r\n        if (!StringUtils.isEmpty(localAccountId) && allAccounts && allAccounts.length) {\r\n            this.logger.verbose(\"Account matching localAccountId found, returning\");\r\n            this.logger.verbosePii(`Returning signed-in accounts matching localAccountId: ${localAccountId}`);\r\n            return allAccounts.filter(accountObj => accountObj.localAccountId === localAccountId)[0] || null;\r\n        } else {\r\n            this.logger.verbose(\"getAccountByLocalId: No matching account found, returning null\");\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the account to use as the active account. If no account is passed to the acquireToken APIs, then MSAL will use this active account.\r\n     * @param account\r\n     */\r\n    setActiveAccount(account: AccountInfo | null): void {\r\n        this.browserStorage.setActiveAccount(account);\r\n    }\r\n\r\n    /**\r\n     * Gets the currently active account\r\n     */\r\n    getActiveAccount(): AccountInfo | null {\r\n        return this.browserStorage.getActiveAccount();\r\n    }\r\n\r\n    // #endregion\r\n\r\n    // #region Helpers\r\n\r\n    /**\r\n     *\r\n     * Use to get the redirect uri configured in MSAL or null.\r\n     * @param requestRedirectUri\r\n     * @returns Redirect URL\r\n     *\r\n     */\r\n    protected getRedirectUri(requestRedirectUri?: string): string {\r\n        this.logger.verbose(\"getRedirectUri called\");\r\n        const redirectUri = requestRedirectUri || this.config.auth.redirectUri || BrowserUtils.getCurrentUri();\r\n        return UrlString.getAbsoluteUrl(redirectUri, BrowserUtils.getCurrentUri());\r\n    }\r\n\r\n    /**\r\n     * Use to get the redirectStartPage either from request or use current window\r\n     * @param requestStartPage\r\n     */\r\n    protected getRedirectStartPage(requestStartPage?: string): string {\r\n        const redirectStartPage = requestStartPage || window.location.href;\r\n        return UrlString.getAbsoluteUrl(redirectStartPage, BrowserUtils.getCurrentUri());\r\n    }\r\n\r\n    /**\r\n     * Used to get a discovered version of the default authority.\r\n     * @param requestAuthority\r\n     * @param requestCorrelationId\r\n     */\r\n    async getDiscoveredAuthority(requestAuthority?: string, requestCorrelationId?: string): Promise<Authority> {\r\n        this.logger.verbose(\"getDiscoveredAuthority called\", requestCorrelationId);\r\n        const authorityOptions: AuthorityOptions = {\r\n            protocolMode: this.config.auth.protocolMode,\r\n            knownAuthorities: this.config.auth.knownAuthorities,\r\n            cloudDiscoveryMetadata: this.config.auth.cloudDiscoveryMetadata,\r\n            authorityMetadata: this.config.auth.authorityMetadata\r\n        };\r\n\r\n        if (requestAuthority) {\r\n            this.logger.verbose(\"Creating discovered authority with request authority\", requestCorrelationId);\r\n            return await AuthorityFactory.createDiscoveredInstance(requestAuthority, this.config.system.networkClient, this.browserStorage, authorityOptions);\r\n        }\r\n\r\n        this.logger.verbose(\"Creating discovered authority with configured authority\", requestCorrelationId);\r\n        return await AuthorityFactory.createDiscoveredInstance(this.config.auth.authority, this.config.system.networkClient, this.browserStorage, authorityOptions);\r\n    }\r\n\r\n    /**\r\n     * Helper to check whether interaction is in progress.\r\n     */\r\n    protected interactionInProgress(): boolean {\r\n        // Check whether value in cache is present and equal to expected value\r\n        return (this.browserStorage.getTemporaryCache(TemporaryCacheKeys.INTERACTION_STATUS_KEY, true)) === BrowserConstants.INTERACTION_IN_PROGRESS_VALUE;\r\n    }\r\n\r\n    /**\r\n     * Creates an Authorization Code Client with the given authority, or the default authority.\r\n     * @param serverTelemetryManager\r\n     * @param authorityUrl\r\n     */\r\n    protected async createAuthCodeClient(serverTelemetryManager: ServerTelemetryManager, authorityUrl?: string, correlationId?: string): Promise<AuthorizationCodeClient> {\r\n        // Create auth module.\r\n        const clientConfig = await this.getClientConfiguration(serverTelemetryManager, authorityUrl, correlationId);\r\n        return new AuthorizationCodeClient(clientConfig);\r\n    }\r\n\r\n    /**\r\n     * Creates an Silent Flow Client with the given authority, or the default authority.\r\n     * @param serverTelemetryManager\r\n     * @param authorityUrl\r\n     */\r\n    protected async createSilentFlowClient(serverTelemetryManager: ServerTelemetryManager, authorityUrl?: string, correlationId?: string): Promise<SilentFlowClient> {\r\n        // Create auth module.\r\n        const clientConfig = await this.getClientConfiguration(serverTelemetryManager, authorityUrl, correlationId);\r\n        return new SilentFlowClient(clientConfig);\r\n    }\r\n\r\n    /**\r\n     * Creates a Refresh Client with the given authority, or the default authority.\r\n     * @param serverTelemetryManager\r\n     * @param authorityUrl\r\n     */\r\n    protected async createRefreshTokenClient(serverTelemetryManager: ServerTelemetryManager, authorityUrl?: string, correlationId?: string): Promise<RefreshTokenClient> {\r\n        // Create auth module.\r\n        const clientConfig = await this.getClientConfiguration(serverTelemetryManager, authorityUrl, correlationId);\r\n        return new RefreshTokenClient(clientConfig);\r\n    }\r\n\r\n    /**\r\n     * Creates a Client Configuration object with the given request authority, or the default authority.\r\n     * @param serverTelemetryManager\r\n     * @param requestAuthority\r\n     * @param requestCorrelationId\r\n     */\r\n    protected async getClientConfiguration(serverTelemetryManager: ServerTelemetryManager, requestAuthority?: string, requestCorrelationId?: string): Promise<ClientConfiguration> {\r\n        this.logger.verbose(\"getClientConfiguration called\", requestCorrelationId);\r\n        const discoveredAuthority = await this.getDiscoveredAuthority(requestAuthority, requestCorrelationId);\r\n\r\n        return {\r\n            authOptions: {\r\n                clientId: this.config.auth.clientId,\r\n                authority: discoveredAuthority,\r\n                clientCapabilities: this.config.auth.clientCapabilities\r\n            },\r\n            systemOptions: {\r\n                tokenRenewalOffsetSeconds: this.config.system.tokenRenewalOffsetSeconds,\r\n                preventCorsPreflight: true\r\n            },\r\n            loggerOptions: {\r\n                loggerCallback: this.config.system.loggerOptions.loggerCallback,\r\n                piiLoggingEnabled: this.config.system.loggerOptions.piiLoggingEnabled,\r\n                logLevel: this.config.system.loggerOptions.logLevel,\r\n                correlationId: requestCorrelationId\r\n            },\r\n            cryptoInterface: this.browserCrypto,\r\n            networkInterface: this.networkClient,\r\n            storageInterface: this.browserStorage,\r\n            serverTelemetryManager: serverTelemetryManager,\r\n            libraryInfo: {\r\n                sku: BrowserConstants.MSAL_SKU,\r\n                version: version,\r\n                cpu: \"\",\r\n                os: \"\"\r\n            }\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Helper to validate app environment before making a request.\r\n     * @param request\r\n     * @param interactionType\r\n     */\r\n    protected preflightInteractiveRequest(request: RedirectRequest|PopupRequest, interactionType: InteractionType): AuthorizationUrlRequest {\r\n        this.logger.verbose(\"preflightInteractiveRequest called, validating app environment\", request?.correlationId);\r\n        // block the reload if it occurred inside a hidden iframe\r\n        BrowserUtils.blockReloadInHiddenIframes();\r\n\r\n        // Check if interaction is in progress. Throw error if true.\r\n        if (this.interactionInProgress()) {\r\n            throw BrowserAuthError.createInteractionInProgressError();\r\n        }\r\n\r\n        return this.initializeAuthorizationRequest(request, interactionType);\r\n    }\r\n\r\n    /**\r\n     * Helper to validate app environment before making an auth request\r\n     * * @param interactionType\r\n     */\r\n    protected preflightBrowserEnvironmentCheck(interactionType: InteractionType): void {\r\n        this.logger.verbose(\"preflightBrowserEnvironmentCheck started\");\r\n        // Block request if not in browser environment\r\n        BrowserUtils.blockNonBrowserEnvironment(this.isBrowserEnvironment);\r\n\r\n        // Block redirects if in an iframe\r\n        BrowserUtils.blockRedirectInIframe(interactionType, this.config.system.allowRedirectInIframe);\r\n\r\n        // Block auth requests inside a hidden iframe\r\n        BrowserUtils.blockReloadInHiddenIframes();\r\n\r\n        // Block redirectUri opened in a popup from calling MSAL APIs\r\n        BrowserUtils.blockAcquireTokenInPopups();\r\n\r\n        // Block redirects if memory storage is enabled but storeAuthStateInCookie is not\r\n        if (interactionType === InteractionType.Redirect &&\r\n            this.config.cache.cacheLocation === BrowserCacheLocation.MemoryStorage &&\r\n            !this.config.cache.storeAuthStateInCookie) {\r\n            throw BrowserConfigurationAuthError.createInMemoryRedirectUnavailableError();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initializer function for all request APIs\r\n     * @param request\r\n     */\r\n    protected initializeBaseRequest(request: Partial<BaseAuthRequest>): BaseAuthRequest {\r\n        this.logger.verbose(\"Initializing BaseAuthRequest\", request.correlationId);\r\n        const authority = request.authority || this.config.auth.authority;\r\n\r\n        const scopes = [...((request && request.scopes) || [])];\r\n        const correlationId = (request && request.correlationId) || this.browserCrypto.createNewGuid();\r\n\r\n        // Set authenticationScheme to BEARER if not explicitly set in the request\r\n        if (!request.authenticationScheme) {\r\n            request.authenticationScheme = AuthenticationScheme.BEARER;\r\n            this.logger.verbose(\"Authentication Scheme wasn't explicitly set in request, defaulting to \\\"Bearer\\\" request\", request.correlationId);\r\n        } else {\r\n            this.logger.verbose(`Authentication Scheme set to \"${request.authenticationScheme}\" as configured in Auth request`, request.correlationId);\r\n        }\r\n\r\n        const validatedRequest: BaseAuthRequest = {\r\n            ...request,\r\n            correlationId,\r\n            authority,\r\n            scopes\r\n        };\r\n\r\n        return validatedRequest;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @param apiId\r\n     * @param correlationId\r\n     * @param forceRefresh\r\n     */\r\n    protected initializeServerTelemetryManager(apiId: number, correlationId: string, forceRefresh?: boolean): ServerTelemetryManager {\r\n        this.logger.verbose(\"initializeServerTelemetryManager called\", correlationId);\r\n        const telemetryPayload: ServerTelemetryRequest = {\r\n            clientId: this.config.auth.clientId,\r\n            correlationId: correlationId,\r\n            apiId: apiId,\r\n            forceRefresh: forceRefresh || false,\r\n            wrapperSKU: this.wrapperSKU,\r\n            wrapperVer: this.wrapperVer\r\n        };\r\n\r\n        return new ServerTelemetryManager(telemetryPayload, this.browserStorage);\r\n    }\r\n\r\n    /**\r\n     * Helper to initialize required request parameters for interactive APIs and ssoSilent()\r\n     * @param request\r\n     * @param interactionType\r\n     */\r\n    protected initializeAuthorizationRequest(request: RedirectRequest|PopupRequest|SsoSilentRequest, interactionType: InteractionType): AuthorizationUrlRequest {\r\n        this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\r\n        const redirectUri = this.getRedirectUri(request.redirectUri);\r\n        const browserState: BrowserStateObject = {\r\n            interactionType: interactionType\r\n        };\r\n\r\n        const state = ProtocolUtils.setRequestState(\r\n            this.browserCrypto,\r\n            (request && request.state) || \"\",\r\n            browserState\r\n        );\r\n\r\n        const validatedRequest: AuthorizationUrlRequest = {\r\n            ...this.initializeBaseRequest(request),\r\n            redirectUri: redirectUri,\r\n            state: state,\r\n            nonce: request.nonce || this.browserCrypto.createNewGuid(),\r\n            responseMode: ResponseMode.FRAGMENT\r\n        };\r\n\r\n        const account = request.account || this.getActiveAccount();\r\n        if (account) {\r\n            this.logger.verbose(\"Setting validated request account\");\r\n            this.logger.verbosePii(`Setting validated request account: ${account}`);\r\n            validatedRequest.account = account;\r\n        }\r\n\r\n        // Check for ADAL SSO\r\n        if (StringUtils.isEmpty(validatedRequest.loginHint)) {\r\n            // Only check for adal token if no SSO params are being used\r\n            const adalIdTokenString = this.browserStorage.getTemporaryCache(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n            if (adalIdTokenString) {\r\n                const adalIdToken = new IdToken(adalIdTokenString, this.browserCrypto);\r\n                this.browserStorage.removeItem(PersistentCacheKeys.ADAL_ID_TOKEN);\r\n                if (adalIdToken.claims && adalIdToken.claims.upn) {\r\n                    this.logger.verbose(\"No SSO params used and ADAL token retrieved, setting ADAL upn as loginHint\");\r\n                    validatedRequest.loginHint = adalIdToken.claims.upn;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.browserStorage.updateCacheEntries(validatedRequest.state, validatedRequest.nonce, validatedRequest.authority, validatedRequest.loginHint || \"\", validatedRequest.account || null);\r\n\r\n        return validatedRequest;\r\n    }\r\n\r\n    /**\r\n     * Generates an auth code request tied to the url request.\r\n     * @param request\r\n     */\r\n    protected async initializeAuthorizationCodeRequest(request: AuthorizationUrlRequest): Promise<CommonAuthorizationCodeRequest> {\r\n        this.logger.verbose(\"initializeAuthorizationRequest called\", request.correlationId);\r\n        const generatedPkceParams = await this.browserCrypto.generatePkceCodes();\r\n\r\n        const authCodeRequest: CommonAuthorizationCodeRequest = {\r\n            ...request,\r\n            redirectUri: request.redirectUri,\r\n            code: \"\",\r\n            codeVerifier: generatedPkceParams.verifier\r\n        };\r\n\r\n        request.codeChallenge = generatedPkceParams.challenge;\r\n        request.codeChallengeMethod = Constants.S256_CODE_CHALLENGE_METHOD;\r\n\r\n        return authCodeRequest;\r\n    }\r\n\r\n    /**\r\n     * Initializer for the logout request.\r\n     * @param logoutRequest\r\n     */\r\n    protected initializeLogoutRequest(logoutRequest?: EndSessionRequest): CommonEndSessionRequest {\r\n        this.logger.verbose(\"initializeLogoutRequest called\", logoutRequest?.correlationId);\r\n\r\n        // Check if interaction is in progress. Throw error if true.\r\n        if (this.interactionInProgress()) {\r\n            throw BrowserAuthError.createInteractionInProgressError();\r\n        }\r\n\r\n        const validLogoutRequest: CommonEndSessionRequest = {\r\n            correlationId: this.browserCrypto.createNewGuid(),\r\n            ...logoutRequest\r\n        };\r\n\r\n        /*\r\n         * Only set redirect uri if logout request isn't provided or the set uri isn't null.\r\n         * Otherwise, use passed uri, config, or current page.\r\n         */\r\n        if (!logoutRequest || logoutRequest.postLogoutRedirectUri !== null) {\r\n            if (logoutRequest && logoutRequest.postLogoutRedirectUri) {\r\n                this.logger.verbose(\"Setting postLogoutRedirectUri to uri set on logout request\", validLogoutRequest.correlationId);\r\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(logoutRequest.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\r\n            } else if (this.config.auth.postLogoutRedirectUri === null) {\r\n                this.logger.verbose(\"postLogoutRedirectUri configured as null and no uri set on request, not passing post logout redirect\", validLogoutRequest.correlationId);\r\n            } else if (this.config.auth.postLogoutRedirectUri) {\r\n                this.logger.verbose(\"Setting postLogoutRedirectUri to configured uri\", validLogoutRequest.correlationId);\r\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(this.config.auth.postLogoutRedirectUri, BrowserUtils.getCurrentUri());\r\n            } else {\r\n                this.logger.verbose(\"Setting postLogoutRedirectUri to current page\", validLogoutRequest.correlationId);\r\n                validLogoutRequest.postLogoutRedirectUri = UrlString.getAbsoluteUrl(BrowserUtils.getCurrentUri(), BrowserUtils.getCurrentUri());\r\n            }\r\n        } else {\r\n            this.logger.verbose(\"postLogoutRedirectUri passed as null, not setting post logout redirect uri\", validLogoutRequest.correlationId);\r\n        }\r\n\r\n        return validLogoutRequest;\r\n    }\r\n\r\n    /**\r\n     * Adds event callbacks to array\r\n     * @param callback\r\n     */\r\n    addEventCallback(callback: EventCallbackFunction): string | null {\r\n        return this.eventHandler.addEventCallback(callback);\r\n    }\r\n\r\n    /**\r\n     * Removes callback with provided id from callback array\r\n     * @param callbackId\r\n     */\r\n    removeEventCallback(callbackId: string): void {\r\n        this.eventHandler.removeEventCallback(callbackId);\r\n    }\r\n\r\n    /**\r\n     * Returns the logger instance\r\n     */\r\n    getLogger(): Logger {\r\n        return this.logger;\r\n    }\r\n\r\n    /**\r\n     * Replaces the default logger set in configurations with new Logger with new configurations\r\n     * @param logger Logger instance\r\n     */\r\n    setLogger(logger: Logger): void {\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Called by wrapper libraries (Angular & React) to set SKU and Version passed down to telemetry, logger, etc.\r\n     * @param sku\r\n     * @param version\r\n     */\r\n    initializeWrapperLibrary(sku: WrapperSKU, version: string): void {\r\n        // Validate the SKU passed in is one we expect\r\n        this.wrapperSKU = sku;\r\n        this.wrapperVer = version;\r\n    }\r\n\r\n    /**\r\n     * Sets navigation client\r\n     * @param navigationClient\r\n     */\r\n    setNavigationClient(navigationClient: INavigationClient): void {\r\n        this.navigationClient = navigationClient;\r\n    }\r\n    // #endregion\r\n}\r\n"]},"metadata":{},"sourceType":"module"}