{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { Range } from \"../Range\";\n/**\r\n * @class\r\n * Class representing LargeFileUploadTask\r\n */\n\nexport class LargeFileUploadTask {\n  /**\r\n   * @public\r\n   * @constructor\r\n   * Constructs a LargeFileUploadTask\r\n   * @param {Client} client - The GraphClient instance\r\n   * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\r\n   * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\r\n   * @param {LargeFileUploadTaskOptions} options - The upload task options\r\n   * @returns An instance of LargeFileUploadTask\r\n   */\n  constructor(client, file, uploadSession, options = {}) {\n    /**\r\n     * @private\r\n     * Default value for the rangeSize\r\n     */\n    this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;\n    this.client = client;\n    this.file = file;\n\n    if (options.rangeSize === undefined) {\n      options.rangeSize = this.DEFAULT_FILE_SIZE;\n    }\n\n    this.options = options;\n    this.uploadSession = uploadSession;\n    this.nextRange = new Range(0, this.options.rangeSize - 1);\n  }\n  /**\r\n   * @public\r\n   * @static\r\n   * @async\r\n   * Makes request to the server to create an upload session\r\n   * @param {Client} client - The GraphClient instance\r\n   * @param {any} payload - The payload that needs to be sent\r\n   * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent\r\n   * @returns The promise that resolves to LargeFileUploadSession\r\n   */\n\n\n  static createUploadSession(client, requestUrl, payload, headers = {}) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const session = yield client.api(requestUrl).headers(headers).post(payload);\n        const largeFileUploadSession = {\n          url: session.uploadUrl,\n          expiry: new Date(session.expirationDateTime)\n        };\n        return largeFileUploadSession;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @private\r\n   * Parses given range string to the Range instance\r\n   * @param {string[]} ranges - The ranges value\r\n   * @returns The range instance\r\n   */\n\n\n  parseRange(ranges) {\n    const rangeStr = ranges[0];\n\n    if (typeof rangeStr === \"undefined\" || rangeStr === \"\") {\n      return new Range();\n    }\n\n    const firstRange = rangeStr.split(\"-\");\n    const minVal = parseInt(firstRange[0], 10);\n    let maxVal = parseInt(firstRange[1], 10);\n\n    if (Number.isNaN(maxVal)) {\n      maxVal = this.file.size - 1;\n    }\n\n    return new Range(minVal, maxVal);\n  }\n  /**\r\n   * @private\r\n   * Updates the expiration date and the next range\r\n   * @param {UploadStatusResponse} response - The response of the upload status\r\n   * @returns Nothing\r\n   */\n\n\n  updateTaskStatus(response) {\n    this.uploadSession.expiry = new Date(response.expirationDateTime);\n    this.nextRange = this.parseRange(response.nextExpectedRanges);\n  }\n  /**\r\n   * @public\r\n   * Gets next range that needs to be uploaded\r\n   * @returns The range instance\r\n   */\n\n\n  getNextRange() {\n    if (this.nextRange.minValue === -1) {\n      return this.nextRange;\n    }\n\n    const minVal = this.nextRange.minValue;\n    let maxValue = minVal + this.options.rangeSize - 1;\n\n    if (maxValue >= this.file.size) {\n      maxValue = this.file.size - 1;\n    }\n\n    return new Range(minVal, maxValue);\n  }\n  /**\r\n   * @public\r\n   * Slices the file content to the given range\r\n   * @param {Range} range - The range value\r\n   * @returns The sliced ArrayBuffer or Blob\r\n   */\n\n\n  sliceFile(range) {\n    const blob = this.file.content.slice(range.minValue, range.maxValue + 1);\n    return blob;\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Uploads file to the server in a sequential order by slicing the file\r\n   * @returns The promise resolves to uploaded response\r\n   */\n\n\n  upload() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        while (true) {\n          const nextRange = this.getNextRange();\n\n          if (nextRange.maxValue === -1) {\n            const err = new Error(\"Task with which you are trying to upload is already completed, Please check for your uploaded file\");\n            err.name = \"Invalid Session\";\n            throw err;\n          }\n\n          const fileSlice = this.sliceFile(nextRange);\n          const response = yield this.uploadSlice(fileSlice, nextRange, this.file.size); // Upon completion of upload process incase of onedrive, driveItem is returned, which contains id\n\n          if (response.id !== undefined) {\n            return response;\n          } else {\n            this.updateTaskStatus(response);\n          }\n        }\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Uploads given slice to the server\r\n   * @param {ArrayBuffer | Blob | File} fileSlice - The file slice\r\n   * @param {Range} range - The range value\r\n   * @param {number} totalSize - The total size of a complete file\r\n   */\n\n\n  uploadSlice(fileSlice, range, totalSize) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.client.api(this.uploadSession.url).headers({\n          \"Content-Length\": `${range.maxValue - range.minValue + 1}`,\n          \"Content-Range\": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`\n        }).put(fileSlice);\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Deletes upload session in the server\r\n   * @returns The promise resolves to cancelled response\r\n   */\n\n\n  cancel() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        return yield this.client.api(this.uploadSession.url).delete();\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Gets status for the upload session\r\n   * @returns The promise resolves to the status enquiry response\r\n   */\n\n\n  getStatus() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        const response = yield this.client.api(this.uploadSession.url).get();\n        this.updateTaskStatus(response);\n        return response;\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n  /**\r\n   * @public\r\n   * @async\r\n   * Resumes upload session and continue uploading the file from the last sent range\r\n   * @returns The promise resolves to the uploaded response\r\n   */\n\n\n  resume() {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        yield this.getStatus();\n        return yield this.upload();\n      } catch (err) {\n        throw err;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/tasks/LargeFileUploadTask.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { Range } from \"../Range\";\r\n/**\r\n * @class\r\n * Class representing LargeFileUploadTask\r\n */\r\nexport class LargeFileUploadTask {\r\n    /**\r\n     * @public\r\n     * @constructor\r\n     * Constructs a LargeFileUploadTask\r\n     * @param {Client} client - The GraphClient instance\r\n     * @param {FileObject} file - The FileObject holding details of a file that needs to be uploaded\r\n     * @param {LargeFileUploadSession} uploadSession - The upload session to which the upload has to be done\r\n     * @param {LargeFileUploadTaskOptions} options - The upload task options\r\n     * @returns An instance of LargeFileUploadTask\r\n     */\r\n    constructor(client, file, uploadSession, options = {}) {\r\n        /**\r\n         * @private\r\n         * Default value for the rangeSize\r\n         */\r\n        this.DEFAULT_FILE_SIZE = 5 * 1024 * 1024;\r\n        this.client = client;\r\n        this.file = file;\r\n        if (options.rangeSize === undefined) {\r\n            options.rangeSize = this.DEFAULT_FILE_SIZE;\r\n        }\r\n        this.options = options;\r\n        this.uploadSession = uploadSession;\r\n        this.nextRange = new Range(0, this.options.rangeSize - 1);\r\n    }\r\n    /**\r\n     * @public\r\n     * @static\r\n     * @async\r\n     * Makes request to the server to create an upload session\r\n     * @param {Client} client - The GraphClient instance\r\n     * @param {any} payload - The payload that needs to be sent\r\n     * @param {KeyValuePairObjectStringNumber} headers - The headers that needs to be sent\r\n     * @returns The promise that resolves to LargeFileUploadSession\r\n     */\r\n    static createUploadSession(client, requestUrl, payload, headers = {}) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const session = yield client\r\n                    .api(requestUrl)\r\n                    .headers(headers)\r\n                    .post(payload);\r\n                const largeFileUploadSession = {\r\n                    url: session.uploadUrl,\r\n                    expiry: new Date(session.expirationDateTime),\r\n                };\r\n                return largeFileUploadSession;\r\n            }\r\n            catch (err) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @private\r\n     * Parses given range string to the Range instance\r\n     * @param {string[]} ranges - The ranges value\r\n     * @returns The range instance\r\n     */\r\n    parseRange(ranges) {\r\n        const rangeStr = ranges[0];\r\n        if (typeof rangeStr === \"undefined\" || rangeStr === \"\") {\r\n            return new Range();\r\n        }\r\n        const firstRange = rangeStr.split(\"-\");\r\n        const minVal = parseInt(firstRange[0], 10);\r\n        let maxVal = parseInt(firstRange[1], 10);\r\n        if (Number.isNaN(maxVal)) {\r\n            maxVal = this.file.size - 1;\r\n        }\r\n        return new Range(minVal, maxVal);\r\n    }\r\n    /**\r\n     * @private\r\n     * Updates the expiration date and the next range\r\n     * @param {UploadStatusResponse} response - The response of the upload status\r\n     * @returns Nothing\r\n     */\r\n    updateTaskStatus(response) {\r\n        this.uploadSession.expiry = new Date(response.expirationDateTime);\r\n        this.nextRange = this.parseRange(response.nextExpectedRanges);\r\n    }\r\n    /**\r\n     * @public\r\n     * Gets next range that needs to be uploaded\r\n     * @returns The range instance\r\n     */\r\n    getNextRange() {\r\n        if (this.nextRange.minValue === -1) {\r\n            return this.nextRange;\r\n        }\r\n        const minVal = this.nextRange.minValue;\r\n        let maxValue = minVal + this.options.rangeSize - 1;\r\n        if (maxValue >= this.file.size) {\r\n            maxValue = this.file.size - 1;\r\n        }\r\n        return new Range(minVal, maxValue);\r\n    }\r\n    /**\r\n     * @public\r\n     * Slices the file content to the given range\r\n     * @param {Range} range - The range value\r\n     * @returns The sliced ArrayBuffer or Blob\r\n     */\r\n    sliceFile(range) {\r\n        const blob = this.file.content.slice(range.minValue, range.maxValue + 1);\r\n        return blob;\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Uploads file to the server in a sequential order by slicing the file\r\n     * @returns The promise resolves to uploaded response\r\n     */\r\n    upload() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                while (true) {\r\n                    const nextRange = this.getNextRange();\r\n                    if (nextRange.maxValue === -1) {\r\n                        const err = new Error(\"Task with which you are trying to upload is already completed, Please check for your uploaded file\");\r\n                        err.name = \"Invalid Session\";\r\n                        throw err;\r\n                    }\r\n                    const fileSlice = this.sliceFile(nextRange);\r\n                    const response = yield this.uploadSlice(fileSlice, nextRange, this.file.size);\r\n                    // Upon completion of upload process incase of onedrive, driveItem is returned, which contains id\r\n                    if (response.id !== undefined) {\r\n                        return response;\r\n                    }\r\n                    else {\r\n                        this.updateTaskStatus(response);\r\n                    }\r\n                }\r\n            }\r\n            catch (err) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Uploads given slice to the server\r\n     * @param {ArrayBuffer | Blob | File} fileSlice - The file slice\r\n     * @param {Range} range - The range value\r\n     * @param {number} totalSize - The total size of a complete file\r\n     */\r\n    uploadSlice(fileSlice, range, totalSize) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                return yield this.client\r\n                    .api(this.uploadSession.url)\r\n                    .headers({\r\n                    \"Content-Length\": `${range.maxValue - range.minValue + 1}`,\r\n                    \"Content-Range\": `bytes ${range.minValue}-${range.maxValue}/${totalSize}`,\r\n                })\r\n                    .put(fileSlice);\r\n            }\r\n            catch (err) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Deletes upload session in the server\r\n     * @returns The promise resolves to cancelled response\r\n     */\r\n    cancel() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                return yield this.client.api(this.uploadSession.url).delete();\r\n            }\r\n            catch (err) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Gets status for the upload session\r\n     * @returns The promise resolves to the status enquiry response\r\n     */\r\n    getStatus() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                const response = yield this.client.api(this.uploadSession.url).get();\r\n                this.updateTaskStatus(response);\r\n                return response;\r\n            }\r\n            catch (err) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @async\r\n     * Resumes upload session and continue uploading the file from the last sent range\r\n     * @returns The promise resolves to the uploaded response\r\n     */\r\n    resume() {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                yield this.getStatus();\r\n                return yield this.upload();\r\n            }\r\n            catch (err) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=LargeFileUploadTask.js.map"]},"metadata":{},"sourceType":"module"}