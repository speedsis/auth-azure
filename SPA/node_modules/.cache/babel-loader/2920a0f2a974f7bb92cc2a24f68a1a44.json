{"ast":null,"code":"/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\nimport * as tslib_1 from \"tslib\";\nimport { ResponseType } from \"./ResponseType\";\n/**\r\n * @enum\r\n * Enum for document types\r\n * @property {string} TEXT_HTML - The text/html content type\r\n * @property {string} TEXT_XML - The text/xml content type\r\n * @property {string} APPLICATION_XML - The application/xml content type\r\n * @property {string} APPLICATION_XHTML - The application/xhml+xml content type\r\n */\n\nexport var DocumentType;\n\n(function (DocumentType) {\n  DocumentType[\"TEXT_HTML\"] = \"text/html\";\n  DocumentType[\"TEXT_XML\"] = \"text/xml\";\n  DocumentType[\"APPLICATION_XML\"] = \"application/xml\";\n  DocumentType[\"APPLICATION_XHTML\"] = \"application/xhtml+xml\";\n})(DocumentType || (DocumentType = {}));\n/**\r\n * @enum\r\n * Enum for Content types\r\n * @property {string} TEXT_PLAIN - The text/plain content type\r\n * @property {string} APPLICATION_JSON - The application/json content type\r\n */\n\n\nvar ContentType;\n\n(function (ContentType) {\n  ContentType[\"TEXT_PLAIN\"] = \"text/plain\";\n  ContentType[\"APPLICATION_JSON\"] = \"application/json\";\n})(ContentType || (ContentType = {}));\n/**\r\n * @enum\r\n * Enum for Content type regex\r\n * @property {string} DOCUMENT - The regex to match document content types\r\n * @property {string} IMAGE - The regex to match image content types\r\n */\n\n\nvar ContentTypeRegexStr;\n\n(function (ContentTypeRegexStr) {\n  ContentTypeRegexStr[\"DOCUMENT\"] = \"^(text\\\\/(html|xml))|(application\\\\/(xml|xhtml\\\\+xml))$\";\n  ContentTypeRegexStr[\"IMAGE\"] = \"^image\\\\/.+\";\n})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));\n/**\r\n * @class\r\n * Class for GraphResponseHandler\r\n */\n\n\nexport class GraphResponseHandler {\n  /**\r\n   * @private\r\n   * @static\r\n   * To parse Document response\r\n   * @param {Response} rawResponse - The response object\r\n   * @param {DocumentType} type - The type to which the document needs to be parsed\r\n   * @returns A promise that resolves to a document content\r\n   */\n  static parseDocumentResponse(rawResponse, type) {\n    try {\n      if (typeof DOMParser !== \"undefined\") {\n        return new Promise((resolve, reject) => {\n          rawResponse.text().then(xmlString => {\n            try {\n              const parser = new DOMParser();\n              const xmlDoc = parser.parseFromString(xmlString, type);\n              resolve(xmlDoc);\n            } catch (error) {\n              reject(error);\n            }\n          });\n        });\n      } else {\n        return Promise.resolve(rawResponse.body);\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n  /**\r\n   * @private\r\n   * @static\r\n   * @async\r\n   * To convert the native Response to response content\r\n   * @param {Response} rawResponse - The response object\r\n   * @param {ResponseType} [responseType] - The response type value\r\n   * @returns A promise that resolves to the converted response content\r\n   */\n\n\n  static convertResponse(rawResponse, responseType) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      if (rawResponse.status === 204) {\n        // NO CONTENT\n        return Promise.resolve();\n      }\n\n      let responseValue;\n\n      try {\n        switch (responseType) {\n          case ResponseType.ARRAYBUFFER:\n            responseValue = yield rawResponse.arrayBuffer();\n            break;\n\n          case ResponseType.BLOB:\n            responseValue = yield rawResponse.blob();\n            break;\n\n          case ResponseType.DOCUMENT:\n            responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);\n            break;\n\n          case ResponseType.JSON:\n            responseValue = yield rawResponse.json();\n            break;\n\n          case ResponseType.STREAM:\n            responseValue = yield Promise.resolve(rawResponse.body);\n            break;\n\n          case ResponseType.TEXT:\n            responseValue = yield rawResponse.text();\n            break;\n\n          default:\n            const contentType = rawResponse.headers.get(\"Content-type\");\n\n            if (contentType !== null) {\n              const mimeType = contentType.split(\";\")[0];\n\n              if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {\n                responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);\n              } else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {\n                responseValue = rawResponse.blob();\n              } else if (mimeType === ContentType.TEXT_PLAIN) {\n                responseValue = yield rawResponse.text();\n              } else if (mimeType === ContentType.APPLICATION_JSON) {\n                responseValue = yield rawResponse.json();\n              } else {\n                responseValue = Promise.resolve(rawResponse.body);\n              }\n            } else {\n              /**\r\n               * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:\r\n               *  A sender that generates a message containing a payload body SHOULD\r\n               *  generate a Content-Type header field in that message unless the\r\n               *  intended media type of the enclosed representation is unknown to the\r\n               *  sender.  If a Content-Type header field is not present, the recipient\r\n               *  MAY either assume a media type of \"application/octet-stream\"\r\n               *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.\r\n               *\r\n               *  So assuming it as a stream type so returning the body.\r\n               */\n              responseValue = Promise.resolve(rawResponse.body);\n            }\n\n            break;\n        }\n      } catch (error) {\n        throw error;\n      }\n\n      return responseValue;\n    });\n  }\n  /**\r\n   * @public\r\n   * @static\r\n   * @async\r\n   * To get the parsed response\r\n   * @param {Response} rawResponse - The response object\r\n   * @param {ResponseType} [responseType] - The response type value\r\n   * @param {GraphRequestCallback} [callback] - The graph request callback function\r\n   * @returns The parsed response\r\n   */\n\n\n  static getResponse(rawResponse, responseType, callback) {\n    return tslib_1.__awaiter(this, void 0, void 0, function* () {\n      try {\n        if (responseType === ResponseType.RAW) {\n          return Promise.resolve(rawResponse);\n        } else {\n          const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);\n\n          if (rawResponse.ok) {\n            // Status Code 2XX\n            if (typeof callback === \"function\") {\n              callback(null, response);\n            } else {\n              return response;\n            }\n          } else {\n            // NOT OK Response\n            throw response;\n          }\n        }\n      } catch (error) {\n        throw error;\n      }\n    });\n  }\n\n}","map":{"version":3,"sources":["../../src/GraphResponseHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\r\n * -------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\r\n * See License in the project root for license information.\r\n * -------------------------------------------------------------------------------------------\r\n */\r\nimport * as tslib_1 from \"tslib\";\r\nimport { ResponseType } from \"./ResponseType\";\r\n/**\r\n * @enum\r\n * Enum for document types\r\n * @property {string} TEXT_HTML - The text/html content type\r\n * @property {string} TEXT_XML - The text/xml content type\r\n * @property {string} APPLICATION_XML - The application/xml content type\r\n * @property {string} APPLICATION_XHTML - The application/xhml+xml content type\r\n */\r\nexport var DocumentType;\r\n(function (DocumentType) {\r\n    DocumentType[\"TEXT_HTML\"] = \"text/html\";\r\n    DocumentType[\"TEXT_XML\"] = \"text/xml\";\r\n    DocumentType[\"APPLICATION_XML\"] = \"application/xml\";\r\n    DocumentType[\"APPLICATION_XHTML\"] = \"application/xhtml+xml\";\r\n})(DocumentType || (DocumentType = {}));\r\n/**\r\n * @enum\r\n * Enum for Content types\r\n * @property {string} TEXT_PLAIN - The text/plain content type\r\n * @property {string} APPLICATION_JSON - The application/json content type\r\n */\r\nvar ContentType;\r\n(function (ContentType) {\r\n    ContentType[\"TEXT_PLAIN\"] = \"text/plain\";\r\n    ContentType[\"APPLICATION_JSON\"] = \"application/json\";\r\n})(ContentType || (ContentType = {}));\r\n/**\r\n * @enum\r\n * Enum for Content type regex\r\n * @property {string} DOCUMENT - The regex to match document content types\r\n * @property {string} IMAGE - The regex to match image content types\r\n */\r\nvar ContentTypeRegexStr;\r\n(function (ContentTypeRegexStr) {\r\n    ContentTypeRegexStr[\"DOCUMENT\"] = \"^(text\\\\/(html|xml))|(application\\\\/(xml|xhtml\\\\+xml))$\";\r\n    ContentTypeRegexStr[\"IMAGE\"] = \"^image\\\\/.+\";\r\n})(ContentTypeRegexStr || (ContentTypeRegexStr = {}));\r\n/**\r\n * @class\r\n * Class for GraphResponseHandler\r\n */\r\nexport class GraphResponseHandler {\r\n    /**\r\n     * @private\r\n     * @static\r\n     * To parse Document response\r\n     * @param {Response} rawResponse - The response object\r\n     * @param {DocumentType} type - The type to which the document needs to be parsed\r\n     * @returns A promise that resolves to a document content\r\n     */\r\n    static parseDocumentResponse(rawResponse, type) {\r\n        try {\r\n            if (typeof DOMParser !== \"undefined\") {\r\n                return new Promise((resolve, reject) => {\r\n                    rawResponse.text().then((xmlString) => {\r\n                        try {\r\n                            const parser = new DOMParser();\r\n                            const xmlDoc = parser.parseFromString(xmlString, type);\r\n                            resolve(xmlDoc);\r\n                        }\r\n                        catch (error) {\r\n                            reject(error);\r\n                        }\r\n                    });\r\n                });\r\n            }\r\n            else {\r\n                return Promise.resolve(rawResponse.body);\r\n            }\r\n        }\r\n        catch (error) {\r\n            throw error;\r\n        }\r\n    }\r\n    /**\r\n     * @private\r\n     * @static\r\n     * @async\r\n     * To convert the native Response to response content\r\n     * @param {Response} rawResponse - The response object\r\n     * @param {ResponseType} [responseType] - The response type value\r\n     * @returns A promise that resolves to the converted response content\r\n     */\r\n    static convertResponse(rawResponse, responseType) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            if (rawResponse.status === 204) {\r\n                // NO CONTENT\r\n                return Promise.resolve();\r\n            }\r\n            let responseValue;\r\n            try {\r\n                switch (responseType) {\r\n                    case ResponseType.ARRAYBUFFER:\r\n                        responseValue = yield rawResponse.arrayBuffer();\r\n                        break;\r\n                    case ResponseType.BLOB:\r\n                        responseValue = yield rawResponse.blob();\r\n                        break;\r\n                    case ResponseType.DOCUMENT:\r\n                        responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, DocumentType.TEXT_XML);\r\n                        break;\r\n                    case ResponseType.JSON:\r\n                        responseValue = yield rawResponse.json();\r\n                        break;\r\n                    case ResponseType.STREAM:\r\n                        responseValue = yield Promise.resolve(rawResponse.body);\r\n                        break;\r\n                    case ResponseType.TEXT:\r\n                        responseValue = yield rawResponse.text();\r\n                        break;\r\n                    default:\r\n                        const contentType = rawResponse.headers.get(\"Content-type\");\r\n                        if (contentType !== null) {\r\n                            const mimeType = contentType.split(\";\")[0];\r\n                            if (new RegExp(ContentTypeRegexStr.DOCUMENT).test(mimeType)) {\r\n                                responseValue = yield GraphResponseHandler.parseDocumentResponse(rawResponse, mimeType);\r\n                            }\r\n                            else if (new RegExp(ContentTypeRegexStr.IMAGE).test(mimeType)) {\r\n                                responseValue = rawResponse.blob();\r\n                            }\r\n                            else if (mimeType === ContentType.TEXT_PLAIN) {\r\n                                responseValue = yield rawResponse.text();\r\n                            }\r\n                            else if (mimeType === ContentType.APPLICATION_JSON) {\r\n                                responseValue = yield rawResponse.json();\r\n                            }\r\n                            else {\r\n                                responseValue = Promise.resolve(rawResponse.body);\r\n                            }\r\n                        }\r\n                        else {\r\n                            /**\r\n                             * RFC specification {@link https://tools.ietf.org/html/rfc7231#section-3.1.1.5} says:\r\n                             *  A sender that generates a message containing a payload body SHOULD\r\n                             *  generate a Content-Type header field in that message unless the\r\n                             *  intended media type of the enclosed representation is unknown to the\r\n                             *  sender.  If a Content-Type header field is not present, the recipient\r\n                             *  MAY either assume a media type of \"application/octet-stream\"\r\n                             *  ([RFC2046], Section 4.5.1) or examine the data to determine its type.\r\n                             *\r\n                             *  So assuming it as a stream type so returning the body.\r\n                             */\r\n                            responseValue = Promise.resolve(rawResponse.body);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n            return responseValue;\r\n        });\r\n    }\r\n    /**\r\n     * @public\r\n     * @static\r\n     * @async\r\n     * To get the parsed response\r\n     * @param {Response} rawResponse - The response object\r\n     * @param {ResponseType} [responseType] - The response type value\r\n     * @param {GraphRequestCallback} [callback] - The graph request callback function\r\n     * @returns The parsed response\r\n     */\r\n    static getResponse(rawResponse, responseType, callback) {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function* () {\r\n            try {\r\n                if (responseType === ResponseType.RAW) {\r\n                    return Promise.resolve(rawResponse);\r\n                }\r\n                else {\r\n                    const response = yield GraphResponseHandler.convertResponse(rawResponse, responseType);\r\n                    if (rawResponse.ok) {\r\n                        // Status Code 2XX\r\n                        if (typeof callback === \"function\") {\r\n                            callback(null, response);\r\n                        }\r\n                        else {\r\n                            return response;\r\n                        }\r\n                    }\r\n                    else {\r\n                        // NOT OK Response\r\n                        throw response;\r\n                    }\r\n                }\r\n            }\r\n            catch (error) {\r\n                throw error;\r\n            }\r\n        });\r\n    }\r\n}\r\n//# sourceMappingURL=GraphResponseHandler.js.map"]},"metadata":{},"sourceType":"module"}